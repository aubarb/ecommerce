{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nvar __markAsModule = target => __defProp(target, \"__esModule\", {\n  value: true\n});\n\nvar __export = (target, all) => {\n  __markAsModule(target);\n\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n\n__export(exports, {\n  OracleQuery: () => OracleQuery\n});\n\nconst AbstractQuery = require(\"../abstract/query\");\n\nconst SequelizeErrors = require(\"../../errors\");\n\nconst parserStore = require(\"../parserStore\")(\"oracle\");\n\nconst _ = require(\"lodash\");\n\nconst Utils = require(\"../../utils\");\n\nconst {\n  logger\n} = require(\"../../utils/logger\");\n\nconst debug = logger.debugContext(\"sql:oracle\");\n\nclass OracleQuery extends AbstractQuery {\n  constructor(connection, sequelize, options) {\n    super(connection, sequelize, options);\n    this.options = _.extend({\n      logging: console.log,\n      plain: false,\n      raw: false\n    }, options || {});\n    this.checkLoggingOption();\n    this.outFormat = options.outFormat || this.sequelize.connectionManager.lib.OBJECT;\n  }\n\n  getInsertIdField() {\n    return \"id\";\n  }\n\n  getExecOptions() {\n    const execOpts = {\n      outFormat: this.outFormat,\n      autoCommit: this.autoCommit\n    };\n    const oracledb = this.sequelize.connectionManager.lib;\n\n    if (this.model && this.isSelectQuery()) {\n      const fInfo = {};\n      const keys = Object.keys(this.model.tableAttributes);\n\n      for (const key of keys) {\n        const keyValue = this.model.tableAttributes[key];\n\n        if (keyValue.type.key === \"DECIMAL\") {\n          fInfo[key] = {\n            type: oracledb.STRING\n          };\n        }\n\n        if (keyValue.type.key === \"BIGINT\") {\n          fInfo[key] = {\n            type: oracledb.STRING\n          };\n        }\n      }\n\n      if (fInfo) {\n        execOpts.fetchInfo = fInfo;\n      }\n    }\n\n    return execOpts;\n  }\n\n  _convertBindAttributes(bindingDictionary, oracledb) {\n    if (this.model && this.options[bindingDictionary]) {\n      const keys = Object.keys(this.model.tableAttributes);\n\n      for (const key of keys) {\n        const keyValue = this.model.tableAttributes[key];\n\n        if (keyValue.type.key === \"BIGINT\") {\n          const oldBinding = this.options[bindingDictionary][key];\n\n          if (oldBinding) {\n            this.options[bindingDictionary][key] = __spreadProps(__spreadValues({}, oldBinding), {\n              type: oracledb.STRING,\n              maxSize: 1e7\n            });\n          }\n        }\n      }\n    }\n  }\n\n  async run(sql, parameters) {\n    const oracledb = this.sequelize.connectionManager.lib;\n\n    const complete = this._logQuery(sql, debug, parameters);\n\n    const outParameters = [];\n    const bindParameters = [];\n    const bindDef = [];\n\n    if (!sql.match(/END;$/)) {\n      this.sql = sql.replace(/; *$/, \"\");\n    } else {\n      this.sql = sql;\n    }\n\n    if (this.options.outBindAttributes && (Array.isArray(parameters) || _.isPlainObject(parameters))) {\n      this._convertBindAttributes(\"outBindAttributes\", oracledb);\n\n      outParameters.push(...Object.values(this.options.outBindAttributes));\n\n      if (this.isUpsertQuery()) {\n        outParameters.push({\n          dir: oracledb.BIND_OUT\n        });\n      }\n    }\n\n    this.bindParameters = outParameters;\n\n    if (Array.isArray(parameters) || _.isPlainObject(parameters)) {\n      if (this.options.executeMany) {\n        this._convertBindAttributes(\"inbindAttributes\", oracledb);\n\n        bindDef.push(...Object.values(this.options.inbindAttributes));\n        bindDef.push(...outParameters);\n        this.bindParameters = parameters;\n      } else {\n        Object.values(parameters).forEach(value => {\n          bindParameters.push(value);\n        });\n        bindParameters.push(...outParameters);\n        Object.assign(this.bindParameters, bindParameters);\n      }\n    }\n\n    if (this.sql.startsWith(\"BEGIN TRANSACTION\")) {\n      this.autocommit = false;\n      return Promise.resolve();\n    }\n\n    if (this.sql.startsWith(\"SET AUTOCOMMIT ON\")) {\n      this.autocommit = true;\n      return Promise.resolve();\n    }\n\n    if (this.sql.startsWith(\"SET AUTOCOMMIT OFF\")) {\n      this.autocommit = false;\n      return Promise.resolve();\n    }\n\n    if (this.sql.startsWith(\"DECLARE x NUMBER\")) {\n      if (this.autoCommit === void 0) {\n        if (this.connection.uuid) {\n          this.autoCommit = false;\n        } else {\n          this.autoCommit = true;\n        }\n      }\n\n      try {\n        await this.connection.execute(this.sql, this.bindParameters, {\n          autoCommit: this.autoCommit\n        });\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n\n    if (this.sql.startsWith(\"BEGIN\")) {\n      if (this.autoCommit === void 0) {\n        if (this.connection.uuid) {\n          this.autoCommit = false;\n        } else {\n          this.autoCommit = true;\n        }\n      }\n\n      try {\n        const result = await this.connection.execute(this.sql, this.bindParameters, {\n          outFormat: this.outFormat,\n          autoCommit: this.autoCommit\n        });\n\n        if (!Array.isArray(result.outBinds)) {\n          return [result.outBinds];\n        }\n\n        return result.outBinds;\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n\n    if (this.sql.startsWith(\"COMMIT TRANSACTION\")) {\n      try {\n        await this.connection.commit();\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n\n    if (this.sql.startsWith(\"ROLLBACK TRANSACTION\")) {\n      try {\n        await this.connection.rollback();\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n\n    if (this.sql.startsWith(\"SET TRANSACTION\")) {\n      try {\n        await this.connection.execute(this.sql, [], {\n          autoCommit: false\n        });\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n\n    if (this.autoCommit === void 0) {\n      if (this.connection.uuid) {\n        this.autoCommit = false;\n      } else {\n        this.autoCommit = true;\n      }\n    }\n\n    if (\"inputParameters\" in this.options && this.options.inputParameters !== null) {\n      Object.assign(this.bindParameters, this.options.inputParameters);\n    }\n\n    const execOpts = this.getExecOptions();\n\n    if (this.options.executeMany && bindDef.length > 0) {\n      execOpts.bindDefs = bindDef;\n    }\n\n    const executePromise = this.options.executeMany ? this.connection.executeMany(this.sql, this.bindParameters, execOpts) : this.connection.execute(this.sql, this.bindParameters, execOpts);\n\n    try {\n      const result = await executePromise;\n      return this.formatResults(result);\n    } catch (error) {\n      throw this.formatError(error);\n    } finally {\n      complete();\n    }\n  }\n\n  static formatBindParameters(sql, values, dialect) {\n    const replacementFunc = (match, key, values2) => {\n      if (values2[key] !== void 0) {\n        return `:${key}`;\n      }\n\n      return void 0;\n    };\n\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    return [sql, values];\n  }\n\n  _getAttributeMap(attrsMap, rawAttributes) {\n    attrsMap = Object.assign(attrsMap, _.reduce(rawAttributes, (mp, _2, key) => {\n      const catalogKey = this.sequelize.queryInterface.queryGenerator.getCatalogName(key);\n      mp[catalogKey] = key;\n      return mp;\n    }, {}));\n  }\n\n  _processRows(rows) {\n    let result = rows;\n    let attrsMap = {};\n\n    if (this.sequelize.options.quoteIdentifiers === false) {\n      attrsMap = _.reduce(this.options.attributes, (mp, v) => {\n        if (typeof v === \"object\") {\n          v = v[1];\n        }\n\n        const catalogv = this.sequelize.queryInterface.queryGenerator.getCatalogName(v);\n        mp[catalogv] = v;\n        return mp;\n      }, {});\n\n      if (this.model) {\n        this._getAttributeMap(attrsMap, this.model.rawAttributes);\n      }\n\n      if (this.options.aliasesMapping) {\n        const obj = Object.fromEntries(this.options.aliasesMapping);\n        rows = rows.map(row => _.toPairs(row).reduce((acc, _ref) => {\n          let [key, value] = _ref;\n          const mapping = Object.values(obj).find(element => {\n            const catalogElement = this.sequelize.queryInterface.queryGenerator.getCatalogName(element);\n            return catalogElement === key;\n          });\n          if (mapping) acc[mapping || key] = value;\n          return acc;\n        }, {}));\n      }\n\n      result = rows.map(row => {\n        return _.mapKeys(row, (value, key) => {\n          const targetAttr = attrsMap[key];\n\n          if (typeof targetAttr === \"string\" && targetAttr !== key) {\n            return targetAttr;\n          }\n\n          return key;\n        });\n      });\n    }\n\n    if (this.model) {\n      result = result.map(row => {\n        return _.mapValues(row, (value, key) => {\n          if (this.model.rawAttributes[key] && this.model.rawAttributes[key].type) {\n            let typeid = this.model.rawAttributes[key].type.toLocaleString();\n\n            if (this.model.rawAttributes[key].type.key === \"JSON\") {\n              value = JSON.parse(value);\n            }\n\n            if (typeid.indexOf(\"(\") > -1 && this.model.rawAttributes[key].type.key !== \"BOOLEAN\") {\n              typeid = typeid.substr(0, typeid.indexOf(\"(\"));\n            }\n\n            const parse = parserStore.get(typeid);\n\n            if (value !== null & !!parse) {\n              value = parse(value);\n            }\n          }\n\n          return value;\n        });\n      });\n    }\n\n    return result;\n  }\n\n  formatResults(data) {\n    let result = this.instance;\n\n    if (this.isInsertQuery(data)) {\n      let insertData;\n\n      if (data.outBinds) {\n        const keys = Object.keys(this.options.outBindAttributes);\n        insertData = data.outBinds;\n\n        if (this.instance) {\n          insertData = [insertData];\n        }\n\n        const res = insertData.map(row => {\n          const obj = {};\n          row.forEach((element, index) => {\n            obj[keys[index]] = element[0];\n          });\n          return obj;\n        });\n        insertData = res;\n\n        if (!this.instance) {\n          result = res;\n        }\n      }\n\n      this.handleInsertQuery(insertData);\n      return [result, data.rowsAffected];\n    }\n\n    if (this.isShowTablesQuery()) {\n      result = this.handleShowTablesQuery(data.rows);\n    } else if (this.isDescribeQuery()) {\n      result = {};\n      const table = Object.keys(this.sequelize.models);\n      const modelAttributes = {};\n\n      if (this.sequelize.models && table.length > 0) {\n        this._getAttributeMap(modelAttributes, this.sequelize.models[table[0]].rawAttributes);\n      }\n\n      data.rows.forEach(_result => {\n        if (_result.Default) {\n          _result.Default = _result.Default.replace(\"('\", \"\").replace(\"')\", \"\").replace(/'/g, \"\");\n        }\n\n        if (!(modelAttributes[_result.COLUMN_NAME] in result)) {\n          let key = modelAttributes[_result.COLUMN_NAME];\n\n          if (!key) {\n            key = _result.COLUMN_NAME;\n          }\n\n          result[key] = {\n            type: _result.DATA_TYPE.toUpperCase(),\n            allowNull: _result.NULLABLE === \"N\" ? false : true,\n            defaultValue: void 0,\n            primaryKey: _result.CONSTRAINT_TYPE === \"P\"\n          };\n        }\n      });\n    } else if (this.isShowIndexesQuery()) {\n      result = this.handleShowIndexesQuery(data.rows);\n    } else if (this.isSelectQuery()) {\n      const rows = data.rows;\n\n      const result2 = this._processRows(rows);\n\n      return this.handleSelectQuery(result2);\n    } else if (this.isCallQuery()) {\n      result = data.rows[0];\n    } else if (this.isUpdateQuery()) {\n      result = [result, data.rowsAffected];\n    } else if (this.isBulkUpdateQuery()) {\n      result = data.rowsAffected;\n    } else if (this.isBulkDeleteQuery()) {\n      result = data.rowsAffected;\n    } else if (this.isVersionQuery()) {\n      const version = data.rows[0].VERSION_FULL;\n\n      if (version) {\n        const versions = version.split(\".\");\n        result = `${versions[0]}.${versions[1]}.${versions[2]}`;\n      } else {\n        result = \"0.0.0\";\n      }\n    } else if (this.isForeignKeysQuery()) {\n      result = data.rows;\n    } else if (this.isUpsertQuery()) {\n      data = data.outBinds;\n      const keys = Object.keys(this.options.outBindAttributes);\n      const obj = {};\n\n      for (const k in keys) {\n        obj[keys[k]] = data[k];\n      }\n\n      obj.isUpdate = data[data.length - 1];\n      data = obj;\n      result = [{\n        isNewRecord: data.isUpdate,\n        value: data\n      }, data.isUpdate == 0];\n    } else if (this.isShowConstraintsQuery()) {\n      result = this.handleShowConstraintsQuery(data);\n    } else if (this.isRawQuery()) {\n      if (data && data.rows) {\n        return [data.rows, data.metaData];\n      }\n\n      return [data, data];\n    }\n\n    return result;\n  }\n\n  handleShowConstraintsQuery(data) {\n    return data.rows.map(result => {\n      const constraint = {};\n\n      for (const key in result) {\n        constraint[_.camelCase(key)] = result[key].toLowerCase();\n      }\n\n      return constraint;\n    });\n  }\n\n  handleShowTablesQuery(results) {\n    return results.map(resultSet => {\n      return {\n        tableName: resultSet.TABLE_NAME,\n        schema: resultSet.TABLE_SCHEMA\n      };\n    });\n  }\n\n  formatError(err) {\n    let match;\n    match = err.message.match(/unique constraint ([\\s\\S]*) violated/);\n\n    if (match && match.length > 1) {\n      match[1] = match[1].replace(\"(\", \"\").replace(\")\", \"\").split(\".\")[1];\n      const errors = [];\n      let fields = [],\n          message = \"Validation error\",\n          uniqueKey = null;\n\n      if (this.model) {\n        const uniqueKeys = Object.keys(this.model.uniqueKeys);\n        const currKey = uniqueKeys.find(key => {\n          return key.toUpperCase() === match[1].toUpperCase() || key.toUpperCase() === `\"${match[1].toUpperCase()}\"`;\n        });\n\n        if (currKey) {\n          uniqueKey = this.model.uniqueKeys[currKey];\n          fields = uniqueKey.fields;\n        }\n\n        if (uniqueKey && !!uniqueKey.msg) {\n          message = uniqueKey.msg;\n        }\n\n        fields.forEach(field => {\n          errors.push(new SequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, null));\n        });\n      }\n\n      return new SequelizeErrors.UniqueConstraintError({\n        message,\n        errors,\n        err,\n        fields\n      });\n    }\n\n    match = err.message.match(/ORA-02291/) || err.message.match(/ORA-02292/);\n\n    if (match && match.length > 0) {\n      return new SequelizeErrors.ForeignKeyConstraintError({\n        fields: null,\n        index: match[1],\n        parent: err\n      });\n    }\n\n    match = err.message.match(/ORA-02443/);\n\n    if (match && match.length > 0) {\n      return new SequelizeErrors.UnknownConstraintError(match[1]);\n    }\n\n    return new SequelizeErrors.DatabaseError(err);\n  }\n\n  isShowIndexesQuery() {\n    return this.sql.indexOf(\"SELECT i.index_name,i.table_name, i.column_name, u.uniqueness\") > -1;\n  }\n\n  isSelectCountQuery() {\n    return this.sql.toUpperCase().indexOf(\"SELECT COUNT(\") > -1;\n  }\n\n  handleShowIndexesQuery(data) {\n    const acc = [];\n    data.forEach(indexRecord => {\n      if (!acc[indexRecord.INDEX_NAME]) {\n        acc[indexRecord.INDEX_NAME] = {\n          unique: indexRecord.UNIQUENESS === \"UNIQUE\" ? true : false,\n          primary: indexRecord.CONSTRAINT_TYPE === \"P\",\n          name: indexRecord.INDEX_NAME.toLowerCase(),\n          tableName: indexRecord.TABLE_NAME.toLowerCase(),\n          type: void 0\n        };\n        acc[indexRecord.INDEX_NAME].fields = [];\n      }\n\n      acc[indexRecord.INDEX_NAME].fields.push({\n        attribute: indexRecord.COLUMN_NAME,\n        length: void 0,\n        order: indexRecord.DESCEND,\n        collate: void 0\n      });\n    });\n    const returnIndexes = [];\n    const accKeys = Object.keys(acc);\n\n    for (const accKey of accKeys) {\n      const columns = {};\n      columns.fields = acc[accKey].fields;\n\n      if (acc[accKey].name.match(/sys_c[0-9]*/)) {\n        acc[accKey].name = Utils.nameIndex(columns, acc[accKey].tableName).name;\n      }\n\n      returnIndexes.push(acc[accKey]);\n    }\n\n    return returnIndexes;\n  }\n\n  handleInsertQuery(results, metaData) {\n    if (this.instance && results.length > 0) {\n      if (\"pkReturnVal\" in results[0]) {\n        results[0][this.model.primaryKeyAttribute] = results[0].pkReturnVal;\n        delete results[0].pkReturnVal;\n      }\n\n      const autoIncrementField = this.model.autoIncrementAttribute;\n      let autoIncrementFieldAlias = null,\n          id = null;\n      if (Object.prototype.hasOwnProperty.call(this.model.rawAttributes, autoIncrementField) && this.model.rawAttributes[autoIncrementField].field !== void 0) autoIncrementFieldAlias = this.model.rawAttributes[autoIncrementField].field;\n      id = id || results && results[0][this.getInsertIdField()];\n      id = id || metaData && metaData[this.getInsertIdField()];\n      id = id || results && results[0][autoIncrementField];\n      id = id || autoIncrementFieldAlias && results && results[0][autoIncrementFieldAlias];\n      this.instance[autoIncrementField] = id;\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["__export","OracleQuery","AbstractQuery","require","SequelizeErrors","parserStore","_","Utils","logger","debug","debugContext","constructor","connection","sequelize","options","extend","logging","console","log","plain","raw","checkLoggingOption","outFormat","connectionManager","lib","OBJECT","getInsertIdField","getExecOptions","execOpts","autoCommit","oracledb","model","isSelectQuery","fInfo","keys","Object","tableAttributes","key","keyValue","type","STRING","fetchInfo","_convertBindAttributes","bindingDictionary","oldBinding","__spreadProps","maxSize","sql","parameters","complete","_logQuery","outParameters","bindParameters","bindDef","match","replace","outBindAttributes","Array","isArray","isPlainObject","push","values","isUpsertQuery","dir","BIND_OUT","executeMany","inbindAttributes","forEach","value","assign","startsWith","autocommit","Promise","resolve","uuid","execute","create","error","formatError","result","outBinds","commit","rollback","inputParameters","length","bindDefs","executePromise","formatResults","dialect","replacementFunc","values2","formatBindParameters","_getAttributeMap","attrsMap","rawAttributes","reduce","mp","_2","catalogKey","queryInterface","queryGenerator","getCatalogName","_processRows","rows","quoteIdentifiers","attributes","v","catalogv","aliasesMapping","obj","fromEntries","map","row","toPairs","acc","mapping","find","element","catalogElement","mapKeys","targetAttr","mapValues","typeid","toLocaleString","JSON","parse","indexOf","substr","get","data","instance","isInsertQuery","insertData","res","index","handleInsertQuery","rowsAffected","isShowTablesQuery","handleShowTablesQuery","isDescribeQuery","table","models","modelAttributes","_result","Default","COLUMN_NAME","DATA_TYPE","toUpperCase","allowNull","NULLABLE","defaultValue","primaryKey","CONSTRAINT_TYPE","isShowIndexesQuery","handleShowIndexesQuery","result2","handleSelectQuery","isCallQuery","isUpdateQuery","isBulkUpdateQuery","isBulkDeleteQuery","isVersionQuery","version","VERSION_FULL","versions","split","isForeignKeysQuery","k","isUpdate","isNewRecord","isShowConstraintsQuery","handleShowConstraintsQuery","isRawQuery","metaData","constraint","camelCase","toLowerCase","results","resultSet","tableName","TABLE_NAME","schema","TABLE_SCHEMA","err","message","errors","fields","uniqueKey","uniqueKeys","currKey","msg","field","ValidationErrorItem","getUniqueConstraintErrorMessage","UniqueConstraintError","ForeignKeyConstraintError","parent","UnknownConstraintError","DatabaseError","isSelectCountQuery","indexRecord","INDEX_NAME","unique","UNIQUENESS","primary","name","attribute","order","DESCEND","collate","returnIndexes","accKeys","accKey","columns","nameIndex","primaryKeyAttribute","pkReturnVal","autoIncrementField","autoIncrementAttribute","autoIncrementFieldAlias","id","prototype","hasOwnProperty","call"],"sources":["/Users/aurele/node_modules/sequelize/src/dialects/oracle/query.js"],"sourcesContent":["// Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved\n\n'use strict';\n\nconst AbstractQuery = require('../abstract/query');\nconst SequelizeErrors = require('../../errors');\nconst parserStore = require('../parserStore')('oracle');\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst { logger } = require('../../utils/logger');\n\nconst debug = logger.debugContext('sql:oracle');\n\nexport class OracleQuery extends AbstractQuery {\n  constructor(connection, sequelize, options) {\n    super(connection, sequelize, options);\n    this.options = _.extend(\n      {\n        logging: console.log,\n        plain: false,\n        raw: false\n      },\n      options || {}\n    );\n\n    this.checkLoggingOption();\n    this.outFormat = options.outFormat || this.sequelize.connectionManager.lib.OBJECT;\n  }\n\n  getInsertIdField() {\n    return 'id';\n  }\n\n  getExecOptions() {\n    const execOpts = { outFormat: this.outFormat, autoCommit: this.autoCommit };\n\n    // We set the oracledb\n    const oracledb = this.sequelize.connectionManager.lib;\n\n    if (this.model && this.isSelectQuery()) {\n      const fInfo = {};\n      const keys = Object.keys(this.model.tableAttributes);\n      for (const key of keys) {\n        const keyValue = this.model.tableAttributes[key];\n        if (keyValue.type.key === 'DECIMAL') {\n          fInfo[key] = { type: oracledb.STRING };\n        }\n        // Fetching BIGINT as string since, node-oracledb doesn't support JS BIGINT yet\n        if (keyValue.type.key === 'BIGINT') {\n          fInfo[key] = { type: oracledb.STRING };\n        }\n      }\n      if ( fInfo ) {\n        execOpts.fetchInfo = fInfo;\n      }\n    }\n    return execOpts;\n  }\n\n  /**\n   * convert binding values for unsupported\n   * types in connector library\n   *\n   * @param {string} bindingDictionary a string representing the key to scan\n   * @param {object} oracledb native oracle library\n   * @private\n   */\n  _convertBindAttributes(bindingDictionary, oracledb) {\n    if (this.model && this.options[bindingDictionary]) {\n      // check against model if we have some BIGINT\n      const keys = Object.keys(this.model.tableAttributes);\n      for (const key of keys) {\n        const keyValue = this.model.tableAttributes[key];\n        if (keyValue.type.key === 'BIGINT') {\n          const oldBinding = this.options[bindingDictionary][key];\n          if (oldBinding) {\n            this.options[bindingDictionary][key] = {\n              ...oldBinding,\n              type: oracledb.STRING,\n              maxSize: 10000000 //TOTALLY ARBITRARY Number to prevent query failure\n            };\n          }\n        }\n      }\n    }\n  }\n\n  async run(sql, parameters) {\n    // We set the oracledb\n    const oracledb = this.sequelize.connectionManager.lib;\n    const complete = this._logQuery(sql, debug, parameters);\n    const outParameters = [];\n    const bindParameters = [];\n    const bindDef = [];\n\n    if (!sql.match(/END;$/)) {\n      this.sql = sql.replace(/; *$/, '');\n    } else {\n      this.sql = sql;\n    }\n\n    // When this.options.bindAttributes exists then it is an insertQuery/upsertQuery\n    // So we insert the return bind direction and type\n    if (this.options.outBindAttributes && (Array.isArray(parameters) || _.isPlainObject(parameters))) {\n      this._convertBindAttributes('outBindAttributes', oracledb);\n      outParameters.push(...Object.values(this.options.outBindAttributes));\n      // For upsertQuery we need to push the bindDef for isUpdate\n      if (this.isUpsertQuery()) {\n        outParameters.push({ dir: oracledb.BIND_OUT });\n      }\n    }\n\n    this.bindParameters = outParameters;\n    // construct input binds from parameters for single row insert execute call\n    // ex: [3, 4,...]\n    if (Array.isArray(parameters) || _.isPlainObject(parameters)) {\n      if (this.options.executeMany) {\n        // Constructing BindDefs for ExecuteMany call\n        // Building the bindDef for in and out binds\n        this._convertBindAttributes('inbindAttributes', oracledb);\n        bindDef.push(...Object.values(this.options.inbindAttributes));\n        bindDef.push(...outParameters);\n        this.bindParameters = parameters;\n      } else {\n        Object.values(parameters).forEach(value => {\n          bindParameters.push(value);\n        });\n        bindParameters.push(...outParameters);\n        Object.assign(this.bindParameters, bindParameters);\n      }\n    }\n\n    // TRANSACTION SUPPORT\n    if (this.sql.startsWith('BEGIN TRANSACTION')) {\n      this.autocommit = false;\n      return Promise.resolve();\n    }\n    if (this.sql.startsWith('SET AUTOCOMMIT ON')) {\n      this.autocommit = true;\n      return Promise.resolve();\n    }\n    if (this.sql.startsWith('SET AUTOCOMMIT OFF')) {\n      this.autocommit = false;\n      return Promise.resolve();\n    }\n    if (this.sql.startsWith('DECLARE x NUMBER')) {\n      // Calling a stored procedure for bulkInsert with NO attributes, returns nothing\n      if (this.autoCommit === undefined) {\n        if (this.connection.uuid) {\n          this.autoCommit = false;\n        } else {\n          this.autoCommit = true;\n        }\n      }\n\n      try {\n        await this.connection.execute(this.sql, this.bindParameters, { autoCommit: this.autoCommit });\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith('BEGIN')) {\n      // Call to stored procedures - BEGIN TRANSACTION has been treated before\n      if (this.autoCommit === undefined) {\n        if (this.connection.uuid) {\n          this.autoCommit = false;\n        } else {\n          this.autoCommit = true;\n        }\n      }\n\n      try {\n        const result = await this.connection.execute(this.sql, this.bindParameters, {\n          outFormat: this.outFormat,\n          autoCommit: this.autoCommit\n        });\n        if (!Array.isArray(result.outBinds)) {\n          return [result.outBinds];\n        }\n        return result.outBinds;\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith('COMMIT TRANSACTION')) {\n      try {\n        await this.connection.commit();\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith('ROLLBACK TRANSACTION')) {\n      try {\n        await this.connection.rollback();\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith('SET TRANSACTION')) {\n      try {\n        await this.connection.execute(this.sql, [], { autoCommit: false });\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    // QUERY SUPPORT\n    // As Oracle does everything in transaction, if autoCommit is not defined, we set it to true\n    if (this.autoCommit === undefined) {\n      if (this.connection.uuid) {\n        this.autoCommit = false;\n      } else {\n        this.autoCommit = true;\n      }\n    }\n\n    // inbind parameters added byname. merge them\n    if ('inputParameters' in this.options && this.options.inputParameters !== null) {\n      Object.assign(this.bindParameters, this.options.inputParameters);\n    }\n    const execOpts = this.getExecOptions();\n    if (this.options.executeMany && bindDef.length > 0) {\n      execOpts.bindDefs = bindDef;\n    }\n    const executePromise = this.options.executeMany ? this.connection.executeMany(this.sql, this.bindParameters, execOpts) : this.connection.execute(this.sql, this.bindParameters, execOpts);\n    try {\n      const result = await executePromise;\n      return this.formatResults(result);\n    } catch (error) {\n      throw this.formatError(error);\n    } finally {\n      complete();\n    }\n  }\n\n  /**\n * The parameters to query.run function are built here\n *\n * @param {string} sql\n * @param {Array} values\n * @param {string} dialect\n */\n  static formatBindParameters(sql, values, dialect) {\n\n    const replacementFunc = (match, key, values) => {\n      if (values[key] !== undefined) {\n        return `:${key}`;\n      }\n      return undefined;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n\n    return [sql, values];\n  }\n\n  /**\n   * Building the attribute map by matching the column names received\n   * from DB and the one in rawAttributes\n   * to sequelize format\n   *\n   * @param {object} attrsMap\n   * @param {object} rawAttributes\n   * @private\n   */\n  _getAttributeMap(attrsMap, rawAttributes) {\n    attrsMap = Object.assign(attrsMap, _.reduce(rawAttributes, (mp, _, key) => {\n      const catalogKey = this.sequelize.queryInterface.queryGenerator.getCatalogName(key);\n      mp[catalogKey] = key;\n      return mp;\n    }, {}));\n  }\n\n  /**\n   * Process rows received from the DB.\n   * Use parse function to parse the returned value\n   * to sequelize format\n   *\n   * @param {Array} rows\n   * @private\n   */\n  _processRows(rows) {\n    let result = rows;\n    let attrsMap = {};\n\n    // When quoteIdentifiers is false we need to map the DB column names\n    // To the one in attribute list\n    if (this.sequelize.options.quoteIdentifiers === false) {\n      // Building the attribute map from this.options.attributes\n      // Needed in case of an aggregate function\n      attrsMap = _.reduce(this.options.attributes, (mp, v) => {\n        // Aggregate function is of form\n        // Fn {fn: 'min', min}, so we have the name in index one of the object\n        if (typeof v === 'object') {\n          v = v[1];\n        }\n        const catalogv = this.sequelize.queryInterface.queryGenerator.getCatalogName(v);\n        mp[catalogv] = v;\n        return mp;\n      }, {});\n\n\n      // Building the attribute map by matching the column names received\n      // from DB and the one in model.rawAttributes\n      if (this.model) {\n        this._getAttributeMap(attrsMap, this.model.rawAttributes);\n      }\n\n      // If aliasesmapping exists we update the attribute map\n      if (this.options.aliasesMapping) {\n        const obj = Object.fromEntries(this.options.aliasesMapping);\n        rows = rows\n          .map(row => _.toPairs(row)\n            .reduce((acc, [key, value]) => {\n              const mapping = Object.values(obj).find(element => {\n                const catalogElement = this.sequelize.queryInterface.queryGenerator.getCatalogName(element);\n                return catalogElement === key;\n              });\n              if (mapping)\n                acc[mapping || key] = value;\n              return acc;\n            }, {})\n          );\n      }\n\n      // Modify the keys into the format that sequelize expects\n      result = rows.map(row => {\n        return _.mapKeys(row, (value, key) => {\n          const targetAttr = attrsMap[key];\n          if (typeof targetAttr === 'string' && targetAttr !== key) {\n            return targetAttr;\n          }\n          return key;\n        });\n      });\n    }\n\n    // We parse the value received from the DB based on its datatype\n    if (this.model) {\n      result = result.map(row => {\n        return _.mapValues(row, (value, key) => {\n          if (this.model.rawAttributes[key] && this.model.rawAttributes[key].type) {\n            let typeid = this.model.rawAttributes[key].type.toLocaleString();\n            if (this.model.rawAttributes[key].type.key === 'JSON') {\n              value = JSON.parse(value);\n            }\n            // For some types, the \"name\" of the type is returned with the length, we remove it\n            // For Boolean we skip this because BOOLEAN is mapped to CHAR(1) and we dont' want to\n            // remove the (1) for BOOLEAN\n            if (typeid.indexOf('(') > -1 && this.model.rawAttributes[key].type.key !== 'BOOLEAN') {\n              typeid = typeid.substr(0, typeid.indexOf('('));\n            }\n            const parse = parserStore.get(typeid);\n            if (value !== null & !!parse) {\n              value = parse(value);\n            }\n          }\n          return value;\n        });\n      });\n    }\n\n    return result;\n  }\n\n  /**\n   * High level function that handles the results of a query execution.\n   * Example:\n   * Oracle format :\n   * { rows: //All rows\n     [ [ 'Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production' ],\n       [ 'PL/SQL Release 11.2.0.1.0 - Production' ],\n       [ 'CORE\\t11.2.0.1.0\\tProduction' ],\n       [ 'TNS for 64-bit Windows: Version 11.2.0.1.0 - Production' ],\n       [ 'NLSRTL Version 11.2.0.1.0 - Production' ] ],\n    resultSet: undefined,\n    outBinds: undefined, //Used for dbms_put.line\n    rowsAffected: undefined, //Number of rows affected\n    metaData: [ { name: 'BANNER' } ] }\n  *\n  * @param {Array} data - The result of the query execution.\n  */\n  formatResults(data) {\n    let result = this.instance;\n    if (this.isInsertQuery(data)) {\n      let insertData;\n      if (data.outBinds) {\n        const keys = Object.keys(this.options.outBindAttributes);\n        insertData = data.outBinds;\n        // For one row insert out bind array is 1D array\n        // we convert it to 2D array for uniformity\n        if (this.instance) {\n          insertData = [insertData];\n        }\n        // Mapping the bind parameter to their values\n        const res = insertData.map(row =>{\n          const obj = {};\n          row.forEach((element, index) =>{\n            obj[keys[index]] = element[0];\n          });\n          return obj;\n        });\n        insertData = res;\n        // For bulk insert this.insert is undefined\n        // we map result to res, for one row insert\n        // result needs to be this.instance\n        if (!this.instance) {\n          result = res;\n        }\n      }\n      this.handleInsertQuery(insertData);\n      return [result, data.rowsAffected];\n    }\n    if (this.isShowTablesQuery()) {\n      result = this.handleShowTablesQuery(data.rows);\n    } else if (this.isDescribeQuery()) {\n      result = {};\n      // Getting the table name on which we are doing describe query\n      const table = Object.keys(this.sequelize.models);\n      const modelAttributes = {};\n      // Get the model raw attributes\n      if (this.sequelize.models && table.length > 0) {\n        this._getAttributeMap(modelAttributes, this.sequelize.models[table[0]].rawAttributes);\n      }\n      data.rows.forEach(_result => {\n        if (_result.Default) {\n          _result.Default = _result.Default.replace(\"('\", '')\n            .replace(\"')\", '')\n            .replace(/'/g, ''); /* jshint ignore: line */\n        }\n\n        if (!(modelAttributes[_result.COLUMN_NAME] in result)) {\n          let key = modelAttributes[_result.COLUMN_NAME];\n          if (!key) {\n            key = _result.COLUMN_NAME;\n          }\n\n          result[key] = {\n            type: _result.DATA_TYPE.toUpperCase(),\n            allowNull: _result.NULLABLE === 'N' ? false : true,\n            defaultValue: undefined,\n            primaryKey: _result.CONSTRAINT_TYPE === 'P'\n          };\n        }\n      });\n    } else if (this.isShowIndexesQuery()) {\n      result = this.handleShowIndexesQuery(data.rows);\n    } else if (this.isSelectQuery()) {\n      const rows = data.rows;\n      const result = this._processRows(rows);\n      return this.handleSelectQuery(result);\n    } else if (this.isCallQuery()) {\n      result = data.rows[0];\n    } else if (this.isUpdateQuery()) {\n      result = [result, data.rowsAffected];\n    } else if (this.isBulkUpdateQuery()) {\n      result = data.rowsAffected;\n    } else if (this.isBulkDeleteQuery()) {\n      result = data.rowsAffected;\n    } else if (this.isVersionQuery()) {\n      const version = data.rows[0].VERSION_FULL;\n      if (version) {\n        const versions = version.split('.');\n        result = `${versions[0]}.${versions[1]}.${versions[2]}`;\n      } else {\n        result = '0.0.0';\n      }\n    } else if (this.isForeignKeysQuery()) {\n      result = data.rows;\n    } else if (this.isUpsertQuery()) {\n      // Upsert Query, will return nothing\n      data = data.outBinds;\n      const keys = Object.keys(this.options.outBindAttributes);\n      const obj = {};\n      for (const k in keys) {\n        obj[keys[k]] = data[k];\n      }\n      obj.isUpdate = data[data.length - 1];\n      data = obj;\n      result = [{ isNewRecord: data.isUpdate, value: data }, data.isUpdate == 0];\n    } else if (this.isShowConstraintsQuery()) {\n      result = this.handleShowConstraintsQuery(data);\n    } else if (this.isRawQuery()) {\n      // If data.rows exists then it is a select query\n      // Hence we would have two components\n      // metaData and rows and we return them\n      // as [data.rows, data.metaData]\n      // Else it is result of update/upsert/insert query\n      // and it has no rows so we return [data, data]\n      if (data && data.rows) {\n        return [data.rows, data.metaData];\n      }\n      return [data, data];\n    }\n\n    return result;\n  }\n\n  handleShowConstraintsQuery(data) {\n    // Convert snake_case keys to camelCase as its generated by stored procedure\n    return data.rows.map(result => {\n      const constraint = {};\n      for (const key in result) {\n        constraint[_.camelCase(key)] = result[key].toLowerCase();\n      }\n      return constraint;\n    });\n  }\n\n  handleShowTablesQuery(results) {\n    return results.map(resultSet => {\n      return {\n        tableName: resultSet.TABLE_NAME,\n        schema: resultSet.TABLE_SCHEMA\n      };\n    });\n  }\n\n  formatError(err) {\n    let match;\n    // ORA-00001: unique constraint (USER.XXXXXXX) violated\n    match = err.message.match(/unique constraint ([\\s\\S]*) violated/);\n    if (match && match.length > 1) {\n      match[1] = match[1].replace('(', '').replace(')', '').split('.')[1]; // As we get (SEQUELIZE.UNIQNAME), we replace to have UNIQNAME\n      const errors = [];\n      let fields = [],\n        message = 'Validation error',\n        uniqueKey = null;\n\n      if (this.model) {\n        const uniqueKeys = Object.keys(this.model.uniqueKeys);\n\n        const currKey = uniqueKeys.find(key => {\n          // We check directly AND with quotes -> \"a\"\" === a || \"a\" === \"a\"\n          return key.toUpperCase() === match[1].toUpperCase() || key.toUpperCase() === `\"${match[1].toUpperCase()}\"`;\n        });\n\n        if (currKey) {\n          uniqueKey = this.model.uniqueKeys[currKey];\n          fields = uniqueKey.fields;\n        }\n\n        if (uniqueKey && !!uniqueKey.msg) {\n          message = uniqueKey.msg;\n        }\n\n        fields.forEach(field => {\n          errors.push(\n            new SequelizeErrors.ValidationErrorItem(\n              this.getUniqueConstraintErrorMessage(field),\n              'unique violation',\n              field,\n              null\n            )\n          );\n        });\n      }\n\n      return new SequelizeErrors.UniqueConstraintError({\n        message,\n        errors,\n        err,\n        fields\n      });\n    }\n\n    // ORA-02291: integrity constraint (string.string) violated - parent key not found / ORA-02292: integrity constraint (string.string) violated - child record found\n    match = err.message.match(/ORA-02291/) || err.message.match(/ORA-02292/);\n    if (match && match.length > 0) {\n      return new SequelizeErrors.ForeignKeyConstraintError({\n        fields: null,\n        index: match[1],\n        parent: err\n      });\n    }\n\n    // ORA-02443: Cannot drop constraint  - nonexistent constraint\n    match = err.message.match(/ORA-02443/);\n    if (match && match.length > 0) {\n      return new SequelizeErrors.UnknownConstraintError(match[1]);\n    }\n\n    return new SequelizeErrors.DatabaseError(err);\n  }\n\n  isShowIndexesQuery() {\n    return this.sql.indexOf('SELECT i.index_name,i.table_name, i.column_name, u.uniqueness') > -1;\n  }\n\n  isSelectCountQuery() {\n    return this.sql.toUpperCase().indexOf('SELECT COUNT(') > -1;\n  }\n\n  handleShowIndexesQuery(data) {\n    const acc = [];\n\n    // We first treat the datas\n    data.forEach(indexRecord => {\n      // We create the object\n      if (!acc[indexRecord.INDEX_NAME]) {\n        acc[indexRecord.INDEX_NAME] = {\n          unique: indexRecord.UNIQUENESS === 'UNIQUE' ? true : false,\n          primary: indexRecord.CONSTRAINT_TYPE === 'P',\n          name: indexRecord.INDEX_NAME.toLowerCase(),\n          tableName: indexRecord.TABLE_NAME.toLowerCase(),\n          type: undefined\n        };\n        acc[indexRecord.INDEX_NAME].fields = [];\n      }\n\n      // We create the fields\n      acc[indexRecord.INDEX_NAME].fields.push({\n        attribute: indexRecord.COLUMN_NAME,\n        length: undefined,\n        order: indexRecord.DESCEND,\n        collate: undefined\n      });\n    });\n\n    const returnIndexes = [];\n    const accKeys = Object.keys(acc);\n    for (const accKey of accKeys) {\n      const columns = {};\n      columns.fields = acc[accKey].fields;\n      // We are generating index field name in the format sequelize expects\n      // to avoid creating a unique index on auto-generated index name\n      if (acc[accKey].name.match(/sys_c[0-9]*/)) {\n        acc[accKey].name = Utils.nameIndex(columns, acc[accKey].tableName).name;\n      }\n      returnIndexes.push(acc[accKey]);\n    }\n    return returnIndexes;\n  }\n\n  handleInsertQuery(results, metaData) {\n    if (this.instance && results.length > 0) {\n      if ('pkReturnVal' in results[0]) {\n        // The PK of the table is a reserved word (ex : uuid), we have to change the name in the result for the model to find the value correctly\n        results[0][this.model.primaryKeyAttribute] = results[0].pkReturnVal;\n        delete results[0].pkReturnVal;\n      }\n      // add the inserted row id to the instance\n      const autoIncrementField = this.model.autoIncrementAttribute;\n      let autoIncrementFieldAlias = null,\n        id = null;\n\n      if (\n        Object.prototype.hasOwnProperty.call(this.model.rawAttributes, autoIncrementField) &&\n        this.model.rawAttributes[autoIncrementField].field !== undefined\n      )\n        autoIncrementFieldAlias = this.model.rawAttributes[autoIncrementField].field;\n\n      id = id || results && results[0][this.getInsertIdField()];\n      id = id || metaData && metaData[this.getInsertIdField()];\n      id = id || results && results[0][autoIncrementField];\n      id = id || autoIncrementFieldAlias && results && results[0][autoIncrementFieldAlias];\n\n      this.instance[autoIncrementField] = id;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}