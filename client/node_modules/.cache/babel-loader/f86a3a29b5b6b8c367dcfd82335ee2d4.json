{"ast":null,"code":"'use strict';\n\nconst Header = require('./header.js');\n\nconst path = require('path');\n\nclass Pax {\n  constructor(obj, global) {\n    this.atime = obj.atime || null;\n    this.charset = obj.charset || null;\n    this.comment = obj.comment || null;\n    this.ctime = obj.ctime || null;\n    this.gid = obj.gid || null;\n    this.gname = obj.gname || null;\n    this.linkpath = obj.linkpath || null;\n    this.mtime = obj.mtime || null;\n    this.path = obj.path || null;\n    this.size = obj.size || null;\n    this.uid = obj.uid || null;\n    this.uname = obj.uname || null;\n    this.dev = obj.dev || null;\n    this.ino = obj.ino || null;\n    this.nlink = obj.nlink || null;\n    this.global = global || false;\n  }\n\n  encode() {\n    const body = this.encodeBody();\n\n    if (body === '') {\n      return null;\n    }\n\n    const bodyLen = Buffer.byteLength(body); // round up to 512 bytes\n    // add 512 for header\n\n    const bufLen = 512 * Math.ceil(1 + bodyLen / 512);\n    const buf = Buffer.allocUnsafe(bufLen); // 0-fill the header section, it might not hit every field\n\n    for (let i = 0; i < 512; i++) {\n      buf[i] = 0;\n    }\n\n    new Header({\n      // XXX split the path\n      // then the path should be PaxHeader + basename, but less than 99,\n      // prepend with the dirname\n      path: ('PaxHeader/' + path.basename(this.path)).slice(0, 99),\n      mode: this.mode || 0o644,\n      uid: this.uid || null,\n      gid: this.gid || null,\n      size: bodyLen,\n      mtime: this.mtime || null,\n      type: this.global ? 'GlobalExtendedHeader' : 'ExtendedHeader',\n      linkpath: '',\n      uname: this.uname || '',\n      gname: this.gname || '',\n      devmaj: 0,\n      devmin: 0,\n      atime: this.atime || null,\n      ctime: this.ctime || null\n    }).encode(buf);\n    buf.write(body, 512, bodyLen, 'utf8'); // null pad after the body\n\n    for (let i = bodyLen + 512; i < buf.length; i++) {\n      buf[i] = 0;\n    }\n\n    return buf;\n  }\n\n  encodeBody() {\n    return this.encodeField('path') + this.encodeField('ctime') + this.encodeField('atime') + this.encodeField('dev') + this.encodeField('ino') + this.encodeField('nlink') + this.encodeField('charset') + this.encodeField('comment') + this.encodeField('gid') + this.encodeField('gname') + this.encodeField('linkpath') + this.encodeField('mtime') + this.encodeField('size') + this.encodeField('uid') + this.encodeField('uname');\n  }\n\n  encodeField(field) {\n    if (this[field] === null || this[field] === undefined) {\n      return '';\n    }\n\n    const v = this[field] instanceof Date ? this[field].getTime() / 1000 : this[field];\n    const s = ' ' + (field === 'dev' || field === 'ino' || field === 'nlink' ? 'SCHILY.' : '') + field + '=' + v + '\\n';\n    const byteLen = Buffer.byteLength(s); // the digits includes the length of the digits in ascii base-10\n    // so if it's 9 characters, then adding 1 for the 9 makes it 10\n    // which makes it 11 chars.\n\n    let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;\n\n    if (byteLen + digits >= Math.pow(10, digits)) {\n      digits += 1;\n    }\n\n    const len = digits + byteLen;\n    return len + s;\n  }\n\n}\n\nPax.parse = (string, ex, g) => new Pax(merge(parseKV(string), ex), g);\n\nconst merge = (a, b) => b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a;\n\nconst parseKV = string => string.replace(/\\n$/, '').split('\\n').reduce(parseKVLine, Object.create(null));\n\nconst parseKVLine = (set, line) => {\n  const n = parseInt(line, 10); // XXX Values with \\n in them will fail this.\n  // Refactor to not be a naive line-by-line parse.\n\n  if (n !== Buffer.byteLength(line) + 1) {\n    return set;\n  }\n\n  line = line.slice((n + ' ').length);\n  const kv = line.split('=');\n  const k = kv.shift().replace(/^SCHILY\\.(dev|ino|nlink)/, '$1');\n\n  if (!k) {\n    return set;\n  }\n\n  const v = kv.join('=');\n  set[k] = /^([A-Z]+\\.)?([mac]|birth|creation)time$/.test(k) ? new Date(v * 1000) : /^[0-9]+$/.test(v) ? +v : v;\n  return set;\n};\n\nmodule.exports = Pax;","map":{"version":3,"names":["Header","require","path","Pax","constructor","obj","global","atime","charset","comment","ctime","gid","gname","linkpath","mtime","size","uid","uname","dev","ino","nlink","encode","body","encodeBody","bodyLen","Buffer","byteLength","bufLen","Math","ceil","buf","allocUnsafe","i","basename","slice","mode","type","devmaj","devmin","write","length","encodeField","field","undefined","v","Date","getTime","s","byteLen","digits","floor","log","pow","len","parse","string","ex","g","merge","parseKV","a","b","Object","keys","reduce","k","replace","split","parseKVLine","create","set","line","n","parseInt","kv","shift","join","test","module","exports"],"sources":["/Users/aurele/Desktop/E-Commerce App/views/node_modules/tar/lib/pax.js"],"sourcesContent":["'use strict'\nconst Header = require('./header.js')\nconst path = require('path')\n\nclass Pax {\n  constructor (obj, global) {\n    this.atime = obj.atime || null\n    this.charset = obj.charset || null\n    this.comment = obj.comment || null\n    this.ctime = obj.ctime || null\n    this.gid = obj.gid || null\n    this.gname = obj.gname || null\n    this.linkpath = obj.linkpath || null\n    this.mtime = obj.mtime || null\n    this.path = obj.path || null\n    this.size = obj.size || null\n    this.uid = obj.uid || null\n    this.uname = obj.uname || null\n    this.dev = obj.dev || null\n    this.ino = obj.ino || null\n    this.nlink = obj.nlink || null\n    this.global = global || false\n  }\n\n  encode () {\n    const body = this.encodeBody()\n    if (body === '') {\n      return null\n    }\n\n    const bodyLen = Buffer.byteLength(body)\n    // round up to 512 bytes\n    // add 512 for header\n    const bufLen = 512 * Math.ceil(1 + bodyLen / 512)\n    const buf = Buffer.allocUnsafe(bufLen)\n\n    // 0-fill the header section, it might not hit every field\n    for (let i = 0; i < 512; i++) {\n      buf[i] = 0\n    }\n\n    new Header({\n      // XXX split the path\n      // then the path should be PaxHeader + basename, but less than 99,\n      // prepend with the dirname\n      path: ('PaxHeader/' + path.basename(this.path)).slice(0, 99),\n      mode: this.mode || 0o644,\n      uid: this.uid || null,\n      gid: this.gid || null,\n      size: bodyLen,\n      mtime: this.mtime || null,\n      type: this.global ? 'GlobalExtendedHeader' : 'ExtendedHeader',\n      linkpath: '',\n      uname: this.uname || '',\n      gname: this.gname || '',\n      devmaj: 0,\n      devmin: 0,\n      atime: this.atime || null,\n      ctime: this.ctime || null,\n    }).encode(buf)\n\n    buf.write(body, 512, bodyLen, 'utf8')\n\n    // null pad after the body\n    for (let i = bodyLen + 512; i < buf.length; i++) {\n      buf[i] = 0\n    }\n\n    return buf\n  }\n\n  encodeBody () {\n    return (\n      this.encodeField('path') +\n      this.encodeField('ctime') +\n      this.encodeField('atime') +\n      this.encodeField('dev') +\n      this.encodeField('ino') +\n      this.encodeField('nlink') +\n      this.encodeField('charset') +\n      this.encodeField('comment') +\n      this.encodeField('gid') +\n      this.encodeField('gname') +\n      this.encodeField('linkpath') +\n      this.encodeField('mtime') +\n      this.encodeField('size') +\n      this.encodeField('uid') +\n      this.encodeField('uname')\n    )\n  }\n\n  encodeField (field) {\n    if (this[field] === null || this[field] === undefined) {\n      return ''\n    }\n    const v = this[field] instanceof Date ? this[field].getTime() / 1000\n      : this[field]\n    const s = ' ' +\n      (field === 'dev' || field === 'ino' || field === 'nlink'\n        ? 'SCHILY.' : '') +\n      field + '=' + v + '\\n'\n    const byteLen = Buffer.byteLength(s)\n    // the digits includes the length of the digits in ascii base-10\n    // so if it's 9 characters, then adding 1 for the 9 makes it 10\n    // which makes it 11 chars.\n    let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1\n    if (byteLen + digits >= Math.pow(10, digits)) {\n      digits += 1\n    }\n    const len = digits + byteLen\n    return len + s\n  }\n}\n\nPax.parse = (string, ex, g) => new Pax(merge(parseKV(string), ex), g)\n\nconst merge = (a, b) =>\n  b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a\n\nconst parseKV = string =>\n  string\n    .replace(/\\n$/, '')\n    .split('\\n')\n    .reduce(parseKVLine, Object.create(null))\n\nconst parseKVLine = (set, line) => {\n  const n = parseInt(line, 10)\n\n  // XXX Values with \\n in them will fail this.\n  // Refactor to not be a naive line-by-line parse.\n  if (n !== Buffer.byteLength(line) + 1) {\n    return set\n  }\n\n  line = line.slice((n + ' ').length)\n  const kv = line.split('=')\n  const k = kv.shift().replace(/^SCHILY\\.(dev|ino|nlink)/, '$1')\n  if (!k) {\n    return set\n  }\n\n  const v = kv.join('=')\n  set[k] = /^([A-Z]+\\.)?([mac]|birth|creation)time$/.test(k)\n    ? new Date(v * 1000)\n    : /^[0-9]+$/.test(v) ? +v\n    : v\n  return set\n}\n\nmodule.exports = Pax\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}