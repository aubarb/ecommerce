{"ast":null,"code":"'use strict';\n\nmodule.exports = exports = install;\nexports.usage = 'Attempts to install pre-built binary for module';\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst log = require('npmlog');\n\nconst existsAsync = fs.exists || path.exists;\n\nconst versioning = require('./util/versioning.js');\n\nconst napi = require('./util/napi.js');\n\nconst makeDir = require('make-dir'); // for fetching binaries\n\n\nconst fetch = require('node-fetch');\n\nconst tar = require('tar');\n\nlet npgVersion = 'unknown';\n\ntry {\n  // Read own package.json to get the current node-pre-pyp version.\n  const ownPackageJSON = fs.readFileSync(path.join(__dirname, '..', 'package.json'), 'utf8');\n  npgVersion = JSON.parse(ownPackageJSON).version;\n} catch (e) {// do nothing\n}\n\nfunction place_binary(uri, targetDir, opts, callback) {\n  log.http('GET', uri); // Try getting version info from the currently running npm.\n\n  const envVersionInfo = process.env.npm_config_user_agent || 'node ' + process.version;\n  const sanitized = uri.replace('+', '%2B');\n  const requestOpts = {\n    uri: sanitized,\n    headers: {\n      'User-Agent': 'node-pre-gyp (v' + npgVersion + ', ' + envVersionInfo + ')'\n    },\n    follow_max: 10\n  };\n\n  if (opts.cafile) {\n    try {\n      requestOpts.ca = fs.readFileSync(opts.cafile);\n    } catch (e) {\n      return callback(e);\n    }\n  } else if (opts.ca) {\n    requestOpts.ca = opts.ca;\n  }\n\n  const proxyUrl = opts.proxy || process.env.http_proxy || process.env.HTTP_PROXY || process.env.npm_config_proxy;\n  let agent;\n\n  if (proxyUrl) {\n    const ProxyAgent = require('https-proxy-agent');\n\n    agent = new ProxyAgent(proxyUrl);\n    log.http('download', 'proxy agent configured using: \"%s\"', proxyUrl);\n  }\n\n  fetch(sanitized, {\n    agent\n  }).then(res => {\n    if (!res.ok) {\n      throw new Error(`response status ${res.status} ${res.statusText} on ${sanitized}`);\n    }\n\n    const dataStream = res.body;\n    return new Promise((resolve, reject) => {\n      let extractions = 0;\n\n      const countExtractions = entry => {\n        extractions += 1;\n        log.info('install', 'unpacking %s', entry.path);\n      };\n\n      dataStream.pipe(extract(targetDir, countExtractions)).on('error', e => {\n        reject(e);\n      });\n      dataStream.on('end', () => {\n        resolve(`extracted file count: ${extractions}`);\n      });\n      dataStream.on('error', e => {\n        reject(e);\n      });\n    });\n  }).then(text => {\n    log.info(text);\n    callback();\n  }).catch(e => {\n    log.error(`install ${e.message}`);\n    callback(e);\n  });\n}\n\nfunction extract(to, onentry) {\n  return tar.extract({\n    cwd: to,\n    strip: 1,\n    onentry\n  });\n}\n\nfunction extract_from_local(from, targetDir, callback) {\n  if (!fs.existsSync(from)) {\n    return callback(new Error('Cannot find file ' + from));\n  }\n\n  log.info('Found local file to extract from ' + from); // extract helpers\n\n  let extractCount = 0;\n\n  function countExtractions(entry) {\n    extractCount += 1;\n    log.info('install', 'unpacking ' + entry.path);\n  }\n\n  function afterExtract(err) {\n    if (err) return callback(err);\n\n    if (extractCount === 0) {\n      return callback(new Error('There was a fatal problem while extracting the tarball'));\n    }\n\n    log.info('tarball', 'done parsing tarball');\n    callback();\n  }\n\n  fs.createReadStream(from).pipe(extract(targetDir, countExtractions)).on('close', afterExtract).on('error', afterExtract);\n}\n\nfunction do_build(gyp, argv, callback) {\n  const args = ['rebuild'].concat(argv);\n  gyp.todo.push({\n    name: 'build',\n    args: args\n  });\n  process.nextTick(callback);\n}\n\nfunction print_fallback_error(err, opts, package_json) {\n  const fallback_message = ' (falling back to source compile with node-gyp)';\n  let full_message = '';\n\n  if (err.statusCode !== undefined) {\n    // If we got a network response it but failed to download\n    // it means remote binaries are not available, so let's try to help\n    // the user/developer with the info to debug why\n    full_message = 'Pre-built binaries not found for ' + package_json.name + '@' + package_json.version;\n    full_message += ' and ' + opts.runtime + '@' + (opts.target || process.versions.node) + ' (' + opts.node_abi + ' ABI, ' + opts.libc + ')';\n    full_message += fallback_message;\n    log.warn('Tried to download(' + err.statusCode + '): ' + opts.hosted_tarball);\n    log.warn(full_message);\n    log.http(err.message);\n  } else {\n    // If we do not have a statusCode that means an unexpected error\n    // happened and prevented an http response, so we output the exact error\n    full_message = 'Pre-built binaries not installable for ' + package_json.name + '@' + package_json.version;\n    full_message += ' and ' + opts.runtime + '@' + (opts.target || process.versions.node) + ' (' + opts.node_abi + ' ABI, ' + opts.libc + ')';\n    full_message += fallback_message;\n    log.warn(full_message);\n    log.warn('Hit error ' + err.message);\n  }\n} //\n// install\n//\n\n\nfunction install(gyp, argv, callback) {\n  const package_json = gyp.package_json;\n  const napi_build_version = napi.get_napi_build_version_from_command_args(argv);\n  const source_build = gyp.opts['build-from-source'] || gyp.opts.build_from_source;\n  const update_binary = gyp.opts['update-binary'] || gyp.opts.update_binary;\n  const should_do_source_build = source_build === package_json.name || source_build === true || source_build === 'true';\n\n  if (should_do_source_build) {\n    log.info('build', 'requesting source compile');\n    return do_build(gyp, argv, callback);\n  } else {\n    const fallback_to_build = gyp.opts['fallback-to-build'] || gyp.opts.fallback_to_build;\n    let should_do_fallback_build = fallback_to_build === package_json.name || fallback_to_build === true || fallback_to_build === 'true'; // but allow override from npm\n\n    if (process.env.npm_config_argv) {\n      const cooked = JSON.parse(process.env.npm_config_argv).cooked;\n      const match = cooked.indexOf('--fallback-to-build');\n\n      if (match > -1 && cooked.length > match && cooked[match + 1] === 'false') {\n        should_do_fallback_build = false;\n        log.info('install', 'Build fallback disabled via npm flag: --fallback-to-build=false');\n      }\n    }\n\n    let opts;\n\n    try {\n      opts = versioning.evaluate(package_json, gyp.opts, napi_build_version);\n    } catch (err) {\n      return callback(err);\n    }\n\n    opts.ca = gyp.opts.ca;\n    opts.cafile = gyp.opts.cafile;\n    const from = opts.hosted_tarball;\n    const to = opts.module_path;\n    const binary_module = path.join(to, opts.module_name + '.node');\n    existsAsync(binary_module, found => {\n      if (!update_binary) {\n        if (found) {\n          console.log('[' + package_json.name + '] Success: \"' + binary_module + '\" already installed');\n          console.log('Pass --update-binary to reinstall or --build-from-source to recompile');\n          return callback();\n        }\n\n        log.info('check', 'checked for \"' + binary_module + '\" (not found)');\n      }\n\n      makeDir(to).then(() => {\n        const fileName = from.startsWith('file://') && from.slice('file://'.length);\n\n        if (fileName) {\n          extract_from_local(fileName, to, after_place);\n        } else {\n          place_binary(from, to, opts, after_place);\n        }\n      }).catch(err => {\n        after_place(err);\n      });\n\n      function after_place(err) {\n        if (err && should_do_fallback_build) {\n          print_fallback_error(err, opts, package_json);\n          return do_build(gyp, argv, callback);\n        } else if (err) {\n          return callback(err);\n        } else {\n          console.log('[' + package_json.name + '] Success: \"' + binary_module + '\" is installed via remote');\n          return callback();\n        }\n      }\n    });\n  }\n}","map":{"version":3,"names":["module","exports","install","usage","fs","require","path","log","existsAsync","exists","versioning","napi","makeDir","fetch","tar","npgVersion","ownPackageJSON","readFileSync","join","__dirname","JSON","parse","version","e","place_binary","uri","targetDir","opts","callback","http","envVersionInfo","process","env","npm_config_user_agent","sanitized","replace","requestOpts","headers","follow_max","cafile","ca","proxyUrl","proxy","http_proxy","HTTP_PROXY","npm_config_proxy","agent","ProxyAgent","then","res","ok","Error","status","statusText","dataStream","body","Promise","resolve","reject","extractions","countExtractions","entry","info","pipe","extract","on","text","catch","error","message","to","onentry","cwd","strip","extract_from_local","from","existsSync","extractCount","afterExtract","err","createReadStream","do_build","gyp","argv","args","concat","todo","push","name","nextTick","print_fallback_error","package_json","fallback_message","full_message","statusCode","undefined","runtime","target","versions","node","node_abi","libc","warn","hosted_tarball","napi_build_version","get_napi_build_version_from_command_args","source_build","build_from_source","update_binary","should_do_source_build","fallback_to_build","should_do_fallback_build","npm_config_argv","cooked","match","indexOf","length","evaluate","module_path","binary_module","module_name","found","console","fileName","startsWith","slice","after_place"],"sources":["/Users/aurele/Desktop/E-Commerce App/views/node_modules/@mapbox/node-pre-gyp/lib/install.js"],"sourcesContent":["'use strict';\n\nmodule.exports = exports = install;\n\nexports.usage = 'Attempts to install pre-built binary for module';\n\nconst fs = require('fs');\nconst path = require('path');\nconst log = require('npmlog');\nconst existsAsync = fs.exists || path.exists;\nconst versioning = require('./util/versioning.js');\nconst napi = require('./util/napi.js');\nconst makeDir = require('make-dir');\n// for fetching binaries\nconst fetch = require('node-fetch');\nconst tar = require('tar');\n\nlet npgVersion = 'unknown';\ntry {\n  // Read own package.json to get the current node-pre-pyp version.\n  const ownPackageJSON = fs.readFileSync(path.join(__dirname, '..', 'package.json'), 'utf8');\n  npgVersion = JSON.parse(ownPackageJSON).version;\n} catch (e) {\n  // do nothing\n}\n\nfunction place_binary(uri, targetDir, opts, callback) {\n  log.http('GET', uri);\n\n  // Try getting version info from the currently running npm.\n  const envVersionInfo = process.env.npm_config_user_agent ||\n        'node ' + process.version;\n\n  const sanitized = uri.replace('+', '%2B');\n  const requestOpts = {\n    uri: sanitized,\n    headers: {\n      'User-Agent': 'node-pre-gyp (v' + npgVersion + ', ' + envVersionInfo + ')'\n    },\n    follow_max: 10\n  };\n\n  if (opts.cafile) {\n    try {\n      requestOpts.ca = fs.readFileSync(opts.cafile);\n    } catch (e) {\n      return callback(e);\n    }\n  } else if (opts.ca) {\n    requestOpts.ca = opts.ca;\n  }\n\n  const proxyUrl = opts.proxy ||\n                    process.env.http_proxy ||\n                    process.env.HTTP_PROXY ||\n                    process.env.npm_config_proxy;\n  let agent;\n  if (proxyUrl) {\n    const ProxyAgent = require('https-proxy-agent');\n    agent = new ProxyAgent(proxyUrl);\n    log.http('download', 'proxy agent configured using: \"%s\"', proxyUrl);\n  }\n\n  fetch(sanitized, { agent })\n    .then((res) => {\n      if (!res.ok) {\n        throw new Error(`response status ${res.status} ${res.statusText} on ${sanitized}`);\n      }\n      const dataStream = res.body;\n\n      return new Promise((resolve, reject) => {\n        let extractions = 0;\n        const countExtractions = (entry) => {\n          extractions += 1;\n          log.info('install', 'unpacking %s', entry.path);\n        };\n\n        dataStream.pipe(extract(targetDir, countExtractions))\n          .on('error', (e) => {\n            reject(e);\n          });\n        dataStream.on('end', () => {\n          resolve(`extracted file count: ${extractions}`);\n        });\n        dataStream.on('error', (e) => {\n          reject(e);\n        });\n      });\n    })\n    .then((text) => {\n      log.info(text);\n      callback();\n    })\n    .catch((e) => {\n      log.error(`install ${e.message}`);\n      callback(e);\n    });\n}\n\nfunction extract(to, onentry) {\n  return tar.extract({\n    cwd: to,\n    strip: 1,\n    onentry\n  });\n}\n\nfunction extract_from_local(from, targetDir, callback) {\n  if (!fs.existsSync(from)) {\n    return callback(new Error('Cannot find file ' + from));\n  }\n  log.info('Found local file to extract from ' + from);\n\n  // extract helpers\n  let extractCount = 0;\n  function countExtractions(entry) {\n    extractCount += 1;\n    log.info('install', 'unpacking ' + entry.path);\n  }\n  function afterExtract(err) {\n    if (err) return callback(err);\n    if (extractCount === 0) {\n      return callback(new Error('There was a fatal problem while extracting the tarball'));\n    }\n    log.info('tarball', 'done parsing tarball');\n    callback();\n  }\n\n  fs.createReadStream(from).pipe(extract(targetDir, countExtractions))\n    .on('close', afterExtract)\n    .on('error', afterExtract);\n}\n\nfunction do_build(gyp, argv, callback) {\n  const args = ['rebuild'].concat(argv);\n  gyp.todo.push({ name: 'build', args: args });\n  process.nextTick(callback);\n}\n\nfunction print_fallback_error(err, opts, package_json) {\n  const fallback_message = ' (falling back to source compile with node-gyp)';\n  let full_message = '';\n  if (err.statusCode !== undefined) {\n    // If we got a network response it but failed to download\n    // it means remote binaries are not available, so let's try to help\n    // the user/developer with the info to debug why\n    full_message = 'Pre-built binaries not found for ' + package_json.name + '@' + package_json.version;\n    full_message += ' and ' + opts.runtime + '@' + (opts.target || process.versions.node) + ' (' + opts.node_abi + ' ABI, ' + opts.libc + ')';\n    full_message += fallback_message;\n    log.warn('Tried to download(' + err.statusCode + '): ' + opts.hosted_tarball);\n    log.warn(full_message);\n    log.http(err.message);\n  } else {\n    // If we do not have a statusCode that means an unexpected error\n    // happened and prevented an http response, so we output the exact error\n    full_message = 'Pre-built binaries not installable for ' + package_json.name + '@' + package_json.version;\n    full_message += ' and ' + opts.runtime + '@' + (opts.target || process.versions.node) + ' (' + opts.node_abi + ' ABI, ' + opts.libc + ')';\n    full_message += fallback_message;\n    log.warn(full_message);\n    log.warn('Hit error ' + err.message);\n  }\n}\n\n//\n// install\n//\nfunction install(gyp, argv, callback) {\n  const package_json = gyp.package_json;\n  const napi_build_version = napi.get_napi_build_version_from_command_args(argv);\n  const source_build = gyp.opts['build-from-source'] || gyp.opts.build_from_source;\n  const update_binary = gyp.opts['update-binary'] || gyp.opts.update_binary;\n  const should_do_source_build = source_build === package_json.name || (source_build === true || source_build === 'true');\n  if (should_do_source_build) {\n    log.info('build', 'requesting source compile');\n    return do_build(gyp, argv, callback);\n  } else {\n    const fallback_to_build = gyp.opts['fallback-to-build'] || gyp.opts.fallback_to_build;\n    let should_do_fallback_build = fallback_to_build === package_json.name || (fallback_to_build === true || fallback_to_build === 'true');\n    // but allow override from npm\n    if (process.env.npm_config_argv) {\n      const cooked = JSON.parse(process.env.npm_config_argv).cooked;\n      const match = cooked.indexOf('--fallback-to-build');\n      if (match > -1 && cooked.length > match && cooked[match + 1] === 'false') {\n        should_do_fallback_build = false;\n        log.info('install', 'Build fallback disabled via npm flag: --fallback-to-build=false');\n      }\n    }\n    let opts;\n    try {\n      opts = versioning.evaluate(package_json, gyp.opts, napi_build_version);\n    } catch (err) {\n      return callback(err);\n    }\n\n    opts.ca = gyp.opts.ca;\n    opts.cafile = gyp.opts.cafile;\n\n    const from = opts.hosted_tarball;\n    const to = opts.module_path;\n    const binary_module = path.join(to, opts.module_name + '.node');\n    existsAsync(binary_module, (found) => {\n      if (!update_binary) {\n        if (found) {\n          console.log('[' + package_json.name + '] Success: \"' + binary_module + '\" already installed');\n          console.log('Pass --update-binary to reinstall or --build-from-source to recompile');\n          return callback();\n        }\n        log.info('check', 'checked for \"' + binary_module + '\" (not found)');\n      }\n\n      makeDir(to).then(() => {\n        const fileName = from.startsWith('file://') && from.slice('file://'.length);\n        if (fileName) {\n          extract_from_local(fileName, to, after_place);\n        } else {\n          place_binary(from, to, opts, after_place);\n        }\n      }).catch((err) => {\n        after_place(err);\n      });\n\n      function after_place(err) {\n        if (err && should_do_fallback_build) {\n          print_fallback_error(err, opts, package_json);\n          return do_build(gyp, argv, callback);\n        } else if (err) {\n          return callback(err);\n        } else {\n          console.log('[' + package_json.name + '] Success: \"' + binary_module + '\" is installed via remote');\n          return callback();\n        }\n      }\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}