{"ast":null,"code":"'use strict';\n\nconst MiniPass = require('minipass');\n\nconst Pax = require('./pax.js');\n\nconst Header = require('./header.js');\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst normPath = require('./normalize-windows-path.js');\n\nconst stripSlash = require('./strip-trailing-slashes.js');\n\nconst prefixPath = (path, prefix) => {\n  if (!prefix) {\n    return normPath(path);\n  }\n\n  path = normPath(path).replace(/^\\.(\\/|$)/, '');\n  return stripSlash(prefix) + '/' + path;\n};\n\nconst maxReadSize = 16 * 1024 * 1024;\nconst PROCESS = Symbol('process');\nconst FILE = Symbol('file');\nconst DIRECTORY = Symbol('directory');\nconst SYMLINK = Symbol('symlink');\nconst HARDLINK = Symbol('hardlink');\nconst HEADER = Symbol('header');\nconst READ = Symbol('read');\nconst LSTAT = Symbol('lstat');\nconst ONLSTAT = Symbol('onlstat');\nconst ONREAD = Symbol('onread');\nconst ONREADLINK = Symbol('onreadlink');\nconst OPENFILE = Symbol('openfile');\nconst ONOPENFILE = Symbol('onopenfile');\nconst CLOSE = Symbol('close');\nconst MODE = Symbol('mode');\nconst AWAITDRAIN = Symbol('awaitDrain');\nconst ONDRAIN = Symbol('ondrain');\nconst PREFIX = Symbol('prefix');\nconst HAD_ERROR = Symbol('hadError');\n\nconst warner = require('./warn-mixin.js');\n\nconst winchars = require('./winchars.js');\n\nconst stripAbsolutePath = require('./strip-absolute-path.js');\n\nconst modeFix = require('./mode-fix.js');\n\nconst WriteEntry = warner(class WriteEntry extends MiniPass {\n  constructor(p, opt) {\n    opt = opt || {};\n    super(opt);\n\n    if (typeof p !== 'string') {\n      throw new TypeError('path is required');\n    }\n\n    this.path = normPath(p); // suppress atime, ctime, uid, gid, uname, gname\n\n    this.portable = !!opt.portable; // until node has builtin pwnam functions, this'll have to do\n\n    this.myuid = process.getuid && process.getuid() || 0;\n    this.myuser = process.env.USER || '';\n    this.maxReadSize = opt.maxReadSize || maxReadSize;\n    this.linkCache = opt.linkCache || new Map();\n    this.statCache = opt.statCache || new Map();\n    this.preservePaths = !!opt.preservePaths;\n    this.cwd = normPath(opt.cwd || process.cwd());\n    this.strict = !!opt.strict;\n    this.noPax = !!opt.noPax;\n    this.noMtime = !!opt.noMtime;\n    this.mtime = opt.mtime || null;\n    this.prefix = opt.prefix ? normPath(opt.prefix) : null;\n    this.fd = null;\n    this.blockLen = null;\n    this.blockRemain = null;\n    this.buf = null;\n    this.offset = null;\n    this.length = null;\n    this.pos = null;\n    this.remain = null;\n\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn);\n    }\n\n    let pathWarn = false;\n\n    if (!this.preservePaths) {\n      const [root, stripped] = stripAbsolutePath(this.path);\n\n      if (root) {\n        this.path = stripped;\n        pathWarn = root;\n      }\n    }\n\n    this.win32 = !!opt.win32 || process.platform === 'win32';\n\n    if (this.win32) {\n      // force the \\ to / normalization, since we might not *actually*\n      // be on windows, but want \\ to be considered a path separator.\n      this.path = winchars.decode(this.path.replace(/\\\\/g, '/'));\n      p = p.replace(/\\\\/g, '/');\n    }\n\n    this.absolute = normPath(opt.absolute || path.resolve(this.cwd, p));\n\n    if (this.path === '') {\n      this.path = './';\n    }\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path\n      });\n    }\n\n    if (this.statCache.has(this.absolute)) {\n      this[ONLSTAT](this.statCache.get(this.absolute));\n    } else {\n      this[LSTAT]();\n    }\n  }\n\n  emit(ev) {\n    if (ev === 'error') {\n      this[HAD_ERROR] = true;\n    }\n\n    for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      data[_key - 1] = arguments[_key];\n    }\n\n    return super.emit(ev, ...data);\n  }\n\n  [LSTAT]() {\n    fs.lstat(this.absolute, (er, stat) => {\n      if (er) {\n        return this.emit('error', er);\n      }\n\n      this[ONLSTAT](stat);\n    });\n  }\n\n  [ONLSTAT](stat) {\n    this.statCache.set(this.absolute, stat);\n    this.stat = stat;\n\n    if (!stat.isFile()) {\n      stat.size = 0;\n    }\n\n    this.type = getType(stat);\n    this.emit('stat', stat);\n    this[PROCESS]();\n  }\n\n  [PROCESS]() {\n    switch (this.type) {\n      case 'File':\n        return this[FILE]();\n\n      case 'Directory':\n        return this[DIRECTORY]();\n\n      case 'SymbolicLink':\n        return this[SYMLINK]();\n      // unsupported types are ignored.\n\n      default:\n        return this.end();\n    }\n  }\n\n  [MODE](mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable);\n  }\n\n  [PREFIX](path) {\n    return prefixPath(path, this.prefix);\n  }\n\n  [HEADER]() {\n    if (this.type === 'Directory' && this.portable) {\n      this.noMtime = true;\n    }\n\n    this.header = new Header({\n      path: this[PREFIX](this.path),\n      // only apply the prefix to hard links.\n      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath) : this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this[MODE](this.stat.mode),\n      uid: this.portable ? null : this.stat.uid,\n      gid: this.portable ? null : this.stat.gid,\n      size: this.stat.size,\n      mtime: this.noMtime ? null : this.mtime || this.stat.mtime,\n      type: this.type,\n      uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : '',\n      atime: this.portable ? null : this.stat.atime,\n      ctime: this.portable ? null : this.stat.ctime\n    });\n\n    if (this.header.encode() && !this.noPax) {\n      super.write(new Pax({\n        atime: this.portable ? null : this.header.atime,\n        ctime: this.portable ? null : this.header.ctime,\n        gid: this.portable ? null : this.header.gid,\n        mtime: this.noMtime ? null : this.mtime || this.header.mtime,\n        path: this[PREFIX](this.path),\n        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath) : this.linkpath,\n        size: this.header.size,\n        uid: this.portable ? null : this.header.uid,\n        uname: this.portable ? null : this.header.uname,\n        dev: this.portable ? null : this.stat.dev,\n        ino: this.portable ? null : this.stat.ino,\n        nlink: this.portable ? null : this.stat.nlink\n      }).encode());\n    }\n\n    super.write(this.header.block);\n  }\n\n  [DIRECTORY]() {\n    if (this.path.slice(-1) !== '/') {\n      this.path += '/';\n    }\n\n    this.stat.size = 0;\n    this[HEADER]();\n    this.end();\n  }\n\n  [SYMLINK]() {\n    fs.readlink(this.absolute, (er, linkpath) => {\n      if (er) {\n        return this.emit('error', er);\n      }\n\n      this[ONREADLINK](linkpath);\n    });\n  }\n\n  [ONREADLINK](linkpath) {\n    this.linkpath = normPath(linkpath);\n    this[HEADER]();\n    this.end();\n  }\n\n  [HARDLINK](linkpath) {\n    this.type = 'Link';\n    this.linkpath = normPath(path.relative(this.cwd, linkpath));\n    this.stat.size = 0;\n    this[HEADER]();\n    this.end();\n  }\n\n  [FILE]() {\n    if (this.stat.nlink > 1) {\n      const linkKey = this.stat.dev + ':' + this.stat.ino;\n\n      if (this.linkCache.has(linkKey)) {\n        const linkpath = this.linkCache.get(linkKey);\n\n        if (linkpath.indexOf(this.cwd) === 0) {\n          return this[HARDLINK](linkpath);\n        }\n      }\n\n      this.linkCache.set(linkKey, this.absolute);\n    }\n\n    this[HEADER]();\n\n    if (this.stat.size === 0) {\n      return this.end();\n    }\n\n    this[OPENFILE]();\n  }\n\n  [OPENFILE]() {\n    fs.open(this.absolute, 'r', (er, fd) => {\n      if (er) {\n        return this.emit('error', er);\n      }\n\n      this[ONOPENFILE](fd);\n    });\n  }\n\n  [ONOPENFILE](fd) {\n    this.fd = fd;\n\n    if (this[HAD_ERROR]) {\n      return this[CLOSE]();\n    }\n\n    this.blockLen = 512 * Math.ceil(this.stat.size / 512);\n    this.blockRemain = this.blockLen;\n    const bufLen = Math.min(this.blockLen, this.maxReadSize);\n    this.buf = Buffer.allocUnsafe(bufLen);\n    this.offset = 0;\n    this.pos = 0;\n    this.remain = this.stat.size;\n    this.length = this.buf.length;\n    this[READ]();\n  }\n\n  [READ]() {\n    const {\n      fd,\n      buf,\n      offset,\n      length,\n      pos\n    } = this;\n    fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {\n      if (er) {\n        // ignoring the error from close(2) is a bad practice, but at\n        // this point we already have an error, don't need another one\n        return this[CLOSE](() => this.emit('error', er));\n      }\n\n      this[ONREAD](bytesRead);\n    });\n  }\n\n  [CLOSE](cb) {\n    fs.close(this.fd, cb);\n  }\n\n  [ONREAD](bytesRead) {\n    if (bytesRead <= 0 && this.remain > 0) {\n      const er = new Error('encountered unexpected EOF');\n      er.path = this.absolute;\n      er.syscall = 'read';\n      er.code = 'EOF';\n      return this[CLOSE](() => this.emit('error', er));\n    }\n\n    if (bytesRead > this.remain) {\n      const er = new Error('did not encounter expected EOF');\n      er.path = this.absolute;\n      er.syscall = 'read';\n      er.code = 'EOF';\n      return this[CLOSE](() => this.emit('error', er));\n    } // null out the rest of the buffer, if we could fit the block padding\n    // at the end of this loop, we've incremented bytesRead and this.remain\n    // to be incremented up to the blockRemain level, as if we had expected\n    // to get a null-padded file, and read it until the end.  then we will\n    // decrement both remain and blockRemain by bytesRead, and know that we\n    // reached the expected EOF, without any null buffer to append.\n\n\n    if (bytesRead === this.remain) {\n      for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {\n        this.buf[i + this.offset] = 0;\n        bytesRead++;\n        this.remain++;\n      }\n    }\n\n    const writeBuf = this.offset === 0 && bytesRead === this.buf.length ? this.buf : this.buf.slice(this.offset, this.offset + bytesRead);\n    const flushed = this.write(writeBuf);\n\n    if (!flushed) {\n      this[AWAITDRAIN](() => this[ONDRAIN]());\n    } else {\n      this[ONDRAIN]();\n    }\n  }\n\n  [AWAITDRAIN](cb) {\n    this.once('drain', cb);\n  }\n\n  write(writeBuf) {\n    if (this.blockRemain < writeBuf.length) {\n      const er = new Error('writing more data than expected');\n      er.path = this.absolute;\n      return this.emit('error', er);\n    }\n\n    this.remain -= writeBuf.length;\n    this.blockRemain -= writeBuf.length;\n    this.pos += writeBuf.length;\n    this.offset += writeBuf.length;\n    return super.write(writeBuf);\n  }\n\n  [ONDRAIN]() {\n    if (!this.remain) {\n      if (this.blockRemain) {\n        super.write(Buffer.alloc(this.blockRemain));\n      }\n\n      return this[CLOSE](er => er ? this.emit('error', er) : this.end());\n    }\n\n    if (this.offset >= this.length) {\n      // if we only have a smaller bit left to read, alloc a smaller buffer\n      // otherwise, keep it the same length it was before.\n      this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length));\n      this.offset = 0;\n    }\n\n    this.length = this.buf.length - this.offset;\n    this[READ]();\n  }\n\n});\n\nclass WriteEntrySync extends WriteEntry {\n  [LSTAT]() {\n    this[ONLSTAT](fs.lstatSync(this.absolute));\n  }\n\n  [SYMLINK]() {\n    this[ONREADLINK](fs.readlinkSync(this.absolute));\n  }\n\n  [OPENFILE]() {\n    this[ONOPENFILE](fs.openSync(this.absolute, 'r'));\n  }\n\n  [READ]() {\n    let threw = true;\n\n    try {\n      const {\n        fd,\n        buf,\n        offset,\n        length,\n        pos\n      } = this;\n      const bytesRead = fs.readSync(fd, buf, offset, length, pos);\n      this[ONREAD](bytesRead);\n      threw = false;\n    } finally {\n      // ignoring the error from close(2) is a bad practice, but at\n      // this point we already have an error, don't need another one\n      if (threw) {\n        try {\n          this[CLOSE](() => {});\n        } catch (er) {}\n      }\n    }\n  }\n\n  [AWAITDRAIN](cb) {\n    cb();\n  }\n\n  [CLOSE](cb) {\n    fs.closeSync(this.fd);\n    cb();\n  }\n\n}\n\nconst WriteEntryTar = warner(class WriteEntryTar extends MiniPass {\n  constructor(readEntry, opt) {\n    opt = opt || {};\n    super(opt);\n    this.preservePaths = !!opt.preservePaths;\n    this.portable = !!opt.portable;\n    this.strict = !!opt.strict;\n    this.noPax = !!opt.noPax;\n    this.noMtime = !!opt.noMtime;\n    this.readEntry = readEntry;\n    this.type = readEntry.type;\n\n    if (this.type === 'Directory' && this.portable) {\n      this.noMtime = true;\n    }\n\n    this.prefix = opt.prefix || null;\n    this.path = normPath(readEntry.path);\n    this.mode = this[MODE](readEntry.mode);\n    this.uid = this.portable ? null : readEntry.uid;\n    this.gid = this.portable ? null : readEntry.gid;\n    this.uname = this.portable ? null : readEntry.uname;\n    this.gname = this.portable ? null : readEntry.gname;\n    this.size = readEntry.size;\n    this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime;\n    this.atime = this.portable ? null : readEntry.atime;\n    this.ctime = this.portable ? null : readEntry.ctime;\n    this.linkpath = normPath(readEntry.linkpath);\n\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn);\n    }\n\n    let pathWarn = false;\n\n    if (!this.preservePaths) {\n      const [root, stripped] = stripAbsolutePath(this.path);\n\n      if (root) {\n        this.path = stripped;\n        pathWarn = root;\n      }\n    }\n\n    this.remain = readEntry.size;\n    this.blockRemain = readEntry.startBlockSize;\n    this.header = new Header({\n      path: this[PREFIX](this.path),\n      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath) : this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this.mode,\n      uid: this.portable ? null : this.uid,\n      gid: this.portable ? null : this.gid,\n      size: this.size,\n      mtime: this.noMtime ? null : this.mtime,\n      type: this.type,\n      uname: this.portable ? null : this.uname,\n      atime: this.portable ? null : this.atime,\n      ctime: this.portable ? null : this.ctime\n    });\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path\n      });\n    }\n\n    if (this.header.encode() && !this.noPax) {\n      super.write(new Pax({\n        atime: this.portable ? null : this.atime,\n        ctime: this.portable ? null : this.ctime,\n        gid: this.portable ? null : this.gid,\n        mtime: this.noMtime ? null : this.mtime,\n        path: this[PREFIX](this.path),\n        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath) : this.linkpath,\n        size: this.size,\n        uid: this.portable ? null : this.uid,\n        uname: this.portable ? null : this.uname,\n        dev: this.portable ? null : this.readEntry.dev,\n        ino: this.portable ? null : this.readEntry.ino,\n        nlink: this.portable ? null : this.readEntry.nlink\n      }).encode());\n    }\n\n    super.write(this.header.block);\n    readEntry.pipe(this);\n  }\n\n  [PREFIX](path) {\n    return prefixPath(path, this.prefix);\n  }\n\n  [MODE](mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable);\n  }\n\n  write(data) {\n    const writeLen = data.length;\n\n    if (writeLen > this.blockRemain) {\n      throw new Error('writing more to entry than is appropriate');\n    }\n\n    this.blockRemain -= writeLen;\n    return super.write(data);\n  }\n\n  end() {\n    if (this.blockRemain) {\n      super.write(Buffer.alloc(this.blockRemain));\n    }\n\n    return super.end();\n  }\n\n});\nWriteEntry.Sync = WriteEntrySync;\nWriteEntry.Tar = WriteEntryTar;\n\nconst getType = stat => stat.isFile() ? 'File' : stat.isDirectory() ? 'Directory' : stat.isSymbolicLink() ? 'SymbolicLink' : 'Unsupported';\n\nmodule.exports = WriteEntry;","map":{"version":3,"names":["MiniPass","require","Pax","Header","fs","path","normPath","stripSlash","prefixPath","prefix","replace","maxReadSize","PROCESS","Symbol","FILE","DIRECTORY","SYMLINK","HARDLINK","HEADER","READ","LSTAT","ONLSTAT","ONREAD","ONREADLINK","OPENFILE","ONOPENFILE","CLOSE","MODE","AWAITDRAIN","ONDRAIN","PREFIX","HAD_ERROR","warner","winchars","stripAbsolutePath","modeFix","WriteEntry","constructor","p","opt","TypeError","portable","myuid","process","getuid","myuser","env","USER","linkCache","Map","statCache","preservePaths","cwd","strict","noPax","noMtime","mtime","fd","blockLen","blockRemain","buf","offset","length","pos","remain","onwarn","on","pathWarn","root","stripped","win32","platform","decode","absolute","resolve","warn","entry","has","get","emit","ev","data","lstat","er","stat","set","isFile","size","type","getType","end","mode","header","linkpath","uid","gid","uname","atime","ctime","encode","write","dev","ino","nlink","block","slice","readlink","relative","linkKey","indexOf","open","Math","ceil","bufLen","min","Buffer","allocUnsafe","read","bytesRead","cb","close","Error","syscall","code","i","writeBuf","flushed","once","alloc","WriteEntrySync","lstatSync","readlinkSync","openSync","threw","readSync","closeSync","WriteEntryTar","readEntry","gname","startBlockSize","pipe","writeLen","Sync","Tar","isDirectory","isSymbolicLink","module","exports"],"sources":["/Users/aurele/Desktop/E-Commerce App/views/node_modules/tar/lib/write-entry.js"],"sourcesContent":["'use strict'\nconst MiniPass = require('minipass')\nconst Pax = require('./pax.js')\nconst Header = require('./header.js')\nconst fs = require('fs')\nconst path = require('path')\nconst normPath = require('./normalize-windows-path.js')\nconst stripSlash = require('./strip-trailing-slashes.js')\n\nconst prefixPath = (path, prefix) => {\n  if (!prefix) {\n    return normPath(path)\n  }\n  path = normPath(path).replace(/^\\.(\\/|$)/, '')\n  return stripSlash(prefix) + '/' + path\n}\n\nconst maxReadSize = 16 * 1024 * 1024\nconst PROCESS = Symbol('process')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst HEADER = Symbol('header')\nconst READ = Symbol('read')\nconst LSTAT = Symbol('lstat')\nconst ONLSTAT = Symbol('onlstat')\nconst ONREAD = Symbol('onread')\nconst ONREADLINK = Symbol('onreadlink')\nconst OPENFILE = Symbol('openfile')\nconst ONOPENFILE = Symbol('onopenfile')\nconst CLOSE = Symbol('close')\nconst MODE = Symbol('mode')\nconst AWAITDRAIN = Symbol('awaitDrain')\nconst ONDRAIN = Symbol('ondrain')\nconst PREFIX = Symbol('prefix')\nconst HAD_ERROR = Symbol('hadError')\nconst warner = require('./warn-mixin.js')\nconst winchars = require('./winchars.js')\nconst stripAbsolutePath = require('./strip-absolute-path.js')\n\nconst modeFix = require('./mode-fix.js')\n\nconst WriteEntry = warner(class WriteEntry extends MiniPass {\n  constructor (p, opt) {\n    opt = opt || {}\n    super(opt)\n    if (typeof p !== 'string') {\n      throw new TypeError('path is required')\n    }\n    this.path = normPath(p)\n    // suppress atime, ctime, uid, gid, uname, gname\n    this.portable = !!opt.portable\n    // until node has builtin pwnam functions, this'll have to do\n    this.myuid = process.getuid && process.getuid() || 0\n    this.myuser = process.env.USER || ''\n    this.maxReadSize = opt.maxReadSize || maxReadSize\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.preservePaths = !!opt.preservePaths\n    this.cwd = normPath(opt.cwd || process.cwd())\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n    this.prefix = opt.prefix ? normPath(opt.prefix) : null\n\n    this.fd = null\n    this.blockLen = null\n    this.blockRemain = null\n    this.buf = null\n    this.offset = null\n    this.length = null\n    this.pos = null\n    this.remain = null\n\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n\n    let pathWarn = false\n    if (!this.preservePaths) {\n      const [root, stripped] = stripAbsolutePath(this.path)\n      if (root) {\n        this.path = stripped\n        pathWarn = root\n      }\n    }\n\n    this.win32 = !!opt.win32 || process.platform === 'win32'\n    if (this.win32) {\n      // force the \\ to / normalization, since we might not *actually*\n      // be on windows, but want \\ to be considered a path separator.\n      this.path = winchars.decode(this.path.replace(/\\\\/g, '/'))\n      p = p.replace(/\\\\/g, '/')\n    }\n\n    this.absolute = normPath(opt.absolute || path.resolve(this.cwd, p))\n\n    if (this.path === '') {\n      this.path = './'\n    }\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path,\n      })\n    }\n\n    if (this.statCache.has(this.absolute)) {\n      this[ONLSTAT](this.statCache.get(this.absolute))\n    } else {\n      this[LSTAT]()\n    }\n  }\n\n  emit (ev, ...data) {\n    if (ev === 'error') {\n      this[HAD_ERROR] = true\n    }\n    return super.emit(ev, ...data)\n  }\n\n  [LSTAT] () {\n    fs.lstat(this.absolute, (er, stat) => {\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONLSTAT](stat)\n    })\n  }\n\n  [ONLSTAT] (stat) {\n    this.statCache.set(this.absolute, stat)\n    this.stat = stat\n    if (!stat.isFile()) {\n      stat.size = 0\n    }\n    this.type = getType(stat)\n    this.emit('stat', stat)\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    switch (this.type) {\n      case 'File': return this[FILE]()\n      case 'Directory': return this[DIRECTORY]()\n      case 'SymbolicLink': return this[SYMLINK]()\n      // unsupported types are ignored.\n      default: return this.end()\n    }\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable)\n  }\n\n  [PREFIX] (path) {\n    return prefixPath(path, this.prefix)\n  }\n\n  [HEADER] () {\n    if (this.type === 'Directory' && this.portable) {\n      this.noMtime = true\n    }\n\n    this.header = new Header({\n      path: this[PREFIX](this.path),\n      // only apply the prefix to hard links.\n      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n      : this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this[MODE](this.stat.mode),\n      uid: this.portable ? null : this.stat.uid,\n      gid: this.portable ? null : this.stat.gid,\n      size: this.stat.size,\n      mtime: this.noMtime ? null : this.mtime || this.stat.mtime,\n      type: this.type,\n      uname: this.portable ? null :\n      this.stat.uid === this.myuid ? this.myuser : '',\n      atime: this.portable ? null : this.stat.atime,\n      ctime: this.portable ? null : this.stat.ctime,\n    })\n\n    if (this.header.encode() && !this.noPax) {\n      super.write(new Pax({\n        atime: this.portable ? null : this.header.atime,\n        ctime: this.portable ? null : this.header.ctime,\n        gid: this.portable ? null : this.header.gid,\n        mtime: this.noMtime ? null : this.mtime || this.header.mtime,\n        path: this[PREFIX](this.path),\n        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n        : this.linkpath,\n        size: this.header.size,\n        uid: this.portable ? null : this.header.uid,\n        uname: this.portable ? null : this.header.uname,\n        dev: this.portable ? null : this.stat.dev,\n        ino: this.portable ? null : this.stat.ino,\n        nlink: this.portable ? null : this.stat.nlink,\n      }).encode())\n    }\n    super.write(this.header.block)\n  }\n\n  [DIRECTORY] () {\n    if (this.path.slice(-1) !== '/') {\n      this.path += '/'\n    }\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [SYMLINK] () {\n    fs.readlink(this.absolute, (er, linkpath) => {\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONREADLINK](linkpath)\n    })\n  }\n\n  [ONREADLINK] (linkpath) {\n    this.linkpath = normPath(linkpath)\n    this[HEADER]()\n    this.end()\n  }\n\n  [HARDLINK] (linkpath) {\n    this.type = 'Link'\n    this.linkpath = normPath(path.relative(this.cwd, linkpath))\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [FILE] () {\n    if (this.stat.nlink > 1) {\n      const linkKey = this.stat.dev + ':' + this.stat.ino\n      if (this.linkCache.has(linkKey)) {\n        const linkpath = this.linkCache.get(linkKey)\n        if (linkpath.indexOf(this.cwd) === 0) {\n          return this[HARDLINK](linkpath)\n        }\n      }\n      this.linkCache.set(linkKey, this.absolute)\n    }\n\n    this[HEADER]()\n    if (this.stat.size === 0) {\n      return this.end()\n    }\n\n    this[OPENFILE]()\n  }\n\n  [OPENFILE] () {\n    fs.open(this.absolute, 'r', (er, fd) => {\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONOPENFILE](fd)\n    })\n  }\n\n  [ONOPENFILE] (fd) {\n    this.fd = fd\n    if (this[HAD_ERROR]) {\n      return this[CLOSE]()\n    }\n\n    this.blockLen = 512 * Math.ceil(this.stat.size / 512)\n    this.blockRemain = this.blockLen\n    const bufLen = Math.min(this.blockLen, this.maxReadSize)\n    this.buf = Buffer.allocUnsafe(bufLen)\n    this.offset = 0\n    this.pos = 0\n    this.remain = this.stat.size\n    this.length = this.buf.length\n    this[READ]()\n  }\n\n  [READ] () {\n    const { fd, buf, offset, length, pos } = this\n    fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {\n      if (er) {\n        // ignoring the error from close(2) is a bad practice, but at\n        // this point we already have an error, don't need another one\n        return this[CLOSE](() => this.emit('error', er))\n      }\n      this[ONREAD](bytesRead)\n    })\n  }\n\n  [CLOSE] (cb) {\n    fs.close(this.fd, cb)\n  }\n\n  [ONREAD] (bytesRead) {\n    if (bytesRead <= 0 && this.remain > 0) {\n      const er = new Error('encountered unexpected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      return this[CLOSE](() => this.emit('error', er))\n    }\n\n    if (bytesRead > this.remain) {\n      const er = new Error('did not encounter expected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      return this[CLOSE](() => this.emit('error', er))\n    }\n\n    // null out the rest of the buffer, if we could fit the block padding\n    // at the end of this loop, we've incremented bytesRead and this.remain\n    // to be incremented up to the blockRemain level, as if we had expected\n    // to get a null-padded file, and read it until the end.  then we will\n    // decrement both remain and blockRemain by bytesRead, and know that we\n    // reached the expected EOF, without any null buffer to append.\n    if (bytesRead === this.remain) {\n      for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {\n        this.buf[i + this.offset] = 0\n        bytesRead++\n        this.remain++\n      }\n    }\n\n    const writeBuf = this.offset === 0 && bytesRead === this.buf.length ?\n      this.buf : this.buf.slice(this.offset, this.offset + bytesRead)\n\n    const flushed = this.write(writeBuf)\n    if (!flushed) {\n      this[AWAITDRAIN](() => this[ONDRAIN]())\n    } else {\n      this[ONDRAIN]()\n    }\n  }\n\n  [AWAITDRAIN] (cb) {\n    this.once('drain', cb)\n  }\n\n  write (writeBuf) {\n    if (this.blockRemain < writeBuf.length) {\n      const er = new Error('writing more data than expected')\n      er.path = this.absolute\n      return this.emit('error', er)\n    }\n    this.remain -= writeBuf.length\n    this.blockRemain -= writeBuf.length\n    this.pos += writeBuf.length\n    this.offset += writeBuf.length\n    return super.write(writeBuf)\n  }\n\n  [ONDRAIN] () {\n    if (!this.remain) {\n      if (this.blockRemain) {\n        super.write(Buffer.alloc(this.blockRemain))\n      }\n      return this[CLOSE](er => er ? this.emit('error', er) : this.end())\n    }\n\n    if (this.offset >= this.length) {\n      // if we only have a smaller bit left to read, alloc a smaller buffer\n      // otherwise, keep it the same length it was before.\n      this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length))\n      this.offset = 0\n    }\n    this.length = this.buf.length - this.offset\n    this[READ]()\n  }\n})\n\nclass WriteEntrySync extends WriteEntry {\n  [LSTAT] () {\n    this[ONLSTAT](fs.lstatSync(this.absolute))\n  }\n\n  [SYMLINK] () {\n    this[ONREADLINK](fs.readlinkSync(this.absolute))\n  }\n\n  [OPENFILE] () {\n    this[ONOPENFILE](fs.openSync(this.absolute, 'r'))\n  }\n\n  [READ] () {\n    let threw = true\n    try {\n      const { fd, buf, offset, length, pos } = this\n      const bytesRead = fs.readSync(fd, buf, offset, length, pos)\n      this[ONREAD](bytesRead)\n      threw = false\n    } finally {\n      // ignoring the error from close(2) is a bad practice, but at\n      // this point we already have an error, don't need another one\n      if (threw) {\n        try {\n          this[CLOSE](() => {})\n        } catch (er) {}\n      }\n    }\n  }\n\n  [AWAITDRAIN] (cb) {\n    cb()\n  }\n\n  [CLOSE] (cb) {\n    fs.closeSync(this.fd)\n    cb()\n  }\n}\n\nconst WriteEntryTar = warner(class WriteEntryTar extends MiniPass {\n  constructor (readEntry, opt) {\n    opt = opt || {}\n    super(opt)\n    this.preservePaths = !!opt.preservePaths\n    this.portable = !!opt.portable\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n\n    this.readEntry = readEntry\n    this.type = readEntry.type\n    if (this.type === 'Directory' && this.portable) {\n      this.noMtime = true\n    }\n\n    this.prefix = opt.prefix || null\n\n    this.path = normPath(readEntry.path)\n    this.mode = this[MODE](readEntry.mode)\n    this.uid = this.portable ? null : readEntry.uid\n    this.gid = this.portable ? null : readEntry.gid\n    this.uname = this.portable ? null : readEntry.uname\n    this.gname = this.portable ? null : readEntry.gname\n    this.size = readEntry.size\n    this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime\n    this.atime = this.portable ? null : readEntry.atime\n    this.ctime = this.portable ? null : readEntry.ctime\n    this.linkpath = normPath(readEntry.linkpath)\n\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n\n    let pathWarn = false\n    if (!this.preservePaths) {\n      const [root, stripped] = stripAbsolutePath(this.path)\n      if (root) {\n        this.path = stripped\n        pathWarn = root\n      }\n    }\n\n    this.remain = readEntry.size\n    this.blockRemain = readEntry.startBlockSize\n\n    this.header = new Header({\n      path: this[PREFIX](this.path),\n      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n      : this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this.mode,\n      uid: this.portable ? null : this.uid,\n      gid: this.portable ? null : this.gid,\n      size: this.size,\n      mtime: this.noMtime ? null : this.mtime,\n      type: this.type,\n      uname: this.portable ? null : this.uname,\n      atime: this.portable ? null : this.atime,\n      ctime: this.portable ? null : this.ctime,\n    })\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path,\n      })\n    }\n\n    if (this.header.encode() && !this.noPax) {\n      super.write(new Pax({\n        atime: this.portable ? null : this.atime,\n        ctime: this.portable ? null : this.ctime,\n        gid: this.portable ? null : this.gid,\n        mtime: this.noMtime ? null : this.mtime,\n        path: this[PREFIX](this.path),\n        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n        : this.linkpath,\n        size: this.size,\n        uid: this.portable ? null : this.uid,\n        uname: this.portable ? null : this.uname,\n        dev: this.portable ? null : this.readEntry.dev,\n        ino: this.portable ? null : this.readEntry.ino,\n        nlink: this.portable ? null : this.readEntry.nlink,\n      }).encode())\n    }\n\n    super.write(this.header.block)\n    readEntry.pipe(this)\n  }\n\n  [PREFIX] (path) {\n    return prefixPath(path, this.prefix)\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable)\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain) {\n      throw new Error('writing more to entry than is appropriate')\n    }\n    this.blockRemain -= writeLen\n    return super.write(data)\n  }\n\n  end () {\n    if (this.blockRemain) {\n      super.write(Buffer.alloc(this.blockRemain))\n    }\n    return super.end()\n  }\n})\n\nWriteEntry.Sync = WriteEntrySync\nWriteEntry.Tar = WriteEntryTar\n\nconst getType = stat =>\n  stat.isFile() ? 'File'\n  : stat.isDirectory() ? 'Directory'\n  : stat.isSymbolicLink() ? 'SymbolicLink'\n  : 'Unsupported'\n\nmodule.exports = WriteEntry\n"],"mappings":"AAAA;;AACA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,UAAD,CAAxB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,UAAD,CAAnB;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,aAAD,CAAtB;;AACA,MAAMG,EAAE,GAAGH,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMI,IAAI,GAAGJ,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMK,QAAQ,GAAGL,OAAO,CAAC,6BAAD,CAAxB;;AACA,MAAMM,UAAU,GAAGN,OAAO,CAAC,6BAAD,CAA1B;;AAEA,MAAMO,UAAU,GAAG,CAACH,IAAD,EAAOI,MAAP,KAAkB;EACnC,IAAI,CAACA,MAAL,EAAa;IACX,OAAOH,QAAQ,CAACD,IAAD,CAAf;EACD;;EACDA,IAAI,GAAGC,QAAQ,CAACD,IAAD,CAAR,CAAeK,OAAf,CAAuB,WAAvB,EAAoC,EAApC,CAAP;EACA,OAAOH,UAAU,CAACE,MAAD,CAAV,GAAqB,GAArB,GAA2BJ,IAAlC;AACD,CAND;;AAQA,MAAMM,WAAW,GAAG,KAAK,IAAL,GAAY,IAAhC;AACA,MAAMC,OAAO,GAAGC,MAAM,CAAC,SAAD,CAAtB;AACA,MAAMC,IAAI,GAAGD,MAAM,CAAC,MAAD,CAAnB;AACA,MAAME,SAAS,GAAGF,MAAM,CAAC,WAAD,CAAxB;AACA,MAAMG,OAAO,GAAGH,MAAM,CAAC,SAAD,CAAtB;AACA,MAAMI,QAAQ,GAAGJ,MAAM,CAAC,UAAD,CAAvB;AACA,MAAMK,MAAM,GAAGL,MAAM,CAAC,QAAD,CAArB;AACA,MAAMM,IAAI,GAAGN,MAAM,CAAC,MAAD,CAAnB;AACA,MAAMO,KAAK,GAAGP,MAAM,CAAC,OAAD,CAApB;AACA,MAAMQ,OAAO,GAAGR,MAAM,CAAC,SAAD,CAAtB;AACA,MAAMS,MAAM,GAAGT,MAAM,CAAC,QAAD,CAArB;AACA,MAAMU,UAAU,GAAGV,MAAM,CAAC,YAAD,CAAzB;AACA,MAAMW,QAAQ,GAAGX,MAAM,CAAC,UAAD,CAAvB;AACA,MAAMY,UAAU,GAAGZ,MAAM,CAAC,YAAD,CAAzB;AACA,MAAMa,KAAK,GAAGb,MAAM,CAAC,OAAD,CAApB;AACA,MAAMc,IAAI,GAAGd,MAAM,CAAC,MAAD,CAAnB;AACA,MAAMe,UAAU,GAAGf,MAAM,CAAC,YAAD,CAAzB;AACA,MAAMgB,OAAO,GAAGhB,MAAM,CAAC,SAAD,CAAtB;AACA,MAAMiB,MAAM,GAAGjB,MAAM,CAAC,QAAD,CAArB;AACA,MAAMkB,SAAS,GAAGlB,MAAM,CAAC,UAAD,CAAxB;;AACA,MAAMmB,MAAM,GAAG/B,OAAO,CAAC,iBAAD,CAAtB;;AACA,MAAMgC,QAAQ,GAAGhC,OAAO,CAAC,eAAD,CAAxB;;AACA,MAAMiC,iBAAiB,GAAGjC,OAAO,CAAC,0BAAD,CAAjC;;AAEA,MAAMkC,OAAO,GAAGlC,OAAO,CAAC,eAAD,CAAvB;;AAEA,MAAMmC,UAAU,GAAGJ,MAAM,CAAC,MAAMI,UAAN,SAAyBpC,QAAzB,CAAkC;EAC1DqC,WAAW,CAAEC,CAAF,EAAKC,GAAL,EAAU;IACnBA,GAAG,GAAGA,GAAG,IAAI,EAAb;IACA,MAAMA,GAAN;;IACA,IAAI,OAAOD,CAAP,KAAa,QAAjB,EAA2B;MACzB,MAAM,IAAIE,SAAJ,CAAc,kBAAd,CAAN;IACD;;IACD,KAAKnC,IAAL,GAAYC,QAAQ,CAACgC,CAAD,CAApB,CANmB,CAOnB;;IACA,KAAKG,QAAL,GAAgB,CAAC,CAACF,GAAG,CAACE,QAAtB,CARmB,CASnB;;IACA,KAAKC,KAAL,GAAaC,OAAO,CAACC,MAAR,IAAkBD,OAAO,CAACC,MAAR,EAAlB,IAAsC,CAAnD;IACA,KAAKC,MAAL,GAAcF,OAAO,CAACG,GAAR,CAAYC,IAAZ,IAAoB,EAAlC;IACA,KAAKpC,WAAL,GAAmB4B,GAAG,CAAC5B,WAAJ,IAAmBA,WAAtC;IACA,KAAKqC,SAAL,GAAiBT,GAAG,CAACS,SAAJ,IAAiB,IAAIC,GAAJ,EAAlC;IACA,KAAKC,SAAL,GAAiBX,GAAG,CAACW,SAAJ,IAAiB,IAAID,GAAJ,EAAlC;IACA,KAAKE,aAAL,GAAqB,CAAC,CAACZ,GAAG,CAACY,aAA3B;IACA,KAAKC,GAAL,GAAW9C,QAAQ,CAACiC,GAAG,CAACa,GAAJ,IAAWT,OAAO,CAACS,GAAR,EAAZ,CAAnB;IACA,KAAKC,MAAL,GAAc,CAAC,CAACd,GAAG,CAACc,MAApB;IACA,KAAKC,KAAL,GAAa,CAAC,CAACf,GAAG,CAACe,KAAnB;IACA,KAAKC,OAAL,GAAe,CAAC,CAAChB,GAAG,CAACgB,OAArB;IACA,KAAKC,KAAL,GAAajB,GAAG,CAACiB,KAAJ,IAAa,IAA1B;IACA,KAAK/C,MAAL,GAAc8B,GAAG,CAAC9B,MAAJ,GAAaH,QAAQ,CAACiC,GAAG,CAAC9B,MAAL,CAArB,GAAoC,IAAlD;IAEA,KAAKgD,EAAL,GAAU,IAAV;IACA,KAAKC,QAAL,GAAgB,IAAhB;IACA,KAAKC,WAAL,GAAmB,IAAnB;IACA,KAAKC,GAAL,GAAW,IAAX;IACA,KAAKC,MAAL,GAAc,IAAd;IACA,KAAKC,MAAL,GAAc,IAAd;IACA,KAAKC,GAAL,GAAW,IAAX;IACA,KAAKC,MAAL,GAAc,IAAd;;IAEA,IAAI,OAAOzB,GAAG,CAAC0B,MAAX,KAAsB,UAA1B,EAAsC;MACpC,KAAKC,EAAL,CAAQ,MAAR,EAAgB3B,GAAG,CAAC0B,MAApB;IACD;;IAED,IAAIE,QAAQ,GAAG,KAAf;;IACA,IAAI,CAAC,KAAKhB,aAAV,EAAyB;MACvB,MAAM,CAACiB,IAAD,EAAOC,QAAP,IAAmBnC,iBAAiB,CAAC,KAAK7B,IAAN,CAA1C;;MACA,IAAI+D,IAAJ,EAAU;QACR,KAAK/D,IAAL,GAAYgE,QAAZ;QACAF,QAAQ,GAAGC,IAAX;MACD;IACF;;IAED,KAAKE,KAAL,GAAa,CAAC,CAAC/B,GAAG,CAAC+B,KAAN,IAAe3B,OAAO,CAAC4B,QAAR,KAAqB,OAAjD;;IACA,IAAI,KAAKD,KAAT,EAAgB;MACd;MACA;MACA,KAAKjE,IAAL,GAAY4B,QAAQ,CAACuC,MAAT,CAAgB,KAAKnE,IAAL,CAAUK,OAAV,CAAkB,KAAlB,EAAyB,GAAzB,CAAhB,CAAZ;MACA4B,CAAC,GAAGA,CAAC,CAAC5B,OAAF,CAAU,KAAV,EAAiB,GAAjB,CAAJ;IACD;;IAED,KAAK+D,QAAL,GAAgBnE,QAAQ,CAACiC,GAAG,CAACkC,QAAJ,IAAgBpE,IAAI,CAACqE,OAAL,CAAa,KAAKtB,GAAlB,EAAuBd,CAAvB,CAAjB,CAAxB;;IAEA,IAAI,KAAKjC,IAAL,KAAc,EAAlB,EAAsB;MACpB,KAAKA,IAAL,GAAY,IAAZ;IACD;;IAED,IAAI8D,QAAJ,EAAc;MACZ,KAAKQ,IAAL,CAAU,gBAAV,EAA6B,aAAYR,QAAS,qBAAlD,EAAwE;QACtES,KAAK,EAAE,IAD+D;QAEtEvE,IAAI,EAAE8D,QAAQ,GAAG,KAAK9D;MAFgD,CAAxE;IAID;;IAED,IAAI,KAAK6C,SAAL,CAAe2B,GAAf,CAAmB,KAAKJ,QAAxB,CAAJ,EAAuC;MACrC,KAAKpD,OAAL,EAAc,KAAK6B,SAAL,CAAe4B,GAAf,CAAmB,KAAKL,QAAxB,CAAd;IACD,CAFD,MAEO;MACL,KAAKrD,KAAL;IACD;EACF;;EAED2D,IAAI,CAAEC,EAAF,EAAe;IACjB,IAAIA,EAAE,KAAK,OAAX,EAAoB;MAClB,KAAKjD,SAAL,IAAkB,IAAlB;IACD;;IAHgB,kCAANkD,IAAM;MAANA,IAAM;IAAA;;IAIjB,OAAO,MAAMF,IAAN,CAAWC,EAAX,EAAe,GAAGC,IAAlB,CAAP;EACD;;EAEK,CAAL7D,KAAK,IAAK;IACThB,EAAE,CAAC8E,KAAH,CAAS,KAAKT,QAAd,EAAwB,CAACU,EAAD,EAAKC,IAAL,KAAc;MACpC,IAAID,EAAJ,EAAQ;QACN,OAAO,KAAKJ,IAAL,CAAU,OAAV,EAAmBI,EAAnB,CAAP;MACD;;MACD,KAAK9D,OAAL,EAAc+D,IAAd;IACD,CALD;EAMD;;EAEO,CAAP/D,OAAO,EAAG+D,IAAH,EAAS;IACf,KAAKlC,SAAL,CAAemC,GAAf,CAAmB,KAAKZ,QAAxB,EAAkCW,IAAlC;IACA,KAAKA,IAAL,GAAYA,IAAZ;;IACA,IAAI,CAACA,IAAI,CAACE,MAAL,EAAL,EAAoB;MAClBF,IAAI,CAACG,IAAL,GAAY,CAAZ;IACD;;IACD,KAAKC,IAAL,GAAYC,OAAO,CAACL,IAAD,CAAnB;IACA,KAAKL,IAAL,CAAU,MAAV,EAAkBK,IAAlB;IACA,KAAKxE,OAAL;EACD;;EAEO,CAAPA,OAAO,IAAK;IACX,QAAQ,KAAK4E,IAAb;MACE,KAAK,MAAL;QAAa,OAAO,KAAK1E,IAAL,GAAP;;MACb,KAAK,WAAL;QAAkB,OAAO,KAAKC,SAAL,GAAP;;MAClB,KAAK,cAAL;QAAqB,OAAO,KAAKC,OAAL,GAAP;MACrB;;MACA;QAAS,OAAO,KAAK0E,GAAL,EAAP;IALX;EAOD;;EAEI,CAAJ/D,IAAI,EAAGgE,IAAH,EAAS;IACZ,OAAOxD,OAAO,CAACwD,IAAD,EAAO,KAAKH,IAAL,KAAc,WAArB,EAAkC,KAAK/C,QAAvC,CAAd;EACD;;EAEM,CAANX,MAAM,EAAGzB,IAAH,EAAS;IACd,OAAOG,UAAU,CAACH,IAAD,EAAO,KAAKI,MAAZ,CAAjB;EACD;;EAEM,CAANS,MAAM,IAAK;IACV,IAAI,KAAKsE,IAAL,KAAc,WAAd,IAA6B,KAAK/C,QAAtC,EAAgD;MAC9C,KAAKc,OAAL,GAAe,IAAf;IACD;;IAED,KAAKqC,MAAL,GAAc,IAAIzF,MAAJ,CAAW;MACvBE,IAAI,EAAE,KAAKyB,MAAL,EAAa,KAAKzB,IAAlB,CADiB;MAEvB;MACAwF,QAAQ,EAAE,KAAKL,IAAL,KAAc,MAAd,GAAuB,KAAK1D,MAAL,EAAa,KAAK+D,QAAlB,CAAvB,GACR,KAAKA,QAJgB;MAKvB;MACA;MACAF,IAAI,EAAE,KAAKhE,IAAL,EAAW,KAAKyD,IAAL,CAAUO,IAArB,CAPiB;MAQvBG,GAAG,EAAE,KAAKrD,QAAL,GAAgB,IAAhB,GAAuB,KAAK2C,IAAL,CAAUU,GARf;MASvBC,GAAG,EAAE,KAAKtD,QAAL,GAAgB,IAAhB,GAAuB,KAAK2C,IAAL,CAAUW,GATf;MAUvBR,IAAI,EAAE,KAAKH,IAAL,CAAUG,IAVO;MAWvB/B,KAAK,EAAE,KAAKD,OAAL,GAAe,IAAf,GAAsB,KAAKC,KAAL,IAAc,KAAK4B,IAAL,CAAU5B,KAX9B;MAYvBgC,IAAI,EAAE,KAAKA,IAZY;MAavBQ,KAAK,EAAE,KAAKvD,QAAL,GAAgB,IAAhB,GACP,KAAK2C,IAAL,CAAUU,GAAV,KAAkB,KAAKpD,KAAvB,GAA+B,KAAKG,MAApC,GAA6C,EAdtB;MAevBoD,KAAK,EAAE,KAAKxD,QAAL,GAAgB,IAAhB,GAAuB,KAAK2C,IAAL,CAAUa,KAfjB;MAgBvBC,KAAK,EAAE,KAAKzD,QAAL,GAAgB,IAAhB,GAAuB,KAAK2C,IAAL,CAAUc;IAhBjB,CAAX,CAAd;;IAmBA,IAAI,KAAKN,MAAL,CAAYO,MAAZ,MAAwB,CAAC,KAAK7C,KAAlC,EAAyC;MACvC,MAAM8C,KAAN,CAAY,IAAIlG,GAAJ,CAAQ;QAClB+F,KAAK,EAAE,KAAKxD,QAAL,GAAgB,IAAhB,GAAuB,KAAKmD,MAAL,CAAYK,KADxB;QAElBC,KAAK,EAAE,KAAKzD,QAAL,GAAgB,IAAhB,GAAuB,KAAKmD,MAAL,CAAYM,KAFxB;QAGlBH,GAAG,EAAE,KAAKtD,QAAL,GAAgB,IAAhB,GAAuB,KAAKmD,MAAL,CAAYG,GAHtB;QAIlBvC,KAAK,EAAE,KAAKD,OAAL,GAAe,IAAf,GAAsB,KAAKC,KAAL,IAAc,KAAKoC,MAAL,CAAYpC,KAJrC;QAKlBnD,IAAI,EAAE,KAAKyB,MAAL,EAAa,KAAKzB,IAAlB,CALY;QAMlBwF,QAAQ,EAAE,KAAKL,IAAL,KAAc,MAAd,GAAuB,KAAK1D,MAAL,EAAa,KAAK+D,QAAlB,CAAvB,GACR,KAAKA,QAPW;QAQlBN,IAAI,EAAE,KAAKK,MAAL,CAAYL,IARA;QASlBO,GAAG,EAAE,KAAKrD,QAAL,GAAgB,IAAhB,GAAuB,KAAKmD,MAAL,CAAYE,GATtB;QAUlBE,KAAK,EAAE,KAAKvD,QAAL,GAAgB,IAAhB,GAAuB,KAAKmD,MAAL,CAAYI,KAVxB;QAWlBK,GAAG,EAAE,KAAK5D,QAAL,GAAgB,IAAhB,GAAuB,KAAK2C,IAAL,CAAUiB,GAXpB;QAYlBC,GAAG,EAAE,KAAK7D,QAAL,GAAgB,IAAhB,GAAuB,KAAK2C,IAAL,CAAUkB,GAZpB;QAalBC,KAAK,EAAE,KAAK9D,QAAL,GAAgB,IAAhB,GAAuB,KAAK2C,IAAL,CAAUmB;MAbtB,CAAR,EAcTJ,MAdS,EAAZ;IAeD;;IACD,MAAMC,KAAN,CAAY,KAAKR,MAAL,CAAYY,KAAxB;EACD;;EAES,CAATzF,SAAS,IAAK;IACb,IAAI,KAAKV,IAAL,CAAUoG,KAAV,CAAgB,CAAC,CAAjB,MAAwB,GAA5B,EAAiC;MAC/B,KAAKpG,IAAL,IAAa,GAAb;IACD;;IACD,KAAK+E,IAAL,CAAUG,IAAV,GAAiB,CAAjB;IACA,KAAKrE,MAAL;IACA,KAAKwE,GAAL;EACD;;EAEO,CAAP1E,OAAO,IAAK;IACXZ,EAAE,CAACsG,QAAH,CAAY,KAAKjC,QAAjB,EAA2B,CAACU,EAAD,EAAKU,QAAL,KAAkB;MAC3C,IAAIV,EAAJ,EAAQ;QACN,OAAO,KAAKJ,IAAL,CAAU,OAAV,EAAmBI,EAAnB,CAAP;MACD;;MACD,KAAK5D,UAAL,EAAiBsE,QAAjB;IACD,CALD;EAMD;;EAEU,CAAVtE,UAAU,EAAGsE,QAAH,EAAa;IACtB,KAAKA,QAAL,GAAgBvF,QAAQ,CAACuF,QAAD,CAAxB;IACA,KAAK3E,MAAL;IACA,KAAKwE,GAAL;EACD;;EAEQ,CAARzE,QAAQ,EAAG4E,QAAH,EAAa;IACpB,KAAKL,IAAL,GAAY,MAAZ;IACA,KAAKK,QAAL,GAAgBvF,QAAQ,CAACD,IAAI,CAACsG,QAAL,CAAc,KAAKvD,GAAnB,EAAwByC,QAAxB,CAAD,CAAxB;IACA,KAAKT,IAAL,CAAUG,IAAV,GAAiB,CAAjB;IACA,KAAKrE,MAAL;IACA,KAAKwE,GAAL;EACD;;EAEI,CAAJ5E,IAAI,IAAK;IACR,IAAI,KAAKsE,IAAL,CAAUmB,KAAV,GAAkB,CAAtB,EAAyB;MACvB,MAAMK,OAAO,GAAG,KAAKxB,IAAL,CAAUiB,GAAV,GAAgB,GAAhB,GAAsB,KAAKjB,IAAL,CAAUkB,GAAhD;;MACA,IAAI,KAAKtD,SAAL,CAAe6B,GAAf,CAAmB+B,OAAnB,CAAJ,EAAiC;QAC/B,MAAMf,QAAQ,GAAG,KAAK7C,SAAL,CAAe8B,GAAf,CAAmB8B,OAAnB,CAAjB;;QACA,IAAIf,QAAQ,CAACgB,OAAT,CAAiB,KAAKzD,GAAtB,MAA+B,CAAnC,EAAsC;UACpC,OAAO,KAAKnC,QAAL,EAAe4E,QAAf,CAAP;QACD;MACF;;MACD,KAAK7C,SAAL,CAAeqC,GAAf,CAAmBuB,OAAnB,EAA4B,KAAKnC,QAAjC;IACD;;IAED,KAAKvD,MAAL;;IACA,IAAI,KAAKkE,IAAL,CAAUG,IAAV,KAAmB,CAAvB,EAA0B;MACxB,OAAO,KAAKG,GAAL,EAAP;IACD;;IAED,KAAKlE,QAAL;EACD;;EAEQ,CAARA,QAAQ,IAAK;IACZpB,EAAE,CAAC0G,IAAH,CAAQ,KAAKrC,QAAb,EAAuB,GAAvB,EAA4B,CAACU,EAAD,EAAK1B,EAAL,KAAY;MACtC,IAAI0B,EAAJ,EAAQ;QACN,OAAO,KAAKJ,IAAL,CAAU,OAAV,EAAmBI,EAAnB,CAAP;MACD;;MACD,KAAK1D,UAAL,EAAiBgC,EAAjB;IACD,CALD;EAMD;;EAEU,CAAVhC,UAAU,EAAGgC,EAAH,EAAO;IAChB,KAAKA,EAAL,GAAUA,EAAV;;IACA,IAAI,KAAK1B,SAAL,CAAJ,EAAqB;MACnB,OAAO,KAAKL,KAAL,GAAP;IACD;;IAED,KAAKgC,QAAL,GAAgB,MAAMqD,IAAI,CAACC,IAAL,CAAU,KAAK5B,IAAL,CAAUG,IAAV,GAAiB,GAA3B,CAAtB;IACA,KAAK5B,WAAL,GAAmB,KAAKD,QAAxB;IACA,MAAMuD,MAAM,GAAGF,IAAI,CAACG,GAAL,CAAS,KAAKxD,QAAd,EAAwB,KAAK/C,WAA7B,CAAf;IACA,KAAKiD,GAAL,GAAWuD,MAAM,CAACC,WAAP,CAAmBH,MAAnB,CAAX;IACA,KAAKpD,MAAL,GAAc,CAAd;IACA,KAAKE,GAAL,GAAW,CAAX;IACA,KAAKC,MAAL,GAAc,KAAKoB,IAAL,CAAUG,IAAxB;IACA,KAAKzB,MAAL,GAAc,KAAKF,GAAL,CAASE,MAAvB;IACA,KAAK3C,IAAL;EACD;;EAEI,CAAJA,IAAI,IAAK;IACR,MAAM;MAAEsC,EAAF;MAAMG,GAAN;MAAWC,MAAX;MAAmBC,MAAnB;MAA2BC;IAA3B,IAAmC,IAAzC;IACA3D,EAAE,CAACiH,IAAH,CAAQ5D,EAAR,EAAYG,GAAZ,EAAiBC,MAAjB,EAAyBC,MAAzB,EAAiCC,GAAjC,EAAsC,CAACoB,EAAD,EAAKmC,SAAL,KAAmB;MACvD,IAAInC,EAAJ,EAAQ;QACN;QACA;QACA,OAAO,KAAKzD,KAAL,EAAY,MAAM,KAAKqD,IAAL,CAAU,OAAV,EAAmBI,EAAnB,CAAlB,CAAP;MACD;;MACD,KAAK7D,MAAL,EAAagG,SAAb;IACD,CAPD;EAQD;;EAEK,CAAL5F,KAAK,EAAG6F,EAAH,EAAO;IACXnH,EAAE,CAACoH,KAAH,CAAS,KAAK/D,EAAd,EAAkB8D,EAAlB;EACD;;EAEM,CAANjG,MAAM,EAAGgG,SAAH,EAAc;IACnB,IAAIA,SAAS,IAAI,CAAb,IAAkB,KAAKtD,MAAL,GAAc,CAApC,EAAuC;MACrC,MAAMmB,EAAE,GAAG,IAAIsC,KAAJ,CAAU,4BAAV,CAAX;MACAtC,EAAE,CAAC9E,IAAH,GAAU,KAAKoE,QAAf;MACAU,EAAE,CAACuC,OAAH,GAAa,MAAb;MACAvC,EAAE,CAACwC,IAAH,GAAU,KAAV;MACA,OAAO,KAAKjG,KAAL,EAAY,MAAM,KAAKqD,IAAL,CAAU,OAAV,EAAmBI,EAAnB,CAAlB,CAAP;IACD;;IAED,IAAImC,SAAS,GAAG,KAAKtD,MAArB,EAA6B;MAC3B,MAAMmB,EAAE,GAAG,IAAIsC,KAAJ,CAAU,gCAAV,CAAX;MACAtC,EAAE,CAAC9E,IAAH,GAAU,KAAKoE,QAAf;MACAU,EAAE,CAACuC,OAAH,GAAa,MAAb;MACAvC,EAAE,CAACwC,IAAH,GAAU,KAAV;MACA,OAAO,KAAKjG,KAAL,EAAY,MAAM,KAAKqD,IAAL,CAAU,OAAV,EAAmBI,EAAnB,CAAlB,CAAP;IACD,CAfkB,CAiBnB;IACA;IACA;IACA;IACA;IACA;;;IACA,IAAImC,SAAS,KAAK,KAAKtD,MAAvB,EAA+B;MAC7B,KAAK,IAAI4D,CAAC,GAAGN,SAAb,EAAwBM,CAAC,GAAG,KAAK9D,MAAT,IAAmBwD,SAAS,GAAG,KAAK3D,WAA5D,EAAyEiE,CAAC,EAA1E,EAA8E;QAC5E,KAAKhE,GAAL,CAASgE,CAAC,GAAG,KAAK/D,MAAlB,IAA4B,CAA5B;QACAyD,SAAS;QACT,KAAKtD,MAAL;MACD;IACF;;IAED,MAAM6D,QAAQ,GAAG,KAAKhE,MAAL,KAAgB,CAAhB,IAAqByD,SAAS,KAAK,KAAK1D,GAAL,CAASE,MAA5C,GACf,KAAKF,GADU,GACJ,KAAKA,GAAL,CAAS6C,KAAT,CAAe,KAAK5C,MAApB,EAA4B,KAAKA,MAAL,GAAcyD,SAA1C,CADb;IAGA,MAAMQ,OAAO,GAAG,KAAK1B,KAAL,CAAWyB,QAAX,CAAhB;;IACA,IAAI,CAACC,OAAL,EAAc;MACZ,KAAKlG,UAAL,EAAiB,MAAM,KAAKC,OAAL,GAAvB;IACD,CAFD,MAEO;MACL,KAAKA,OAAL;IACD;EACF;;EAEU,CAAVD,UAAU,EAAG2F,EAAH,EAAO;IAChB,KAAKQ,IAAL,CAAU,OAAV,EAAmBR,EAAnB;EACD;;EAEDnB,KAAK,CAAEyB,QAAF,EAAY;IACf,IAAI,KAAKlE,WAAL,GAAmBkE,QAAQ,CAAC/D,MAAhC,EAAwC;MACtC,MAAMqB,EAAE,GAAG,IAAIsC,KAAJ,CAAU,iCAAV,CAAX;MACAtC,EAAE,CAAC9E,IAAH,GAAU,KAAKoE,QAAf;MACA,OAAO,KAAKM,IAAL,CAAU,OAAV,EAAmBI,EAAnB,CAAP;IACD;;IACD,KAAKnB,MAAL,IAAe6D,QAAQ,CAAC/D,MAAxB;IACA,KAAKH,WAAL,IAAoBkE,QAAQ,CAAC/D,MAA7B;IACA,KAAKC,GAAL,IAAY8D,QAAQ,CAAC/D,MAArB;IACA,KAAKD,MAAL,IAAegE,QAAQ,CAAC/D,MAAxB;IACA,OAAO,MAAMsC,KAAN,CAAYyB,QAAZ,CAAP;EACD;;EAEO,CAAPhG,OAAO,IAAK;IACX,IAAI,CAAC,KAAKmC,MAAV,EAAkB;MAChB,IAAI,KAAKL,WAAT,EAAsB;QACpB,MAAMyC,KAAN,CAAYe,MAAM,CAACa,KAAP,CAAa,KAAKrE,WAAlB,CAAZ;MACD;;MACD,OAAO,KAAKjC,KAAL,EAAYyD,EAAE,IAAIA,EAAE,GAAG,KAAKJ,IAAL,CAAU,OAAV,EAAmBI,EAAnB,CAAH,GAA4B,KAAKO,GAAL,EAAhD,CAAP;IACD;;IAED,IAAI,KAAK7B,MAAL,IAAe,KAAKC,MAAxB,EAAgC;MAC9B;MACA;MACA,KAAKF,GAAL,GAAWuD,MAAM,CAACC,WAAP,CAAmBL,IAAI,CAACG,GAAL,CAAS,KAAKvD,WAAd,EAA2B,KAAKC,GAAL,CAASE,MAApC,CAAnB,CAAX;MACA,KAAKD,MAAL,GAAc,CAAd;IACD;;IACD,KAAKC,MAAL,GAAc,KAAKF,GAAL,CAASE,MAAT,GAAkB,KAAKD,MAArC;IACA,KAAK1C,IAAL;EACD;;AA5UyD,CAAnC,CAAzB;;AA+UA,MAAM8G,cAAN,SAA6B7F,UAA7B,CAAwC;EAChC,CAALhB,KAAK,IAAK;IACT,KAAKC,OAAL,EAAcjB,EAAE,CAAC8H,SAAH,CAAa,KAAKzD,QAAlB,CAAd;EACD;;EAEO,CAAPzD,OAAO,IAAK;IACX,KAAKO,UAAL,EAAiBnB,EAAE,CAAC+H,YAAH,CAAgB,KAAK1D,QAArB,CAAjB;EACD;;EAEQ,CAARjD,QAAQ,IAAK;IACZ,KAAKC,UAAL,EAAiBrB,EAAE,CAACgI,QAAH,CAAY,KAAK3D,QAAjB,EAA2B,GAA3B,CAAjB;EACD;;EAEI,CAAJtD,IAAI,IAAK;IACR,IAAIkH,KAAK,GAAG,IAAZ;;IACA,IAAI;MACF,MAAM;QAAE5E,EAAF;QAAMG,GAAN;QAAWC,MAAX;QAAmBC,MAAnB;QAA2BC;MAA3B,IAAmC,IAAzC;MACA,MAAMuD,SAAS,GAAGlH,EAAE,CAACkI,QAAH,CAAY7E,EAAZ,EAAgBG,GAAhB,EAAqBC,MAArB,EAA6BC,MAA7B,EAAqCC,GAArC,CAAlB;MACA,KAAKzC,MAAL,EAAagG,SAAb;MACAe,KAAK,GAAG,KAAR;IACD,CALD,SAKU;MACR;MACA;MACA,IAAIA,KAAJ,EAAW;QACT,IAAI;UACF,KAAK3G,KAAL,EAAY,MAAM,CAAE,CAApB;QACD,CAFD,CAEE,OAAOyD,EAAP,EAAW,CAAE;MAChB;IACF;EACF;;EAEU,CAAVvD,UAAU,EAAG2F,EAAH,EAAO;IAChBA,EAAE;EACH;;EAEK,CAAL7F,KAAK,EAAG6F,EAAH,EAAO;IACXnH,EAAE,CAACmI,SAAH,CAAa,KAAK9E,EAAlB;IACA8D,EAAE;EACH;;AAtCqC;;AAyCxC,MAAMiB,aAAa,GAAGxG,MAAM,CAAC,MAAMwG,aAAN,SAA4BxI,QAA5B,CAAqC;EAChEqC,WAAW,CAAEoG,SAAF,EAAalG,GAAb,EAAkB;IAC3BA,GAAG,GAAGA,GAAG,IAAI,EAAb;IACA,MAAMA,GAAN;IACA,KAAKY,aAAL,GAAqB,CAAC,CAACZ,GAAG,CAACY,aAA3B;IACA,KAAKV,QAAL,GAAgB,CAAC,CAACF,GAAG,CAACE,QAAtB;IACA,KAAKY,MAAL,GAAc,CAAC,CAACd,GAAG,CAACc,MAApB;IACA,KAAKC,KAAL,GAAa,CAAC,CAACf,GAAG,CAACe,KAAnB;IACA,KAAKC,OAAL,GAAe,CAAC,CAAChB,GAAG,CAACgB,OAArB;IAEA,KAAKkF,SAAL,GAAiBA,SAAjB;IACA,KAAKjD,IAAL,GAAYiD,SAAS,CAACjD,IAAtB;;IACA,IAAI,KAAKA,IAAL,KAAc,WAAd,IAA6B,KAAK/C,QAAtC,EAAgD;MAC9C,KAAKc,OAAL,GAAe,IAAf;IACD;;IAED,KAAK9C,MAAL,GAAc8B,GAAG,CAAC9B,MAAJ,IAAc,IAA5B;IAEA,KAAKJ,IAAL,GAAYC,QAAQ,CAACmI,SAAS,CAACpI,IAAX,CAApB;IACA,KAAKsF,IAAL,GAAY,KAAKhE,IAAL,EAAW8G,SAAS,CAAC9C,IAArB,CAAZ;IACA,KAAKG,GAAL,GAAW,KAAKrD,QAAL,GAAgB,IAAhB,GAAuBgG,SAAS,CAAC3C,GAA5C;IACA,KAAKC,GAAL,GAAW,KAAKtD,QAAL,GAAgB,IAAhB,GAAuBgG,SAAS,CAAC1C,GAA5C;IACA,KAAKC,KAAL,GAAa,KAAKvD,QAAL,GAAgB,IAAhB,GAAuBgG,SAAS,CAACzC,KAA9C;IACA,KAAK0C,KAAL,GAAa,KAAKjG,QAAL,GAAgB,IAAhB,GAAuBgG,SAAS,CAACC,KAA9C;IACA,KAAKnD,IAAL,GAAYkD,SAAS,CAAClD,IAAtB;IACA,KAAK/B,KAAL,GAAa,KAAKD,OAAL,GAAe,IAAf,GAAsBhB,GAAG,CAACiB,KAAJ,IAAaiF,SAAS,CAACjF,KAA1D;IACA,KAAKyC,KAAL,GAAa,KAAKxD,QAAL,GAAgB,IAAhB,GAAuBgG,SAAS,CAACxC,KAA9C;IACA,KAAKC,KAAL,GAAa,KAAKzD,QAAL,GAAgB,IAAhB,GAAuBgG,SAAS,CAACvC,KAA9C;IACA,KAAKL,QAAL,GAAgBvF,QAAQ,CAACmI,SAAS,CAAC5C,QAAX,CAAxB;;IAEA,IAAI,OAAOtD,GAAG,CAAC0B,MAAX,KAAsB,UAA1B,EAAsC;MACpC,KAAKC,EAAL,CAAQ,MAAR,EAAgB3B,GAAG,CAAC0B,MAApB;IACD;;IAED,IAAIE,QAAQ,GAAG,KAAf;;IACA,IAAI,CAAC,KAAKhB,aAAV,EAAyB;MACvB,MAAM,CAACiB,IAAD,EAAOC,QAAP,IAAmBnC,iBAAiB,CAAC,KAAK7B,IAAN,CAA1C;;MACA,IAAI+D,IAAJ,EAAU;QACR,KAAK/D,IAAL,GAAYgE,QAAZ;QACAF,QAAQ,GAAGC,IAAX;MACD;IACF;;IAED,KAAKJ,MAAL,GAAcyE,SAAS,CAAClD,IAAxB;IACA,KAAK5B,WAAL,GAAmB8E,SAAS,CAACE,cAA7B;IAEA,KAAK/C,MAAL,GAAc,IAAIzF,MAAJ,CAAW;MACvBE,IAAI,EAAE,KAAKyB,MAAL,EAAa,KAAKzB,IAAlB,CADiB;MAEvBwF,QAAQ,EAAE,KAAKL,IAAL,KAAc,MAAd,GAAuB,KAAK1D,MAAL,EAAa,KAAK+D,QAAlB,CAAvB,GACR,KAAKA,QAHgB;MAIvB;MACA;MACAF,IAAI,EAAE,KAAKA,IANY;MAOvBG,GAAG,EAAE,KAAKrD,QAAL,GAAgB,IAAhB,GAAuB,KAAKqD,GAPV;MAQvBC,GAAG,EAAE,KAAKtD,QAAL,GAAgB,IAAhB,GAAuB,KAAKsD,GARV;MASvBR,IAAI,EAAE,KAAKA,IATY;MAUvB/B,KAAK,EAAE,KAAKD,OAAL,GAAe,IAAf,GAAsB,KAAKC,KAVX;MAWvBgC,IAAI,EAAE,KAAKA,IAXY;MAYvBQ,KAAK,EAAE,KAAKvD,QAAL,GAAgB,IAAhB,GAAuB,KAAKuD,KAZZ;MAavBC,KAAK,EAAE,KAAKxD,QAAL,GAAgB,IAAhB,GAAuB,KAAKwD,KAbZ;MAcvBC,KAAK,EAAE,KAAKzD,QAAL,GAAgB,IAAhB,GAAuB,KAAKyD;IAdZ,CAAX,CAAd;;IAiBA,IAAI/B,QAAJ,EAAc;MACZ,KAAKQ,IAAL,CAAU,gBAAV,EAA6B,aAAYR,QAAS,qBAAlD,EAAwE;QACtES,KAAK,EAAE,IAD+D;QAEtEvE,IAAI,EAAE8D,QAAQ,GAAG,KAAK9D;MAFgD,CAAxE;IAID;;IAED,IAAI,KAAKuF,MAAL,CAAYO,MAAZ,MAAwB,CAAC,KAAK7C,KAAlC,EAAyC;MACvC,MAAM8C,KAAN,CAAY,IAAIlG,GAAJ,CAAQ;QAClB+F,KAAK,EAAE,KAAKxD,QAAL,GAAgB,IAAhB,GAAuB,KAAKwD,KADjB;QAElBC,KAAK,EAAE,KAAKzD,QAAL,GAAgB,IAAhB,GAAuB,KAAKyD,KAFjB;QAGlBH,GAAG,EAAE,KAAKtD,QAAL,GAAgB,IAAhB,GAAuB,KAAKsD,GAHf;QAIlBvC,KAAK,EAAE,KAAKD,OAAL,GAAe,IAAf,GAAsB,KAAKC,KAJhB;QAKlBnD,IAAI,EAAE,KAAKyB,MAAL,EAAa,KAAKzB,IAAlB,CALY;QAMlBwF,QAAQ,EAAE,KAAKL,IAAL,KAAc,MAAd,GAAuB,KAAK1D,MAAL,EAAa,KAAK+D,QAAlB,CAAvB,GACR,KAAKA,QAPW;QAQlBN,IAAI,EAAE,KAAKA,IARO;QASlBO,GAAG,EAAE,KAAKrD,QAAL,GAAgB,IAAhB,GAAuB,KAAKqD,GATf;QAUlBE,KAAK,EAAE,KAAKvD,QAAL,GAAgB,IAAhB,GAAuB,KAAKuD,KAVjB;QAWlBK,GAAG,EAAE,KAAK5D,QAAL,GAAgB,IAAhB,GAAuB,KAAKgG,SAAL,CAAepC,GAXzB;QAYlBC,GAAG,EAAE,KAAK7D,QAAL,GAAgB,IAAhB,GAAuB,KAAKgG,SAAL,CAAenC,GAZzB;QAalBC,KAAK,EAAE,KAAK9D,QAAL,GAAgB,IAAhB,GAAuB,KAAKgG,SAAL,CAAelC;MAb3B,CAAR,EAcTJ,MAdS,EAAZ;IAeD;;IAED,MAAMC,KAAN,CAAY,KAAKR,MAAL,CAAYY,KAAxB;IACAiC,SAAS,CAACG,IAAV,CAAe,IAAf;EACD;;EAEM,CAAN9G,MAAM,EAAGzB,IAAH,EAAS;IACd,OAAOG,UAAU,CAACH,IAAD,EAAO,KAAKI,MAAZ,CAAjB;EACD;;EAEI,CAAJkB,IAAI,EAAGgE,IAAH,EAAS;IACZ,OAAOxD,OAAO,CAACwD,IAAD,EAAO,KAAKH,IAAL,KAAc,WAArB,EAAkC,KAAK/C,QAAvC,CAAd;EACD;;EAED2D,KAAK,CAAEnB,IAAF,EAAQ;IACX,MAAM4D,QAAQ,GAAG5D,IAAI,CAACnB,MAAtB;;IACA,IAAI+E,QAAQ,GAAG,KAAKlF,WAApB,EAAiC;MAC/B,MAAM,IAAI8D,KAAJ,CAAU,2CAAV,CAAN;IACD;;IACD,KAAK9D,WAAL,IAAoBkF,QAApB;IACA,OAAO,MAAMzC,KAAN,CAAYnB,IAAZ,CAAP;EACD;;EAEDS,GAAG,GAAI;IACL,IAAI,KAAK/B,WAAT,EAAsB;MACpB,MAAMyC,KAAN,CAAYe,MAAM,CAACa,KAAP,CAAa,KAAKrE,WAAlB,CAAZ;IACD;;IACD,OAAO,MAAM+B,GAAN,EAAP;EACD;;AAlH+D,CAAtC,CAA5B;AAqHAtD,UAAU,CAAC0G,IAAX,GAAkBb,cAAlB;AACA7F,UAAU,CAAC2G,GAAX,GAAiBP,aAAjB;;AAEA,MAAM/C,OAAO,GAAGL,IAAI,IAClBA,IAAI,CAACE,MAAL,KAAgB,MAAhB,GACEF,IAAI,CAAC4D,WAAL,KAAqB,WAArB,GACA5D,IAAI,CAAC6D,cAAL,KAAwB,cAAxB,GACA,aAJJ;;AAMAC,MAAM,CAACC,OAAP,GAAiB/G,UAAjB"},"metadata":{},"sourceType":"script"}