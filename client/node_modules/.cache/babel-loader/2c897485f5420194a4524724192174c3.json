{"ast":null,"code":"\"use strict\";\n\nconst moment = require(\"moment\");\n\nconst momentTz = require(\"moment-timezone\");\n\nmodule.exports = BaseTypes => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(void 0, \"https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-D424D23B-0933-425F-BC69-9C0E6724693C\");\n  BaseTypes.DATE.types.oracle = [\"TIMESTAMP\", \"TIMESTAMP WITH LOCAL TIME ZONE\"];\n  BaseTypes.STRING.types.oracle = [\"VARCHAR2\", \"NVARCHAR2\"];\n  BaseTypes.CHAR.types.oracle = [\"CHAR\", \"RAW\"];\n  BaseTypes.TEXT.types.oracle = [\"CLOB\"];\n  BaseTypes.TINYINT.types.oracle = [\"NUMBER\"];\n  BaseTypes.SMALLINT.types.oracle = [\"NUMBER\"];\n  BaseTypes.MEDIUMINT.types.oracle = [\"NUMBER\"];\n  BaseTypes.INTEGER.types.oracle = [\"INTEGER\"];\n  BaseTypes.BIGINT.types.oracle = [\"NUMBER\"];\n  BaseTypes.FLOAT.types.oracle = [\"BINARY_FLOAT\"];\n  BaseTypes.DATEONLY.types.oracle = [\"DATE\"];\n  BaseTypes.BOOLEAN.types.oracle = [\"CHAR(1)\"];\n  BaseTypes.BLOB.types.oracle = [\"BLOB\"];\n  BaseTypes.DECIMAL.types.oracle = [\"NUMBER\"];\n  BaseTypes.UUID.types.oracle = [\"VARCHAR2\"];\n  BaseTypes.ENUM.types.oracle = [\"VARCHAR2\"];\n  BaseTypes.REAL.types.oracle = [\"BINARY_DOUBLE\"];\n  BaseTypes.DOUBLE.types.oracle = [\"BINARY_DOUBLE\"];\n  BaseTypes.JSON.types.oracle = [\"BLOB\"];\n  BaseTypes.GEOMETRY.types.oracle = false;\n\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (this.length > 4e3 || this._binary && this._length > 2e3) {\n        warn(\"Oracle supports length up to 32764 bytes or characters; Be sure that your administrator has extended the MAX_STRING_SIZE parameter. Check https://docs.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-7B72E154-677A-4342-A1EA-C74C1EA928E6\");\n      }\n\n      if (!this._binary) {\n        return `NVARCHAR2(${this._length})`;\n      }\n\n      return `RAW(${this._length})`;\n    }\n\n    _stringify(value, options) {\n      if (this._binary) {\n        return options.escape(value.toString(\"hex\"));\n      }\n\n      return options.escape(value);\n    }\n\n    _getBindDef(oracledb) {\n      if (this._binary) {\n        return {\n          type: oracledb.DB_TYPE_RAW,\n          maxSize: this._length\n        };\n      }\n\n      return {\n        type: oracledb.DB_TYPE_VARCHAR,\n        maxSize: this._length\n      };\n    }\n\n    _bindParam(value, options) {\n      return options.bindParam(value);\n    }\n\n  }\n\n  STRING.prototype.escape = false;\n\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return \"CHAR(1)\";\n    }\n\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_CHAR,\n        maxSize: 1\n      };\n    }\n\n    _stringify(value) {\n      return value === true ? \"1\" : value === false ? \"0\" : value;\n    }\n\n    _sanitize(value) {\n      if (typeof value === \"string\") {\n        return value === \"1\" || value === \"true\" ? true : value === \"0\" || value === \"false\" ? false : value;\n      }\n\n      return super._sanitize(value);\n    }\n\n  }\n\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return \"VARCHAR2(36)\";\n    }\n\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_VARCHAR,\n        maxSize: 36\n      };\n    }\n\n  }\n\n  class NOW extends BaseTypes.NOW {\n    toSql() {\n      return \"SYSDATE\";\n    }\n\n    _stringify() {\n      return \"SYSDATE\";\n    }\n\n  }\n\n  class ENUM extends BaseTypes.ENUM {\n    toSql() {\n      return \"VARCHAR2(512)\";\n    }\n\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_VARCHAR,\n        maxSize: 512\n      };\n    }\n\n  }\n\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      return \"CLOB\";\n    }\n\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_CLOB\n      };\n    }\n\n  }\n\n  class CHAR extends BaseTypes.CHAR {\n    toSql() {\n      if (this._binary) {\n        warn(\"Oracle CHAR.BINARY datatype is not of Fixed Length.\");\n        return `RAW(${this._length})`;\n      }\n\n      return super.toSql();\n    }\n\n    _getBindDef(oracledb) {\n      if (this._binary) {\n        return {\n          type: oracledb.DB_TYPE_RAW,\n          maxSize: this._length\n        };\n      }\n\n      return {\n        type: oracledb.DB_TYPE_CHAR,\n        maxSize: this._length\n      };\n    }\n\n    _bindParam(value, options) {\n      return options.bindParam(value);\n    }\n\n  }\n\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return \"TIMESTAMP WITH LOCAL TIME ZONE\";\n    }\n\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_TIMESTAMP_LTZ\n      };\n    }\n\n    _stringify(date, options) {\n      const format = \"YYYY-MM-DD HH24:MI:SS.FFTZH:TZM\";\n      date = this._applyTimezone(date, options);\n      const formatedDate = date.format(\"YYYY-MM-DD HH:mm:ss.SSS Z\");\n      return `TO_TIMESTAMP_TZ('${formatedDate}','${format}')`;\n    }\n\n    _applyTimezone(date, options) {\n      if (options.timezone) {\n        if (momentTz.tz.zone(options.timezone)) {\n          date = momentTz(date).tz(options.timezone);\n        } else {\n          date = moment(date).utcOffset(options.timezone);\n        }\n      } else {\n        date = momentTz(date);\n      }\n\n      return date;\n    }\n\n    static parse(value, options) {\n      if (value === null) {\n        return value;\n      }\n\n      if (options && moment.tz.zone(options.timezone)) {\n        value = moment.tz(value.toString(), options.timezone).toDate();\n      }\n\n      return value;\n    }\n\n    _bindParam(value, options) {\n      return options.bindParam(value);\n    }\n\n  }\n\n  DATE.prototype.escape = false;\n\n  class DECIMAL extends BaseTypes.DECIMAL {\n    constructor() {\n      super();\n      this.key = \"DECIMAL\";\n    }\n\n    toSql() {\n      let result = \"\";\n\n      if (this._length) {\n        result += `(${this._length}`;\n\n        if (typeof this._decimals === \"number\") {\n          result += `,${this._decimals}`;\n        }\n\n        result += \")\";\n      }\n\n      if (!this._length && this._precision) {\n        result += `(${this._precision}`;\n\n        if (typeof this._scale === \"number\") {\n          result += `,${this._scale}`;\n        }\n\n        result += \")\";\n      }\n\n      return `NUMBER${result}`;\n    }\n\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_NUMBER\n      };\n    }\n\n  }\n\n  class TINYINT extends BaseTypes.TINYINT {\n    toSql() {\n      return \"NUMBER(3)\";\n    }\n\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_NUMBER\n      };\n    }\n\n  }\n\n  class SMALLINT extends BaseTypes.SMALLINT {\n    toSql() {\n      return \"NUMBER(5)\";\n    }\n\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_NUMBER\n      };\n    }\n\n  }\n\n  class MEDIUMINT extends BaseTypes.MEDIUMINT {\n    toSql() {\n      return \"NUMBER(8)\";\n    }\n\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_NUMBER\n      };\n    }\n\n  }\n\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      if (!(this instanceof BIGINT)) return new BIGINT(length);\n      BaseTypes.BIGINT.apply(this, arguments);\n\n      if (this._length || this.options.length || this._unsigned || this._zerofill) {\n        warn(\"Oracle does not support BIGINT with options\");\n        this._length = void 0;\n        this.options.length = void 0;\n        this._unsigned = void 0;\n        this._zerofill = void 0;\n      }\n    }\n\n    toSql() {\n      return \"NUMBER(19)\";\n    }\n\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_NUMBER\n      };\n    }\n\n    _sanitize(value) {\n      if (typeof value === \"bigint\" || typeof value === \"number\") {\n        return value.toString();\n      }\n\n      return value;\n    }\n\n  }\n\n  class NUMBER extends BaseTypes.NUMBER {\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_NUMBER\n      };\n    }\n\n  }\n\n  class INTEGER extends BaseTypes.INTEGER {\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_NUMBER\n      };\n    }\n\n  }\n\n  class FLOAT extends BaseTypes.FLOAT {\n    toSql() {\n      return \"BINARY_FLOAT\";\n    }\n\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_BINARY_FLOAT\n      };\n    }\n\n  }\n\n  class REAL extends BaseTypes.REAL {\n    toSql() {\n      return \"BINARY_DOUBLE\";\n    }\n\n    _stringify(value) {\n      if (value === Number.POSITIVE_INFINITY) {\n        return \"inf\";\n      }\n\n      if (value === Number.NEGATIVE_INFINITY) {\n        return \"-inf\";\n      }\n\n      return value;\n    }\n\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_BINARY_DOUBLE\n      };\n    }\n\n  }\n\n  class BLOB extends BaseTypes.BLOB {\n    _hexify(hex) {\n      return `'${hex}'`;\n    }\n\n    toSql() {\n      return \"BLOB\";\n    }\n\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_BLOB\n      };\n    }\n\n  }\n\n  class JSONTYPE extends BaseTypes.JSON {\n    toSql() {\n      return \"BLOB\";\n    }\n\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_BLOB\n      };\n    }\n\n    _stringify(value, options) {\n      return options.operation === \"where\" && typeof value === \"string\" ? value : JSON.stringify(value);\n    }\n\n    _bindParam(value, options) {\n      return options.bindParam(Buffer.from(JSON.stringify(value)));\n    }\n\n  }\n\n  class DOUBLE extends BaseTypes.DOUBLE {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (!(this instanceof DOUBLE)) return new BaseTypes.DOUBLE(length, decimals);\n      BaseTypes.DOUBLE.apply(this, arguments);\n\n      if (this._length || this._unsigned || this._zerofill) {\n        warn(\"Oracle does not support DOUBLE with options.\");\n        this._length = void 0;\n        this.options.length = void 0;\n        this._unsigned = void 0;\n        this._zerofill = void 0;\n      }\n\n      this.key = \"DOUBLE PRECISION\";\n    }\n\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_BINARY_DOUBLE\n      };\n    }\n\n    toSql() {\n      return \"BINARY_DOUBLE\";\n    }\n\n  }\n\n  class DATEONLY extends BaseTypes.DATEONLY {\n    parse(value) {\n      return moment(value).format(\"YYYY-MM-DD\");\n    }\n\n    _sanitize(value) {\n      if (value) {\n        return moment(value).format(\"YYYY-MM-DD\");\n      }\n\n      return value;\n    }\n\n    _stringify(date, options) {\n      if (date) {\n        const format = \"YYYY/MM/DD\";\n        return options.escape(`TO_DATE('${date}','${format}')`);\n      }\n\n      return options.escape(date);\n    }\n\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_DATE\n      };\n    }\n\n    _bindParam(value, options) {\n      if (typeof value === \"string\") {\n        return options.bindParam(new Date(value));\n      }\n\n      return options.bindParam(value);\n    }\n\n  }\n\n  DATEONLY.prototype.escape = false;\n  return {\n    BOOLEAN,\n    \"DOUBLE PRECISION\": DOUBLE,\n    DOUBLE,\n    STRING,\n    TINYINT,\n    SMALLINT,\n    MEDIUMINT,\n    BIGINT,\n    NUMBER,\n    INTEGER,\n    FLOAT,\n    UUID,\n    DATEONLY,\n    DATE,\n    NOW,\n    BLOB,\n    ENUM,\n    TEXT,\n    CHAR,\n    JSON: JSONTYPE,\n    REAL,\n    DECIMAL\n  };\n};","map":{"version":3,"mappings":"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","names":["moment","require","momentTz","module","exports","BaseTypes","warn","ABSTRACT","bind","DATE","types","oracle","STRING","CHAR","TEXT","TINYINT","SMALLINT","MEDIUMINT","INTEGER","BIGINT","FLOAT","DATEONLY","BOOLEAN","BLOB","DECIMAL","UUID","ENUM","REAL","DOUBLE","JSON","GEOMETRY","toSql","length","_binary","_length","_stringify","value","options","escape","toString","_getBindDef","oracledb","type","DB_TYPE_RAW","maxSize","DB_TYPE_VARCHAR","_bindParam","bindParam","prototype","DB_TYPE_CHAR","_sanitize","NOW","DB_TYPE_CLOB","DB_TYPE_TIMESTAMP_LTZ","date","format","_applyTimezone","formatedDate","timezone","tz","zone","utcOffset","toDate","constructor","key","result","_decimals","_precision","_scale","DB_TYPE_NUMBER","apply","arguments","_unsigned","_zerofill","NUMBER","DB_TYPE_BINARY_FLOAT","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","DB_TYPE_BINARY_DOUBLE","_hexify","hex","DB_TYPE_BLOB","operation","stringify","Buffer","from","decimals","parse","DB_TYPE_DATE","Date","JSONTYPE"],"sources":["/Users/aurele/node_modules/sequelize/src/dialects/oracle/data-types.js"],"sourcesContent":["// Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved\n\n'use strict';\n\nconst moment = require('moment');\nconst momentTz = require('moment-timezone');\n\nmodule.exports = BaseTypes => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(\n    undefined,\n    'https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-D424D23B-0933-425F-BC69-9C0E6724693C'\n  );\n\n  BaseTypes.DATE.types.oracle = ['TIMESTAMP', 'TIMESTAMP WITH LOCAL TIME ZONE'];\n  BaseTypes.STRING.types.oracle = ['VARCHAR2', 'NVARCHAR2'];\n  BaseTypes.CHAR.types.oracle = ['CHAR', 'RAW'];\n  BaseTypes.TEXT.types.oracle = ['CLOB'];\n  BaseTypes.TINYINT.types.oracle = ['NUMBER'];\n  BaseTypes.SMALLINT.types.oracle = ['NUMBER'];\n  BaseTypes.MEDIUMINT.types.oracle = ['NUMBER'];\n  BaseTypes.INTEGER.types.oracle = ['INTEGER'];\n  BaseTypes.BIGINT.types.oracle = ['NUMBER'];\n  BaseTypes.FLOAT.types.oracle = ['BINARY_FLOAT'];\n  BaseTypes.DATEONLY.types.oracle = ['DATE'];\n  BaseTypes.BOOLEAN.types.oracle = ['CHAR(1)'];\n  BaseTypes.BLOB.types.oracle = ['BLOB'];\n  BaseTypes.DECIMAL.types.oracle = ['NUMBER'];\n  BaseTypes.UUID.types.oracle = ['VARCHAR2'];\n  BaseTypes.ENUM.types.oracle = ['VARCHAR2'];\n  BaseTypes.REAL.types.oracle = ['BINARY_DOUBLE'];\n  BaseTypes.DOUBLE.types.oracle = ['BINARY_DOUBLE'];\n  BaseTypes.JSON.types.oracle = ['BLOB'];\n  BaseTypes.GEOMETRY.types.oracle = false;\n\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (this.length > 4000 || this._binary && this._length > 2000) {\n        warn(\n          'Oracle supports length up to 32764 bytes or characters; Be sure that your administrator has extended the MAX_STRING_SIZE parameter. Check https://docs.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-7B72E154-677A-4342-A1EA-C74C1EA928E6'\n        );\n      }\n      if (!this._binary) {\n        return `NVARCHAR2(${this._length})`;\n      }\n      return `RAW(${this._length})`;\n    }\n\n    _stringify(value, options) {\n      if (this._binary) {\n        // For Binary numbers we're converting a buffer to hex then\n        // sending it over the wire as a string,\n        // We pass it through escape function to remove un-necessary quotes\n        // this.format in insert/bulkinsert query calls stringify hence we need to convert binary buffer\n        // to hex string. Since this block is used by both bind (insert/bulkinsert) and\n        // non-bind (select query where clause) hence we need to\n        // have an operation that supports both\n        return options.escape(value.toString('hex'));\n      }\n      return options.escape(value);\n    }\n\n    _getBindDef(oracledb) {\n      if (this._binary) {\n        return { type: oracledb.DB_TYPE_RAW, maxSize: this._length };\n      }\n      return { type: oracledb.DB_TYPE_VARCHAR, maxSize: this._length };\n    }\n\n    _bindParam(value, options) {\n      return options.bindParam(value);\n    }\n  }\n\n  STRING.prototype.escape = false;\n\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return 'CHAR(1)';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_CHAR, maxSize: 1 };\n    }\n\n    _stringify(value) {\n      // If value is true we return '1'\n      // If value is false we return '0'\n      // Else we return it as is\n      // Converting number to char since in bindDef\n      // the type would be oracledb.DB_TYPE_CHAR\n      return value === true ? '1' : value === false ? '0' : value;\n    }\n\n    _sanitize(value) {\n      if (typeof value === 'string') {\n        // If value is a string we return true if among '1' and 'true'\n        // We return false if among '0' and 'false'\n        // Else return the value as is and let the DB raise error for invalid values\n        return value === '1' || value === 'true' ? true : value === '0' || value === 'false' ? false : value;\n      }\n      return super._sanitize(value);\n    }\n  }\n\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return 'VARCHAR2(36)';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_VARCHAR, maxSize: 36 };\n    }\n  }\n\n  class NOW extends BaseTypes.NOW {\n    toSql() {\n      return 'SYSDATE';\n    }\n\n    _stringify() {\n      return 'SYSDATE';\n    }\n  }\n\n  class ENUM extends BaseTypes.ENUM {\n    toSql() {\n      return 'VARCHAR2(512)';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_VARCHAR, maxSize: 512 };\n    }\n  }\n\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      return 'CLOB';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_CLOB };\n    }\n  }\n\n  class CHAR extends BaseTypes.CHAR {\n    toSql() {\n      if (this._binary) {\n        warn('Oracle CHAR.BINARY datatype is not of Fixed Length.');\n        return `RAW(${this._length})`;\n      }\n      return super.toSql();\n    }\n\n    _getBindDef(oracledb) {\n      if (this._binary) {\n        return { type: oracledb.DB_TYPE_RAW, maxSize: this._length };\n      }\n      return { type: oracledb.DB_TYPE_CHAR, maxSize: this._length };\n    }\n\n    _bindParam(value, options) {\n      return options.bindParam(value);\n    }\n  }\n\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return 'TIMESTAMP WITH LOCAL TIME ZONE';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_TIMESTAMP_LTZ };\n    }\n\n    _stringify(date, options) {\n      const format = 'YYYY-MM-DD HH24:MI:SS.FFTZH:TZM';\n\n      date = this._applyTimezone(date, options);\n\n      const formatedDate = date.format('YYYY-MM-DD HH:mm:ss.SSS Z');\n\n      return `TO_TIMESTAMP_TZ('${formatedDate}','${format}')`;\n    }\n\n    _applyTimezone(date, options) {\n      if (options.timezone) {\n        if (momentTz.tz.zone(options.timezone)) {\n          date = momentTz(date).tz(options.timezone);\n        } else {\n          date = moment(date).utcOffset(options.timezone);\n        }\n      } else {\n        date = momentTz(date);\n      }\n      return date;\n    }\n\n    static parse(value, options) {\n      if (value === null) {\n        return value;\n      }\n      if (options && moment.tz.zone(options.timezone)) {\n        value = moment.tz(value.toString(), options.timezone).toDate();\n      }\n      return value;\n    }\n\n    /**\n     * avoids appending TO_TIMESTAMP_TZ in _stringify\n     *\n     * @override\n     */\n    _bindParam(value, options) {\n      return options.bindParam(value);\n    }\n  }\n\n  DATE.prototype.escape = false;\n\n  class DECIMAL extends BaseTypes.DECIMAL {\n    constructor() {\n      super();\n      this.key = 'DECIMAL';\n    }\n\n    toSql() {\n      let result = '';\n      if (this._length) {\n        result += `(${this._length}`;\n        if (typeof this._decimals === 'number') {\n          result += `,${this._decimals}`;\n        }\n        result += ')';\n      }\n\n      if (!this._length && this._precision) {\n        result += `(${this._precision}`;\n        if (typeof this._scale === 'number') {\n          result += `,${this._scale}`;\n        }\n        result += ')';\n      }\n\n      return `NUMBER${result}`;\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n\n  class TINYINT extends BaseTypes.TINYINT {\n    toSql() {\n      return 'NUMBER(3)';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n\n  class SMALLINT extends BaseTypes.SMALLINT {\n    toSql() {\n      return 'NUMBER(5)';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n\n  class MEDIUMINT extends BaseTypes.MEDIUMINT {\n    toSql() {\n      return 'NUMBER(8)';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      if (!(this instanceof BIGINT)) return new BIGINT(length);\n      BaseTypes.BIGINT.apply(this, arguments);\n\n      // ORACLE does not support any options for bigint\n      if (this._length || this.options.length || this._unsigned || this._zerofill) {\n        warn('Oracle does not support BIGINT with options');\n        this._length = undefined;\n        this.options.length = undefined;\n        this._unsigned = undefined;\n        this._zerofill = undefined;\n      }\n    }\n\n    toSql() {\n      return 'NUMBER(19)';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n\n    _sanitize(value) {\n      if (typeof value === 'bigint' || typeof value === 'number') {\n        return value.toString();\n      }\n      return value;\n    }\n\n  }\n\n  class NUMBER extends BaseTypes.NUMBER {\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n\n  class INTEGER extends BaseTypes.INTEGER {\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n\n  class FLOAT extends BaseTypes.FLOAT {\n    toSql() {\n      return 'BINARY_FLOAT';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BINARY_FLOAT };\n    }\n  }\n\n  class REAL extends BaseTypes.REAL {\n    toSql() {\n      return 'BINARY_DOUBLE';\n    }\n\n    // https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-0BA2E065-8006-426C-A3CB-1F6B0C8F283C\n    _stringify(value) {\n      if (value === Number.POSITIVE_INFINITY) {\n        return 'inf';\n      }\n      if (value === Number.NEGATIVE_INFINITY) {\n        return '-inf';\n      }\n      return value;\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BINARY_DOUBLE };\n    }\n  }\n\n  class BLOB extends BaseTypes.BLOB {\n    // Generic hexify returns X'${hex}' but Oracle expects '${hex}' for BLOB datatype\n    _hexify(hex) {\n      return `'${hex}'`;\n    }\n\n    toSql() {\n      return 'BLOB';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BLOB };\n    }\n  }\n\n  class JSONTYPE extends BaseTypes.JSON {\n    toSql() {\n      return 'BLOB';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BLOB };\n    }\n\n    _stringify(value, options) {\n      return options.operation === 'where' && typeof value === 'string' ? value : JSON.stringify(value);\n    }\n\n    _bindParam(value, options) {\n      return options.bindParam(Buffer.from(JSON.stringify(value)));\n    }\n  }\n\n  class DOUBLE extends BaseTypes.DOUBLE {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (!(this instanceof DOUBLE)) return new BaseTypes.DOUBLE(length, decimals);\n      BaseTypes.DOUBLE.apply(this, arguments);\n\n      if (this._length || this._unsigned || this._zerofill) {\n        warn('Oracle does not support DOUBLE with options.');\n        this._length = undefined;\n        this.options.length = undefined;\n        this._unsigned = undefined;\n        this._zerofill = undefined;\n      }\n\n      this.key = 'DOUBLE PRECISION';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BINARY_DOUBLE };\n    }\n\n    toSql() {\n      return 'BINARY_DOUBLE';\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    parse(value) {\n      return moment(value).format('YYYY-MM-DD');\n    }\n\n    _sanitize(value) {\n      if (value) {\n        return moment(value).format('YYYY-MM-DD');\n      }\n      return value;\n    }\n\n    _stringify(date, options) {\n      // If date is not null only then we format the date\n      if (date) {\n        const format = 'YYYY/MM/DD';\n        return options.escape(`TO_DATE('${date}','${format}')`);\n      }\n      return options.escape(date);\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_DATE };\n    }\n\n    /**\n     * avoids appending TO_DATE in _stringify\n     *\n     * @override\n     */\n    _bindParam(value, options) {\n      if (typeof value === 'string') {\n        return options.bindParam(new Date(value));\n      }\n      return options.bindParam(value);\n\n    }\n  }\n\n  DATEONLY.prototype.escape = false;\n\n  return {\n    BOOLEAN,\n    'DOUBLE PRECISION': DOUBLE,\n    DOUBLE,\n    STRING,\n    TINYINT,\n    SMALLINT,\n    MEDIUMINT,\n    BIGINT,\n    NUMBER,\n    INTEGER,\n    FLOAT,\n    UUID,\n    DATEONLY,\n    DATE,\n    NOW,\n    BLOB,\n    ENUM,\n    TEXT,\n    CHAR,\n    JSON: JSONTYPE,\n    REAL,\n    DECIMAL\n  };\n};\n"]},"metadata":{},"sourceType":"script"}