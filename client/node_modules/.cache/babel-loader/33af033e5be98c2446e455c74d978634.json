{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __markAsModule = target => __defProp(target, \"__esModule\", {\n  value: true\n});\n\nvar __export = (target, all) => {\n  __markAsModule(target);\n\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n\n__export(exports, {\n  OracleConnectionManager: () => OracleConnectionManager\n});\n\nconst AbstractConnectionManager = require(\"../abstract/connection-manager\");\n\nconst SequelizeErrors = require(\"../../errors\");\n\nconst parserStore = require(\"../parserStore\")(\"oracle\");\n\nconst {\n  logger\n} = require(\"../../utils/logger\");\n\nconst semver = require(\"semver\");\n\nconst debug = logger.debugContext(\"connection:oracle\");\n\nconst DataTypes = require(\"../../data-types\").oracle;\n\nconst {\n  promisify\n} = require(\"util\");\n\nclass OracleConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n    this.sequelize = sequelize;\n    this.sequelize.config.port = this.sequelize.config.port || 1521;\n    this.lib = this._loadDialectModule(\"oracledb\");\n    this.extendLib();\n    this.refreshTypeParser(DataTypes);\n  }\n\n  extendLib() {\n    if (this.sequelize.config && \"dialectOptions\" in this.sequelize.config) {\n      const dialectOptions = this.sequelize.config.dialectOptions;\n\n      if (dialectOptions && \"maxRows\" in dialectOptions) {\n        this.lib.maxRows = this.sequelize.config.dialectOptions.maxRows;\n      }\n\n      if (dialectOptions && \"fetchAsString\" in dialectOptions) {\n        this.lib.fetchAsString = this.sequelize.config.dialectOptions.fetchAsString;\n      } else {\n        this.lib.fetchAsString = [this.lib.CLOB];\n      }\n    }\n\n    this.lib.fetchAsBuffer = [this.lib.BLOB];\n  }\n\n  buildConnectString(config) {\n    if (!config.host || config.host.length === 0) return config.database;\n    let connectString = config.host;\n\n    if (config.port && config.port > 0) {\n      connectString += `:${config.port}`;\n    } else {\n      connectString += \":1521\";\n    }\n\n    if (config.database && config.database.length > 0) {\n      connectString += `/${config.database}`;\n    }\n\n    return connectString;\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  async connect(config) {\n    const connectionConfig = __spreadValues({\n      user: config.username,\n      password: config.password,\n      externalAuth: config.externalAuth,\n      stmtCacheSize: 0,\n      connectString: this.buildConnectString(config)\n    }, config.dialectOptions);\n\n    try {\n      const connection = await this.lib.getConnection(connectionConfig);\n      this.sequelize.options.databaseVersion = semver.coerce(connection.oracleServerVersionString).version;\n      debug(\"connection acquired\");\n      connection.on(\"error\", error => {\n        switch (error.code) {\n          case \"ESOCKET\":\n          case \"ECONNRESET\":\n          case \"EPIPE\":\n          case \"PROTOCOL_CONNECTION_LOST\":\n            this.pool.destroy(connection);\n        }\n      });\n      return connection;\n    } catch (err) {\n      let errorCode = err.message.split(\":\");\n      errorCode = errorCode[0];\n\n      switch (errorCode) {\n        case \"ORA-12560\":\n        case \"ORA-12154\":\n        case \"ORA-12505\":\n        case \"ORA-12514\":\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n\n        case \"ORA-28000\":\n        case \"ORA-28040\":\n        case \"ORA-01017\":\n          throw new SequelizeErrors.AccessDeniedError(err);\n\n        case \"ORA-12541\":\n          throw new SequelizeErrors.HostNotReachableError(err);\n\n        case \"ORA-12170\":\n          throw new SequelizeErrors.ConnectionTimedOutError(err);\n\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n\n  async disconnect(connection) {\n    if (!connection.isHealthy()) {\n      debug(\"connection tried to disconnect but was already at CLOSED state\");\n      return;\n    }\n\n    return await promisify(callback => connection.close(callback))();\n  }\n\n  validate(connection) {\n    return connection && connection.isHealthy();\n  }\n\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAAA;EAAAC;AAAA;;AAIA,MAAMC,4BAA4BC,QAAQ,gCAAR,CAAlC;;AACA,MAAMC,kBAAkBD,QAAQ,cAAR,CAAxB;;AACA,MAAME,cAAcF,QAAQ,gBAAR,EAA0B,QAA1B,CAApB;;AACA,MAAM;EAAEG;AAAF,IAAaH,QAAQ,oBAAR,CAAnB;;AACA,MAAMI,SAASJ,QAAQ,QAAR,CAAf;;AACA,MAAMK,QAAQF,OAAOG,YAAP,CAAoB,mBAApB,CAAd;;AACA,MAAMC,YAAYP,QAAQ,kBAAR,EAA4BQ,MAA9C;;AACA,MAAM;EAAEC;AAAF,IAAgBT,QAAQ,MAAR,CAAtB;;AAUO,sCAAsCD,yBAAtC,CAAgE;EACrEW,YAAYC,OAAZ,EAAqBC,SAArB,EAAgC;IAC9B,MAAMD,OAAN,EAAeC,SAAf;IAEA,KAAKA,SAAL,GAAiBA,SAAjB;IACA,KAAKA,SAAL,CAAeC,MAAf,CAAsBC,IAAtB,GAA6B,KAAKF,SAAL,CAAeC,MAAf,CAAsBC,IAAtB,IAA8B,IAA3D;IACA,KAAKC,GAAL,GAAW,KAAKC,kBAAL,CAAwB,UAAxB,CAAX;IACA,KAAKC,SAAL;IACA,KAAKC,iBAAL,CAAuBX,SAAvB;EAAuB;;EAOzBU,YAAY;IACV,IAAI,KAAKL,SAAL,CAAeC,MAAf,IAAyB,oBAAoB,KAAKD,SAAL,CAAeC,MAAhE,EAAwE;MACtE,MAAMM,iBAAiB,KAAKP,SAAL,CAAeC,MAAf,CAAsBM,cAA7C;;MACA,IAAIA,kBAAkB,aAAaA,cAAnC,EAAmD;QACjD,KAAKJ,GAAL,CAASK,OAAT,GAAmB,KAAKR,SAAL,CAAeC,MAAf,CAAsBM,cAAtB,CAAqCC,OAAxD;MAAwD;;MAE1D,IAAID,kBAAkB,mBAAmBA,cAAzC,EAAyD;QACvD,KAAKJ,GAAL,CAASM,aAAT,GAAyB,KAAKT,SAAL,CAAeC,MAAf,CAAsBM,cAAtB,CAAqCE,aAA9D;MAA8D,CADhE,MAEO;QACL,KAAKN,GAAL,CAASM,aAAT,GAAyB,CAAC,KAAKN,GAAL,CAASO,IAAV,CAAzB;MAAmC;IAAA;;IAIvC,KAAKP,GAAL,CAASQ,aAAT,GAAyB,CAAC,KAAKR,GAAL,CAASS,IAAV,CAAzB;EAAmC;;EAWrCC,mBAAmBZ,MAAnB,EAA2B;IACzB,IAAI,CAACA,OAAOa,IAAR,IAAgBb,OAAOa,IAAP,CAAYC,MAAZ,KAAuB,CAA3C,EACE,OAAOd,OAAOe,QAAd;IACF,IAAIC,gBAAgBhB,OAAOa,IAA3B;;IACA,IAAIb,OAAOC,IAAP,IAAeD,OAAOC,IAAP,GAAc,CAAjC,EAAoC;MAClCe,iBAAiB,IAAIhB,OAAOC,MAA5B;IAA4B,CAD9B,MAEO;MACLe,iBAAiB,OAAjB;IAAiB;;IAEnB,IAAIhB,OAAOe,QAAP,IAAmBf,OAAOe,QAAP,CAAgBD,MAAhB,GAAyB,CAAhD,EAAmD;MACjDE,iBAAiB,IAAIhB,OAAOe,UAA5B;IAA4B;;IAE9B,OAAOC,aAAP;EAAO;;EAITC,mBAAmBC,QAAnB,EAA6B;IAC3B7B,YAAY8B,OAAZ,CAAoBD,QAApB;EAAoB;;EAGtBE,mBAAmB;IACjB/B,YAAYgC,KAAZ;EAAY;;EAYR,cAAQrB,MAAR,EAAgB;IACpB,MAAMsB,mBAAmBC;MACvBC,MAAMxB,OAAOyB,QADU;MAEvBC,UAAU1B,OAAO0B,QAFM;MAGvBC,cAAc3B,OAAO2B,YAHE;MAIvBC,eAAe,CAJQ;MAKvBZ,eAAe,KAAKJ,kBAAL,CAAwBZ,MAAxB;IALQ,GAMpBA,OAAOM,cANa,CAAzB;;IASA,IAAI;MACF,MAAMuB,aAAa,MAAM,KAAK3B,GAAL,CAAS4B,aAAT,CAAuBR,gBAAvB,CAAzB;MAEA,KAAKvB,SAAL,CAAegC,OAAf,CAAuBC,eAAvB,GAAyCzC,OAAO0C,MAAP,CAAcJ,WAAWK,yBAAzB,EAAoDC,OAA7F;MAEA3C,MAAM,qBAAN;MACAqC,WAAWO,EAAX,CAAc,OAAd,EAAuBC,SAAS;QAC9B,QAAQA,MAAMC,IAAd;UAAc,KACP,SADO;UACP,KACA,YADA;UACA,KACA,OADA;UACA,KACA,0BADA;YAEH,KAAKC,IAAL,CAAUC,OAAV,CAAkBX,UAAlB;QALJ;MAKsB,CANxB;MAUA,OAAOA,UAAP;IAAO,CAhBT,CAgBS,OACAY,GADA,EACP;MAEA,IAAIC,YAAYD,IAAIE,OAAJ,CAAYC,KAAZ,CAAkB,GAAlB,CAAhB;MACAF,YAAYA,UAAU,CAAV,CAAZ;;MAEA,QAAQA,SAAR;QAAQ,KACD,WADC;QACD,KACA,WADA;QACA,KACA,WADA;QACA,KACA,WADA;UAEH,MAAM,IAAItD,gBAAgByD,sBAApB,CAA2CJ,GAA3C,CAAN;;QAAiD,KAC9C,WAD8C;QAC9C,KACA,WADA;QACA,KACA,WADA;UAEH,MAAM,IAAIrD,gBAAgB0D,iBAApB,CAAsCL,GAAtC,CAAN;;QAA4C,KACzC,WADyC;UAE5C,MAAM,IAAIrD,gBAAgB2D,qBAApB,CAA0CN,GAA1C,CAAN;;QAAgD,KAC7C,WAD6C;UAEhD,MAAM,IAAIrD,gBAAgB4D,uBAApB,CAA4CP,GAA5C,CAAN;;QAAkD;UAElD,MAAM,IAAIrD,gBAAgB6D,eAApB,CAAoCR,GAApC,CAAN;MAfJ;IAe8C;EAAA;;EAK5C,iBAAWZ,UAAX,EAAuB;IAC3B,IAAI,CAACA,WAAWqB,SAAX,EAAL,EAA6B;MAC3B1D,MAAM,gEAAN;MACA;IAAA;;IAGF,OAAO,MAAMI,UAAUuD,YAAYtB,WAAWuB,KAAX,CAAiBD,QAAjB,CAAtB,GAAb;EAAoD;;EAStDE,SAASxB,UAAT,EAAqB;IACnB,OAAOA,cAAcA,WAAWqB,SAAX,EAArB;EAAgC;;AA5ImC","names":["__export","OracleConnectionManager","AbstractConnectionManager","require","SequelizeErrors","parserStore","logger","semver","debug","debugContext","DataTypes","oracle","promisify","constructor","dialect","sequelize","config","port","lib","_loadDialectModule","extendLib","refreshTypeParser","dialectOptions","maxRows","fetchAsString","CLOB","fetchAsBuffer","BLOB","buildConnectString","host","length","database","connectString","_refreshTypeParser","dataType","refresh","_clearTypeParser","clear","connectionConfig","__spreadValues","user","username","password","externalAuth","stmtCacheSize","connection","getConnection","options","databaseVersion","coerce","oracleServerVersionString","version","on","error","code","pool","destroy","err","errorCode","message","split","ConnectionRefusedError","AccessDeniedError","HostNotReachableError","ConnectionTimedOutError","ConnectionError","isHealthy","callback","close","validate"],"sources":["/Users/aurele/node_modules/sequelize/src/dialects/oracle/connection-manager.js"],"sourcesContent":["// Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved\n\n'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst SequelizeErrors = require('../../errors');\nconst parserStore = require('../parserStore')('oracle');\nconst { logger } = require('../../utils/logger');\nconst semver = require('semver');\nconst debug = logger.debugContext('connection:oracle');\nconst DataTypes = require('../../data-types').oracle;\nconst { promisify } = require('util');\n/**\n * Oracle Connection Manager\n *\n * Get connections, validate and disconnect them.\n * AbstractConnectionManager pooling use it to handle Oracle specific connections\n * Use github.com/oracle/node-oracledb to connect with Oracle server\n *\n * @private\n */\nexport class OracleConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n\n    this.sequelize = sequelize;\n    this.sequelize.config.port = this.sequelize.config.port || 1521;\n    this.lib = this._loadDialectModule('oracledb');\n    this.extendLib();\n    this.refreshTypeParser(DataTypes);\n  }\n\n  /**\n   * Method for initializing the lib\n   *\n   */\n  extendLib() {\n    if (this.sequelize.config && 'dialectOptions' in this.sequelize.config) {\n      const dialectOptions = this.sequelize.config.dialectOptions;\n      if (dialectOptions && 'maxRows' in dialectOptions) {\n        this.lib.maxRows = this.sequelize.config.dialectOptions.maxRows;\n      }\n      if (dialectOptions && 'fetchAsString' in dialectOptions) {\n        this.lib.fetchAsString = this.sequelize.config.dialectOptions.fetchAsString;\n      } else {\n        this.lib.fetchAsString = [this.lib.CLOB];\n      }\n    }\n    // Retrieve BLOB always as Buffer.\n    this.lib.fetchAsBuffer = [this.lib.BLOB];\n  }\n\n  /**\n   * Method for checking the config object passed and generate the full database if not fully passed\n   * With dbName, host and port, it generates a string like this : 'host:port/dbname'\n   *\n   * @param {object} config\n   * @returns {Promise<Connection>}\n   * @private\n   */\n  buildConnectString(config) {\n    if (!config.host || config.host.length === 0)\n      return config.database;\n    let connectString = config.host;\n    if (config.port && config.port > 0) {\n      connectString += `:${config.port}`;\n    } else {\n      connectString += ':1521';\n    }\n    if (config.database && config.database.length > 0) {\n      connectString += `/${config.database}`;\n    }\n    return connectString;\n  }\n\n  // Expose this as a method so that the parsing may be updated when the user has added additional, custom types\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  /**\n   * Connect with Oracle database based on config, Handle any errors in connection\n   * Set the pool handlers on connection.error\n   * Also set proper timezone once connection is connected.\n   *\n   * @param {object} config\n   * @returns {Promise<Connection>}\n   * @private\n   */\n  async connect(config) {\n    const connectionConfig = {\n      user: config.username,\n      password: config.password,\n      externalAuth: config.externalAuth,\n      stmtCacheSize: 0,\n      connectString: this.buildConnectString(config),\n      ...config.dialectOptions\n    };\n\n    try {\n      const connection = await this.lib.getConnection(connectionConfig);\n      // Setting the sequelize database version to Oracle DB server version to remove the roundtrip for DB version query\n      this.sequelize.options.databaseVersion = semver.coerce(connection.oracleServerVersionString).version;\n\n      debug('connection acquired');\n      connection.on('error', error => {\n        switch (error.code) {\n          case 'ESOCKET':\n          case 'ECONNRESET':\n          case 'EPIPE':\n          case 'PROTOCOL_CONNECTION_LOST':\n            this.pool.destroy(connection);\n        }\n      });\n\n      return connection;\n    } catch (err) {\n      // We split to get the error number; it comes as ORA-XXXXX:\n      let errorCode = err.message.split(':');\n      errorCode = errorCode[0];\n\n      switch (errorCode) {\n        case 'ORA-12560': // ORA-12560: TNS: Protocol Adapter Error\n        case 'ORA-12154': // ORA-12154: TNS: Could not resolve the connect identifier specified\n        case 'ORA-12505': // ORA-12505: TNS: Listener does not currently know of SID given in connect descriptor\n        case 'ORA-12514': // ORA-12514: TNS: Listener does not currently know of service requested in connect descriptor\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n        case 'ORA-28000': // ORA-28000: Account locked\n        case 'ORA-28040': // ORA-28040: No matching authentication protocol\n        case 'ORA-01017': // ORA-01017: invalid username/password; logon denied\n          throw new SequelizeErrors.AccessDeniedError(err);\n        case 'ORA-12541': // ORA-12541: TNS: No listener\n          throw new SequelizeErrors.HostNotReachableError(err);\n        case 'ORA-12170': // ORA-12170: TNS: Connect Timeout occurred\n          throw new SequelizeErrors.ConnectionTimedOutError(err);\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n\n  async disconnect(connection) {\n    if (!connection.isHealthy()) {\n      debug('connection tried to disconnect but was already at CLOSED state');\n      return;\n    }\n\n    return await promisify(callback => connection.close(callback))();\n  }\n\n  /**\n   * Checking if the connection object is valid and the connection is healthy\n   *\n   * @param {object} connection\n   * @private\n   */\n  validate(connection) {\n    return connection && connection.isHealthy();\n  }\n}\n"]},"metadata":{},"sourceType":"script"}