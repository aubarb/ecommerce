{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\n\nconst HasOne = require(\"./has-one\");\n\nconst HasMany = require(\"./has-many\");\n\nconst BelongsToMany = require(\"./belongs-to-many\");\n\nconst BelongsTo = require(\"./belongs-to\");\n\nfunction isModel(model, sequelize) {\n  return model && model.prototype && model.prototype instanceof sequelize.Sequelize.Model;\n}\n\nconst Mixin = {\n  hasMany(target) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!isModel(target, this.sequelize)) {\n      throw new Error(`${this.name}.hasMany called with something that's not a subclass of Sequelize.Model`);\n    }\n\n    const source = this;\n    options.hooks = options.hooks === void 0 ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n    Object.assign(options, _.omit(source.options, [\"hooks\"]));\n\n    if (options.useHooks) {\n      this.runHooks(\"beforeAssociate\", {\n        source,\n        target,\n        type: HasMany\n      }, options);\n    }\n\n    const association = new HasMany(source, target, options);\n    source.associations[association.associationAccessor] = association;\n\n    association._injectAttributes();\n\n    association.mixin(source.prototype);\n\n    if (options.useHooks) {\n      this.runHooks(\"afterAssociate\", {\n        source,\n        target,\n        type: HasMany,\n        association\n      }, options);\n    }\n\n    return association;\n  },\n\n  belongsToMany(target) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!isModel(target, this.sequelize)) {\n      throw new Error(`${this.name}.belongsToMany called with something that's not a subclass of Sequelize.Model`);\n    }\n\n    const source = this;\n    options.hooks = options.hooks === void 0 ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n    options.timestamps = options.timestamps === void 0 ? this.sequelize.options.timestamps : options.timestamps;\n    Object.assign(options, _.omit(source.options, [\"hooks\", \"timestamps\", \"scopes\", \"defaultScope\"]));\n\n    if (options.useHooks) {\n      this.runHooks(\"beforeAssociate\", {\n        source,\n        target,\n        type: BelongsToMany\n      }, options);\n    }\n\n    const association = new BelongsToMany(source, target, options);\n    source.associations[association.associationAccessor] = association;\n\n    association._injectAttributes();\n\n    association.mixin(source.prototype);\n\n    if (options.useHooks) {\n      this.runHooks(\"afterAssociate\", {\n        source,\n        target,\n        type: BelongsToMany,\n        association\n      }, options);\n    }\n\n    return association;\n  },\n\n  getAssociations(target) {\n    return Object.values(this.associations).filter(association => association.target.name === target.name);\n  },\n\n  getAssociationForAlias(target, alias) {\n    return this.getAssociations(target).find(association => association.verifyAssociationAlias(alias)) || null;\n  }\n\n};\n\nfunction singleLinked(Type) {\n  return function (target) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const source = this;\n\n    if (!isModel(target, source.sequelize)) {\n      throw new Error(`${source.name}.${_.lowerFirst(Type.name)} called with something that's not a subclass of Sequelize.Model`);\n    }\n\n    options.hooks = options.hooks === void 0 ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n\n    if (options.useHooks) {\n      source.runHooks(\"beforeAssociate\", {\n        source,\n        target,\n        type: Type\n      }, options);\n    }\n\n    const association = new Type(source, target, Object.assign(options, source.options));\n    source.associations[association.associationAccessor] = association;\n\n    association._injectAttributes();\n\n    association.mixin(source.prototype);\n\n    if (options.useHooks) {\n      source.runHooks(\"afterAssociate\", {\n        source,\n        target,\n        type: Type,\n        association\n      }, options);\n    }\n\n    return association;\n  };\n}\n\nMixin.hasOne = singleLinked(HasOne);\nMixin.belongsTo = singleLinked(BelongsTo);\nmodule.exports = Mixin;\nmodule.exports.Mixin = Mixin;\nmodule.exports.default = Mixin;","map":{"version":3,"mappings":"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","names":["_","require","HasOne","HasMany","BelongsToMany","BelongsTo","model","sequelize","prototype","Sequelize","Model","Mixin","hasMany","target","options","isModel","Error","name","source","hooks","Boolean","useHooks","Object","assign","omit","runHooks","type","association","associations","associationAccessor","_injectAttributes","mixin","belongsToMany","timestamps","getAssociations","values","filter","getAssociationForAlias","alias","find","verifyAssociationAlias","Type","lowerFirst","hasOne","singleLinked","belongsTo","module","exports","default"],"sources":["/Users/aurele/node_modules/sequelize/src/associations/mixin.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst HasOne = require('./has-one');\nconst HasMany = require('./has-many');\nconst BelongsToMany = require('./belongs-to-many');\nconst BelongsTo = require('./belongs-to');\n\nfunction isModel(model, sequelize) {\n  return model\n    && model.prototype\n    && model.prototype instanceof sequelize.Sequelize.Model;\n}\n\nconst Mixin = {\n  hasMany(target, options = {}) {\n    if (!isModel(target, this.sequelize)) {\n      throw new Error(`${this.name}.hasMany called with something that's not a subclass of Sequelize.Model`);\n    }\n\n    const source = this;\n\n    // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n\n    Object.assign(options, _.omit(source.options, ['hooks']));\n\n    if (options.useHooks) {\n      this.runHooks('beforeAssociate', { source, target, type: HasMany }, options);\n    }\n\n    // the id is in the foreign table or in a connecting table\n    const association = new HasMany(source, target, options);\n    source.associations[association.associationAccessor] = association;\n\n    association._injectAttributes();\n    association.mixin(source.prototype);\n\n    if (options.useHooks) {\n      this.runHooks('afterAssociate', { source, target, type: HasMany, association }, options);\n    }\n\n    return association;\n  },\n\n  belongsToMany(target, options = {}) {\n    if (!isModel(target, this.sequelize)) {\n      throw new Error(`${this.name}.belongsToMany called with something that's not a subclass of Sequelize.Model`);\n    }\n\n    const source = this;\n\n    // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n    options.timestamps = options.timestamps === undefined ? this.sequelize.options.timestamps : options.timestamps;\n    Object.assign(options, _.omit(source.options, ['hooks', 'timestamps', 'scopes', 'defaultScope']));\n\n    if (options.useHooks) {\n      this.runHooks('beforeAssociate', { source, target, type: BelongsToMany }, options);\n    }\n    // the id is in the foreign table or in a connecting table\n    const association = new BelongsToMany(source, target, options);\n    source.associations[association.associationAccessor] = association;\n\n    association._injectAttributes();\n    association.mixin(source.prototype);\n\n    if (options.useHooks) {\n      this.runHooks('afterAssociate', { source, target, type: BelongsToMany, association }, options);\n    }\n\n    return association;\n  },\n\n  getAssociations(target) {\n    return Object.values(this.associations).filter(association => association.target.name === target.name);\n  },\n\n  getAssociationForAlias(target, alias) {\n    // Two associations cannot have the same alias, so we can use find instead of filter\n    return this.getAssociations(target).find(association => association.verifyAssociationAlias(alias)) || null;\n  }\n};\n\n// The logic for hasOne and belongsTo is exactly the same\nfunction singleLinked(Type) {\n  return function(target, options = {}) {\n    // eslint-disable-next-line no-invalid-this\n    const source = this;\n    if (!isModel(target, source.sequelize)) {\n      throw new Error(`${source.name}.${_.lowerFirst(Type.name)} called with something that's not a subclass of Sequelize.Model`);\n    }\n\n\n    // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n\n    if (options.useHooks) {\n      source.runHooks('beforeAssociate', { source, target, type: Type }, options);\n    }\n    // the id is in the foreign table\n    const association = new Type(source, target, Object.assign(options, source.options));\n    source.associations[association.associationAccessor] = association;\n\n    association._injectAttributes();\n    association.mixin(source.prototype);\n\n    if (options.useHooks) {\n      source.runHooks('afterAssociate', { source, target, type: Type, association }, options);\n    }\n\n    return association;\n  };\n}\n\nMixin.hasOne = singleLinked(HasOne);\nMixin.belongsTo = singleLinked(BelongsTo);\n\nmodule.exports = Mixin;\nmodule.exports.Mixin = Mixin;\nmodule.exports.default = Mixin;\n"]},"metadata":{},"sourceType":"script"}