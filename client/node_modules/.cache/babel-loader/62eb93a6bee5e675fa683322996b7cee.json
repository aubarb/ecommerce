{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\n\nconst Utils = require(\"../../utils\");\n\nconst AbstractQuery = require(\"../abstract/query\");\n\nconst QueryTypes = require(\"../../query-types\");\n\nconst sequelizeErrors = require(\"../../errors\");\n\nconst parserStore = require(\"../parserStore\")(\"sqlite\");\n\nconst {\n  logger\n} = require(\"../../utils/logger\");\n\nconst debug = logger.debugContext(\"sql:sqlite\");\n\nfunction stringifyIfBigint(value) {\n  if (typeof value === \"bigint\") {\n    return value.toString();\n  }\n\n  return value;\n}\n\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return \"lastID\";\n  }\n\n  static formatBindParameters(sql, values, dialect) {\n    let bindParam;\n\n    if (Array.isArray(values)) {\n      bindParam = {};\n      values.forEach((v, i) => {\n        bindParam[`$${i + 1}`] = v;\n      });\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, {\n        skipValueReplace: true\n      })[0];\n    } else {\n      bindParam = {};\n\n      if (typeof values === \"object\") {\n        for (const k of Object.keys(values)) {\n          bindParam[`$${k}`] = values[k];\n        }\n      }\n\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, {\n        skipValueReplace: true\n      })[0];\n    }\n\n    return [sql, bindParam];\n  }\n\n  _collectModels(include, prefix) {\n    const ret = {};\n\n    if (include) {\n      for (const _include of include) {\n        let key;\n\n        if (!prefix) {\n          key = _include.as;\n        } else {\n          key = `${prefix}.${_include.as}`;\n        }\n\n        ret[key] = _include.model;\n\n        if (_include.include) {\n          _.merge(ret, this._collectModels(_include.include, key));\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  _handleQueryResponse(metaData, columnTypes, err, results, errStack) {\n    if (err) {\n      err.sql = this.sql;\n      throw this.formatError(err, errStack);\n    }\n\n    let result = this.instance;\n\n    if (this.isInsertQuery(results, metaData) || this.isUpsertQuery()) {\n      this.handleInsertQuery(results, metaData);\n\n      if (!this.instance) {\n        if (metaData.constructor.name === \"Statement\" && this.model && this.model.autoIncrementAttribute && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute && this.model.rawAttributes[this.model.primaryKeyAttribute]) {\n          const startId = metaData[this.getInsertIdField()] - metaData.changes + 1;\n          result = [];\n\n          for (let i = startId; i < startId + metaData.changes; i++) {\n            result.push({\n              [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i\n            });\n          }\n        } else {\n          result = metaData[this.getInsertIdField()];\n        }\n      }\n    }\n\n    if (this.isShowTablesQuery()) {\n      return results.map(row => row.name);\n    }\n\n    if (this.isShowConstraintsQuery()) {\n      result = results;\n\n      if (results && results[0] && results[0].sql) {\n        result = this.parseConstraintsFromSql(results[0].sql);\n      }\n\n      return result;\n    }\n\n    if (this.isSelectQuery()) {\n      if (this.options.raw) {\n        return this.handleSelectQuery(results);\n      }\n\n      const prefixes = this._collectModels(this.options.include);\n\n      results = results.map(result2 => {\n        return _.mapValues(result2, (value, name) => {\n          let model;\n\n          if (name.includes(\".\")) {\n            const lastind = name.lastIndexOf(\".\");\n            model = prefixes[name.substr(0, lastind)];\n            name = name.substr(lastind + 1);\n          } else {\n            model = this.options.model;\n          }\n\n          const tableName = model.getTableName().toString().replace(/`/g, \"\");\n          const tableTypes = columnTypes[tableName] || {};\n\n          if (tableTypes && !(name in tableTypes)) {\n            _.forOwn(model.rawAttributes, (attribute, key) => {\n              if (name === key && attribute.field) {\n                name = attribute.field;\n                return false;\n              }\n            });\n          }\n\n          return Object.prototype.hasOwnProperty.call(tableTypes, name) ? this.applyParsers(tableTypes[name], value) : value;\n        });\n      });\n      return this.handleSelectQuery(results);\n    }\n\n    if (this.isShowOrDescribeQuery()) {\n      return results;\n    }\n\n    if (this.sql.includes(\"PRAGMA INDEX_LIST\")) {\n      return this.handleShowIndexesQuery(results);\n    }\n\n    if (this.sql.includes(\"PRAGMA INDEX_INFO\")) {\n      return results;\n    }\n\n    if (this.sql.includes(\"PRAGMA TABLE_INFO\")) {\n      result = {};\n      let defaultValue;\n\n      for (const _result of results) {\n        if (_result.dflt_value === null) {\n          defaultValue = void 0;\n        } else if (_result.dflt_value === \"NULL\") {\n          defaultValue = null;\n        } else {\n          defaultValue = _result.dflt_value;\n        }\n\n        result[_result.name] = {\n          type: _result.type,\n          allowNull: _result.notnull === 0,\n          defaultValue,\n          primaryKey: _result.pk !== 0\n        };\n\n        if (result[_result.name].type === \"TINYINT(1)\") {\n          result[_result.name].defaultValue = {\n            \"0\": false,\n            \"1\": true\n          }[result[_result.name].defaultValue];\n        }\n\n        if (typeof result[_result.name].defaultValue === \"string\") {\n          result[_result.name].defaultValue = result[_result.name].defaultValue.replace(/'/g, \"\");\n        }\n      }\n\n      return result;\n    }\n\n    if (this.sql.includes(\"PRAGMA foreign_keys;\")) {\n      return results[0];\n    }\n\n    if (this.sql.includes(\"PRAGMA foreign_keys\")) {\n      return results;\n    }\n\n    if (this.sql.includes(\"PRAGMA foreign_key_list\")) {\n      return results;\n    }\n\n    if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].includes(this.options.type)) {\n      return metaData.changes;\n    }\n\n    if (this.options.type === QueryTypes.VERSION) {\n      return results[0].version;\n    }\n\n    if (this.options.type === QueryTypes.RAW) {\n      return [results, metaData];\n    }\n\n    if (this.isUpsertQuery()) {\n      return [result, null];\n    }\n\n    if (this.isUpdateQuery() || this.isInsertQuery()) {\n      return [result, metaData.changes];\n    }\n\n    return result;\n  }\n\n  async run(sql, parameters) {\n    const conn = this.connection;\n    this.sql = sql;\n    const method = this.getDatabaseMethod();\n\n    const complete = this._logQuery(sql, debug, parameters);\n\n    return new Promise((resolve, reject) => conn.serialize(async () => {\n      const columnTypes = {};\n      const errForStack = new Error();\n\n      const executeSql = () => {\n        if (sql.startsWith(\"-- \")) {\n          return resolve();\n        }\n\n        const query = this;\n\n        function afterExecute(executionError, results) {\n          try {\n            complete();\n            resolve(query._handleQueryResponse(this, columnTypes, executionError, results, errForStack.stack));\n            return;\n          } catch (error) {\n            reject(error);\n          }\n        }\n\n        if (!parameters) parameters = [];\n\n        if (_.isPlainObject(parameters)) {\n          const newParameters = Object.create(null);\n\n          for (const key of Object.keys(parameters)) {\n            newParameters[`${key}`] = stringifyIfBigint(parameters[key]);\n          }\n\n          parameters = newParameters;\n        } else {\n          parameters = parameters.map(stringifyIfBigint);\n        }\n\n        conn[method](sql, parameters, afterExecute);\n        return null;\n      };\n\n      if (this.getDatabaseMethod() === \"all\") {\n        let tableNames = [];\n\n        if (this.options && this.options.tableNames) {\n          tableNames = this.options.tableNames;\n        } else if (/FROM `(.*?)`/i.exec(this.sql)) {\n          tableNames.push(/FROM `(.*?)`/i.exec(this.sql)[1]);\n        }\n\n        tableNames = tableNames.filter(tableName => !(tableName in columnTypes) && tableName !== \"sqlite_master\");\n\n        if (!tableNames.length) {\n          return executeSql();\n        }\n\n        await Promise.all(tableNames.map(tableName => new Promise(resolve2 => {\n          tableName = tableName.replace(/`/g, \"\");\n          columnTypes[tableName] = {};\n          conn.all(`PRAGMA table_info(\\`${tableName}\\`)`, (err, results) => {\n            if (!err) {\n              for (const result of results) {\n                columnTypes[tableName][result.name] = result.type;\n              }\n            }\n\n            resolve2();\n          });\n        })));\n      }\n\n      return executeSql();\n    }));\n  }\n\n  parseConstraintsFromSql(sql) {\n    let constraints = sql.split(\"CONSTRAINT \");\n    let referenceTableName, referenceTableKeys, updateAction, deleteAction;\n    constraints.splice(0, 1);\n    constraints = constraints.map(constraintSql => {\n      if (constraintSql.includes(\"REFERENCES\")) {\n        updateAction = constraintSql.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n        deleteAction = constraintSql.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n\n        if (updateAction) {\n          updateAction = updateAction[1];\n        }\n\n        if (deleteAction) {\n          deleteAction = deleteAction[1];\n        }\n\n        const referencesRegex = /REFERENCES.+\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/;\n        const referenceConditions = constraintSql.match(referencesRegex)[0].split(\" \");\n        referenceTableName = Utils.removeTicks(referenceConditions[1]);\n        let columnNames = referenceConditions[2];\n        columnNames = columnNames.replace(/\\(|\\)/g, \"\").split(\", \");\n        referenceTableKeys = columnNames.map(column => Utils.removeTicks(column));\n      }\n\n      const constraintCondition = constraintSql.match(/\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/)[0];\n      constraintSql = constraintSql.replace(/\\(.+\\)/, \"\");\n      const constraint = constraintSql.split(\" \");\n\n      if ([\"PRIMARY\", \"FOREIGN\"].includes(constraint[1])) {\n        constraint[1] += \" KEY\";\n      }\n\n      return {\n        constraintName: Utils.removeTicks(constraint[0]),\n        constraintType: constraint[1],\n        updateAction,\n        deleteAction,\n        sql: sql.replace(/\"/g, \"`\"),\n        constraintCondition,\n        referenceTableName,\n        referenceTableKeys\n      };\n    });\n    return constraints;\n  }\n\n  applyParsers(type, value) {\n    if (type.includes(\"(\")) {\n      type = type.substr(0, type.indexOf(\"(\"));\n    }\n\n    type = type.replace(\"UNSIGNED\", \"\").replace(\"ZEROFILL\", \"\");\n    type = type.trim().toUpperCase();\n    const parse = parserStore.get(type);\n\n    if (value !== null && parse) {\n      return parse(value, {\n        timezone: this.sequelize.options.timezone\n      });\n    }\n\n    return value;\n  }\n\n  formatError(err, errStack) {\n    switch (err.code) {\n      case \"SQLITE_CONSTRAINT_UNIQUE\":\n      case \"SQLITE_CONSTRAINT_PRIMARYKEY\":\n      case \"SQLITE_CONSTRAINT_TRIGGER\":\n      case \"SQLITE_CONSTRAINT_FOREIGNKEY\":\n      case \"SQLITE_CONSTRAINT\":\n        {\n          if (err.message.includes(\"FOREIGN KEY constraint failed\")) {\n            return new sequelizeErrors.ForeignKeyConstraintError({\n              parent: err,\n              stack: errStack\n            });\n          }\n\n          let fields = [];\n          let match = err.message.match(/columns (.*?) are/);\n\n          if (match !== null && match.length >= 2) {\n            fields = match[1].split(\", \");\n          } else {\n            match = err.message.match(/UNIQUE constraint failed: (.*)/);\n\n            if (match !== null && match.length >= 2) {\n              fields = match[1].split(\", \").map(columnWithTable => columnWithTable.split(\".\")[1]);\n            }\n          }\n\n          const errors = [];\n          let message = \"Validation error\";\n\n          for (const field of fields) {\n            errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, this.instance && this.instance[field], this.instance, \"not_unique\"));\n          }\n\n          if (this.model) {\n            _.forOwn(this.model.uniqueKeys, constraint => {\n              if (_.isEqual(constraint.fields, fields) && !!constraint.msg) {\n                message = constraint.msg;\n                return false;\n              }\n            });\n          }\n\n          return new sequelizeErrors.UniqueConstraintError({\n            message,\n            errors,\n            parent: err,\n            fields,\n            stack: errStack\n          });\n        }\n\n      case \"SQLITE_BUSY\":\n        return new sequelizeErrors.TimeoutError(err, {\n          stack: errStack\n        });\n\n      default:\n        return new sequelizeErrors.DatabaseError(err, {\n          stack: errStack\n        });\n    }\n  }\n\n  async handleShowIndexesQuery(data) {\n    return Promise.all(data.reverse().map(async item => {\n      item.fields = [];\n      item.primary = false;\n      item.unique = !!item.unique;\n      item.constraintName = item.name;\n      const columns = await this.run(`PRAGMA INDEX_INFO(\\`${item.name}\\`)`);\n\n      for (const column of columns) {\n        item.fields[column.seqno] = {\n          attribute: column.name,\n          length: void 0,\n          order: void 0\n        };\n      }\n\n      return item;\n    }));\n  }\n\n  getDatabaseMethod() {\n    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes(\"CREATE TEMPORARY TABLE\".toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {\n      return \"run\";\n    }\n\n    return \"all\";\n  }\n\n}\n\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;","map":{"version":3,"mappings":"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","names":["_","require","Utils","AbstractQuery","QueryTypes","sequelizeErrors","parserStore","logger","debug","debugContext","value","toString","getInsertIdField","sql","values","dialect","bindParam","Array","isArray","forEach","v","i","formatBindParameters","skipValueReplace","k","Object","keys","_collectModels","include","prefix","ret","_include","key","as","model","merge","_handleQueryResponse","metaData","columnTypes","err","results","errStack","formatError","result","instance","isInsertQuery","isUpsertQuery","handleInsertQuery","constructor","name","autoIncrementAttribute","primaryKeyAttribute","rawAttributes","startId","changes","push","field","isShowTablesQuery","map","row","isShowConstraintsQuery","parseConstraintsFromSql","isSelectQuery","options","raw","handleSelectQuery","prefixes","result2","mapValues","includes","lastind","lastIndexOf","substr","tableName","getTableName","replace","tableTypes","forOwn","attribute","prototype","hasOwnProperty","call","applyParsers","isShowOrDescribeQuery","handleShowIndexesQuery","defaultValue","_result","dflt_value","type","allowNull","notnull","primaryKey","pk","BULKUPDATE","BULKDELETE","VERSION","version","RAW","isUpdateQuery","parameters","conn","connection","method","getDatabaseMethod","complete","_logQuery","Promise","resolve","reject","serialize","errForStack","Error","executeSql","startsWith","query","executionError","stack","error","isPlainObject","newParameters","create","stringifyIfBigint","afterExecute","tableNames","exec","filter","length","all","resolve2","constraints","split","referenceTableName","referenceTableKeys","updateAction","deleteAction","splice","constraintSql","match","referencesRegex","referenceConditions","removeTicks","columnNames","column","constraintCondition","constraint","constraintName","constraintType","indexOf","trim","toUpperCase","parse","get","timezone","sequelize","code","message","ForeignKeyConstraintError","parent","fields","columnWithTable","errors","ValidationErrorItem","getUniqueConstraintErrorMessage","uniqueKeys","isEqual","msg","UniqueConstraintError","TimeoutError","DatabaseError","data","reverse","item","primary","unique","columns","run","seqno","order","isBulkUpdateQuery","toLowerCase","module","exports","Query","default"],"sources":["/Users/aurele/node_modules/sequelize/src/dialects/sqlite/query.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst AbstractQuery = require('../abstract/query');\nconst QueryTypes = require('../../query-types');\nconst sequelizeErrors = require('../../errors');\nconst parserStore = require('../parserStore')('sqlite');\nconst { logger } = require('../../utils/logger');\n\nconst debug = logger.debugContext('sql:sqlite');\n\n// sqlite3 currently ignores bigint values, so we have to translate to string for now\n// There's a WIP here: https://github.com/TryGhost/node-sqlite3/pull/1501\nfunction stringifyIfBigint(value) {\n  if (typeof value === 'bigint') {\n    return value.toString();\n  }\n\n  return value;\n}\n\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return 'lastID';\n  }\n\n  /**\n   * rewrite query with parameters.\n   *\n   * @param {string} sql\n   * @param {Array|object} values\n   * @param {string} dialect\n   * @private\n   */\n  static formatBindParameters(sql, values, dialect) {\n    let bindParam;\n    if (Array.isArray(values)) {\n      bindParam = {};\n      values.forEach((v, i) => {\n        bindParam[`$${i + 1}`] = v;\n      });\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    } else {\n      bindParam = {};\n      if (typeof values === 'object') {\n        for (const k of Object.keys(values)) {\n          bindParam[`$${k}`] = values[k];\n        }\n      }\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    }\n    return [sql, bindParam];\n  }\n\n  _collectModels(include, prefix) {\n    const ret = {};\n\n    if (include) {\n      for (const _include of include) {\n        let key;\n        if (!prefix) {\n          key = _include.as;\n        } else {\n          key = `${prefix}.${_include.as}`;\n        }\n        ret[key] = _include.model;\n\n        if (_include.include) {\n          _.merge(ret, this._collectModels(_include.include, key));\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  _handleQueryResponse(metaData, columnTypes, err, results, errStack) {\n    if (err) {\n      err.sql = this.sql;\n      throw this.formatError(err, errStack);\n    }\n    let result = this.instance;\n\n    // add the inserted row id to the instance\n    if (this.isInsertQuery(results, metaData) || this.isUpsertQuery()) {\n      this.handleInsertQuery(results, metaData);\n      if (!this.instance) {\n        // handle bulkCreate AI primary key\n        if (\n          metaData.constructor.name === 'Statement'\n          && this.model\n          && this.model.autoIncrementAttribute\n          && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute\n          && this.model.rawAttributes[this.model.primaryKeyAttribute]\n        ) {\n          const startId = metaData[this.getInsertIdField()] - metaData.changes + 1;\n          result = [];\n          for (let i = startId; i < startId + metaData.changes; i++) {\n            result.push({ [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i });\n          }\n        } else {\n          result = metaData[this.getInsertIdField()];\n        }\n      }\n    }\n\n    if (this.isShowTablesQuery()) {\n      return results.map(row => row.name);\n    }\n    if (this.isShowConstraintsQuery()) {\n      result = results;\n      if (results && results[0] && results[0].sql) {\n        result = this.parseConstraintsFromSql(results[0].sql);\n      }\n      return result;\n    }\n    if (this.isSelectQuery()) {\n      if (this.options.raw) {\n        return this.handleSelectQuery(results);\n      }\n      // This is a map of prefix strings to models, e.g. user.projects -> Project model\n      const prefixes = this._collectModels(this.options.include);\n\n      results = results.map(result => {\n        return _.mapValues(result, (value, name) => {\n          let model;\n          if (name.includes('.')) {\n            const lastind = name.lastIndexOf('.');\n\n            model = prefixes[name.substr(0, lastind)];\n\n            name = name.substr(lastind + 1);\n          } else {\n            model = this.options.model;\n          }\n\n          const tableName = model.getTableName().toString().replace(/`/g, '');\n          const tableTypes = columnTypes[tableName] || {};\n\n          if (tableTypes && !(name in tableTypes)) {\n            // The column is aliased\n            _.forOwn(model.rawAttributes, (attribute, key) => {\n              if (name === key && attribute.field) {\n                name = attribute.field;\n                return false;\n              }\n            });\n          }\n\n          return Object.prototype.hasOwnProperty.call(tableTypes, name)\n            ? this.applyParsers(tableTypes[name], value)\n            : value;\n        });\n      });\n\n      return this.handleSelectQuery(results);\n    }\n    if (this.isShowOrDescribeQuery()) {\n      return results;\n    }\n    if (this.sql.includes('PRAGMA INDEX_LIST')) {\n      return this.handleShowIndexesQuery(results);\n    }\n    if (this.sql.includes('PRAGMA INDEX_INFO')) {\n      return results;\n    }\n    if (this.sql.includes('PRAGMA TABLE_INFO')) {\n      // this is the sqlite way of getting the metadata of a table\n      result = {};\n\n      let defaultValue;\n      for (const _result of results) {\n        if (_result.dflt_value === null) {\n          // Column schema omits any \"DEFAULT ...\"\n          defaultValue = undefined;\n        } else if (_result.dflt_value === 'NULL') {\n          // Column schema is a \"DEFAULT NULL\"\n          defaultValue = null;\n        } else {\n          defaultValue = _result.dflt_value;\n        }\n\n        result[_result.name] = {\n          type: _result.type,\n          allowNull: _result.notnull === 0,\n          defaultValue,\n          primaryKey: _result.pk !== 0\n        };\n\n        if (result[_result.name].type === 'TINYINT(1)') {\n          result[_result.name].defaultValue = { '0': false, '1': true }[result[_result.name].defaultValue];\n        }\n\n        if (typeof result[_result.name].defaultValue === 'string') {\n          result[_result.name].defaultValue = result[_result.name].defaultValue.replace(/'/g, '');\n        }\n      }\n      return result;\n    }\n    if (this.sql.includes('PRAGMA foreign_keys;')) {\n      return results[0];\n    }\n    if (this.sql.includes('PRAGMA foreign_keys')) {\n      return results;\n    }\n    if (this.sql.includes('PRAGMA foreign_key_list')) {\n      return results;\n    }\n    if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].includes(this.options.type)) {\n      return metaData.changes;\n    }\n    if (this.options.type === QueryTypes.VERSION) {\n      return results[0].version;\n    }\n    if (this.options.type === QueryTypes.RAW) {\n      return [results, metaData];\n    }\n    if (this.isUpsertQuery()) {\n      return [result, null];\n    }\n    if (this.isUpdateQuery() || this.isInsertQuery()) {\n      return [result, metaData.changes];\n    }\n    return result;\n  }\n\n  async run(sql, parameters) {\n    const conn = this.connection;\n    this.sql = sql;\n    const method = this.getDatabaseMethod();\n    const complete = this._logQuery(sql, debug, parameters);\n\n    return new Promise((resolve, reject) => conn.serialize(async () => {\n      const columnTypes = {};\n      const errForStack = new Error();\n      const executeSql = () => {\n        if (sql.startsWith('-- ')) {\n          return resolve();\n        }\n        const query = this;\n        // cannot use arrow function here because the function is bound to the statement\n        function afterExecute(executionError, results) {\n          try {\n            complete();\n            // `this` is passed from sqlite, we have no control over this.\n            // eslint-disable-next-line no-invalid-this\n            resolve(query._handleQueryResponse(this, columnTypes, executionError, results, errForStack.stack));\n            return;\n          } catch (error) {\n            reject(error);\n          }\n        }\n\n        if (!parameters) parameters = [];\n\n        if (_.isPlainObject(parameters)) {\n          const newParameters = Object.create(null);\n          for (const key of Object.keys(parameters)) {\n            newParameters[`${key}`] = stringifyIfBigint(parameters[key]);\n          }\n          parameters = newParameters;\n        } else {\n          parameters = parameters.map(stringifyIfBigint);\n        }\n\n        conn[method](sql, parameters, afterExecute);\n\n        return null;\n      };\n\n      if (this.getDatabaseMethod() === 'all') {\n        let tableNames = [];\n        if (this.options && this.options.tableNames) {\n          tableNames = this.options.tableNames;\n        } else if (/FROM `(.*?)`/i.exec(this.sql)) {\n          tableNames.push(/FROM `(.*?)`/i.exec(this.sql)[1]);\n        }\n\n        // If we already have the metadata for the table, there's no need to ask for it again\n        tableNames = tableNames.filter(tableName => !(tableName in columnTypes) && tableName !== 'sqlite_master');\n\n        if (!tableNames.length) {\n          return executeSql();\n        }\n        await Promise.all(tableNames.map(tableName =>\n          new Promise(resolve => {\n            tableName = tableName.replace(/`/g, '');\n            columnTypes[tableName] = {};\n\n            conn.all(`PRAGMA table_info(\\`${tableName}\\`)`, (err, results) => {\n              if (!err) {\n                for (const result of results) {\n                  columnTypes[tableName][result.name] = result.type;\n                }\n              }\n              resolve();\n            });\n          })));\n      }\n      return executeSql();\n    }));\n  }\n\n  parseConstraintsFromSql(sql) {\n    let constraints = sql.split('CONSTRAINT ');\n    let referenceTableName, referenceTableKeys, updateAction, deleteAction;\n    constraints.splice(0, 1);\n    constraints = constraints.map(constraintSql => {\n      //Parse foreign key snippets\n      if (constraintSql.includes('REFERENCES')) {\n        //Parse out the constraint condition form sql string\n        updateAction = constraintSql.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n        deleteAction = constraintSql.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n\n        if (updateAction) {\n          updateAction = updateAction[1];\n        }\n\n        if (deleteAction) {\n          deleteAction = deleteAction[1];\n        }\n\n        const referencesRegex = /REFERENCES.+\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/;\n        const referenceConditions = constraintSql.match(referencesRegex)[0].split(' ');\n        referenceTableName = Utils.removeTicks(referenceConditions[1]);\n        let columnNames = referenceConditions[2];\n        columnNames = columnNames.replace(/\\(|\\)/g, '').split(', ');\n        referenceTableKeys = columnNames.map(column => Utils.removeTicks(column));\n      }\n\n      const constraintCondition = constraintSql.match(/\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/)[0];\n      constraintSql = constraintSql.replace(/\\(.+\\)/, '');\n      const constraint = constraintSql.split(' ');\n\n      if (['PRIMARY', 'FOREIGN'].includes(constraint[1])) {\n        constraint[1] += ' KEY';\n      }\n\n      return {\n        constraintName: Utils.removeTicks(constraint[0]),\n        constraintType: constraint[1],\n        updateAction,\n        deleteAction,\n        sql: sql.replace(/\"/g, '`'), //Sqlite returns double quotes for table name\n        constraintCondition,\n        referenceTableName,\n        referenceTableKeys\n      };\n    });\n\n    return constraints;\n  }\n\n  applyParsers(type, value) {\n    if (type.includes('(')) {\n      // Remove the length part\n      type = type.substr(0, type.indexOf('('));\n    }\n    type = type.replace('UNSIGNED', '').replace('ZEROFILL', '');\n    type = type.trim().toUpperCase();\n    const parse = parserStore.get(type);\n\n    if (value !== null && parse) {\n      return parse(value, { timezone: this.sequelize.options.timezone });\n    }\n    return value;\n  }\n\n  formatError(err, errStack) {\n\n    switch (err.code) {\n      case 'SQLITE_CONSTRAINT_UNIQUE':\n      case 'SQLITE_CONSTRAINT_PRIMARYKEY':\n      case 'SQLITE_CONSTRAINT_TRIGGER':\n      case 'SQLITE_CONSTRAINT_FOREIGNKEY':\n      case 'SQLITE_CONSTRAINT': {\n        if (err.message.includes('FOREIGN KEY constraint failed')) {\n          return new sequelizeErrors.ForeignKeyConstraintError({\n            parent: err,\n            stack: errStack\n          });\n        }\n\n        let fields = [];\n\n        // Sqlite pre 2.2 behavior - Error: SQLITE_CONSTRAINT: columns x, y are not unique\n        let match = err.message.match(/columns (.*?) are/);\n        if (match !== null && match.length >= 2) {\n          fields = match[1].split(', ');\n        } else {\n\n          // Sqlite post 2.2 behavior - Error: SQLITE_CONSTRAINT: UNIQUE constraint failed: table.x, table.y\n          match = err.message.match(/UNIQUE constraint failed: (.*)/);\n          if (match !== null && match.length >= 2) {\n            fields = match[1].split(', ').map(columnWithTable => columnWithTable.split('.')[1]);\n          }\n        }\n\n        const errors = [];\n        let message = 'Validation error';\n\n        for (const field of fields) {\n          errors.push(new sequelizeErrors.ValidationErrorItem(\n            this.getUniqueConstraintErrorMessage(field),\n            'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,\n            field,\n            this.instance && this.instance[field],\n            this.instance,\n            'not_unique'\n          ));\n        }\n\n        if (this.model) {\n          _.forOwn(this.model.uniqueKeys, constraint => {\n            if (_.isEqual(constraint.fields, fields) && !!constraint.msg) {\n              message = constraint.msg;\n              return false;\n            }\n          });\n        }\n\n        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields, stack: errStack });\n      }\n      case 'SQLITE_BUSY':\n        return new sequelizeErrors.TimeoutError(err, { stack: errStack });\n\n      default:\n        return new sequelizeErrors.DatabaseError(err, { stack: errStack });\n    }\n  }\n\n  async handleShowIndexesQuery(data) {\n    // Sqlite returns indexes so the one that was defined last is returned first. Lets reverse that!\n    return Promise.all(data.reverse().map(async item => {\n      item.fields = [];\n      item.primary = false;\n      item.unique = !!item.unique;\n      item.constraintName = item.name;\n      const columns = await this.run(`PRAGMA INDEX_INFO(\\`${item.name}\\`)`);\n      for (const column of columns) {\n        item.fields[column.seqno] = {\n          attribute: column.name,\n          length: undefined,\n          order: undefined\n        };\n      }\n\n      return item;\n    }));\n  }\n\n  getDatabaseMethod() {\n    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes('CREATE TEMPORARY TABLE'.toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {\n      return 'run';\n    }\n    return 'all';\n  }\n}\n\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;\n"]},"metadata":{},"sourceType":"script"}