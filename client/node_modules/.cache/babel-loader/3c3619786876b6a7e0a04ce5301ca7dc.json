{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nconst _ = require(\"lodash\");\n\nconst Utils = require(\"../../utils\");\n\nconst DataTypes = require(\"../../data-types\");\n\nconst TableHints = require(\"../../table-hints\");\n\nconst AbstractQueryGenerator = require(\"../abstract/query-generator\");\n\nconst randomBytes = require(\"crypto\").randomBytes;\n\nconst semver = require(\"semver\");\n\nconst Op = require(\"../../operators\");\n\nconst throwMethodUndefined = function (methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n};\n\nclass MSSQLQueryGenerator extends AbstractQueryGenerator {\n  createDatabaseQuery(databaseName, options) {\n    options = __spreadValues({\n      collate: null\n    }, options);\n    const collation = options.collate ? `COLLATE ${this.escape(options.collate)}` : \"\";\n    return [\"IF NOT EXISTS (SELECT * FROM sys.databases WHERE name =\", wrapSingleQuote(databaseName), \")\", \"BEGIN\", \"CREATE DATABASE\", this.quoteIdentifier(databaseName), `${collation};`, \"END;\"].join(\" \");\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return [\"IF EXISTS (SELECT * FROM sys.databases WHERE name =\", wrapSingleQuote(databaseName), \")\", \"BEGIN\", \"DROP DATABASE\", this.quoteIdentifier(databaseName), \";\", \"END;\"].join(\" \");\n  }\n\n  createSchema(schema) {\n    return [\"IF NOT EXISTS (SELECT schema_name\", \"FROM information_schema.schemata\", \"WHERE schema_name =\", wrapSingleQuote(schema), \")\", \"BEGIN\", \"EXEC sp_executesql N'CREATE SCHEMA\", this.quoteIdentifier(schema), \";'\", \"END;\"].join(\" \");\n  }\n\n  dropSchema(schema) {\n    const quotedSchema = wrapSingleQuote(schema);\n    return [\"IF EXISTS (SELECT schema_name\", \"FROM information_schema.schemata\", \"WHERE schema_name =\", quotedSchema, \")\", \"BEGIN\", \"DECLARE @id INT, @ms_sql NVARCHAR(2000);\", \"DECLARE @cascade TABLE (\", \"id INT NOT NULL IDENTITY PRIMARY KEY,\", \"ms_sql NVARCHAR(2000) NOT NULL );\", \"INSERT INTO @cascade ( ms_sql )\", \"SELECT CASE WHEN o.type IN ('F','PK')\", \"THEN N'ALTER TABLE ['+ s.name + N'].[' + p.name + N'] DROP CONSTRAINT [' + o.name + N']'\", \"ELSE N'DROP TABLE ['+ s.name + N'].[' + o.name + N']' END\", \"FROM sys.objects o\", \"JOIN sys.schemas s on o.schema_id = s.schema_id\", \"LEFT OUTER JOIN sys.objects p on o.parent_object_id = p.object_id\", \"WHERE o.type IN ('F', 'PK', 'U') AND s.name = \", quotedSchema, \"ORDER BY o.type ASC;\", \"SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;\", \"WHILE @id IS NOT NULL\", \"BEGIN\", \"BEGIN TRY EXEC sp_executesql @ms_sql; END TRY\", \"BEGIN CATCH BREAK; THROW; END CATCH;\", \"DELETE FROM @cascade WHERE id = @id;\", \"SELECT @id = NULL, @ms_sql = NULL;\", \"SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;\", \"END\", \"EXEC sp_executesql N'DROP SCHEMA\", this.quoteIdentifier(schema), \";'\", \"END;\"].join(\" \");\n  }\n\n  showSchemasQuery() {\n    return ['SELECT \"name\" as \"schema_name\" FROM sys.schemas as s', 'WHERE \"s\".\"name\" NOT IN (', \"'INFORMATION_SCHEMA', 'dbo', 'guest', 'sys', 'archive'\", \")\", \"AND\", '\"s\".\"name\" NOT LIKE', \"'db_%'\"].join(\" \");\n  }\n\n  versionQuery() {\n    return [\"DECLARE @ms_ver NVARCHAR(20);\", \"SET @ms_ver = REVERSE(CONVERT(NVARCHAR(20), SERVERPROPERTY('ProductVersion')));\", \"SELECT REVERSE(SUBSTRING(@ms_ver, CHARINDEX('.', @ms_ver)+1, 20)) AS 'version'\"].join(\" \");\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    const primaryKeys = [],\n          foreignKeys = {},\n          attributesClauseParts = [];\n    let commentStr = \"\";\n\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        let dataType = attributes[attr];\n        let match;\n\n        if (dataType.includes(\"COMMENT \")) {\n          const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);\n          const commentText = commentMatch[2].replace(\"COMMENT\", \"\").trim();\n          commentStr += this.commentTemplate(commentText, tableName, attr);\n          dataType = commentMatch[1];\n        }\n\n        if (dataType.includes(\"PRIMARY KEY\")) {\n          primaryKeys.push(attr);\n\n          if (dataType.includes(\"REFERENCES\")) {\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1].replace(\"PRIMARY KEY\", \"\")}`);\n            foreignKeys[attr] = match[2];\n          } else {\n            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType.replace(\"PRIMARY KEY\", \"\")}`);\n          }\n        } else if (dataType.includes(\"REFERENCES\")) {\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n        }\n      }\n    }\n\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(\", \");\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== \"string\") {\n            indexName = `uniq_${tableName}_${columns.fields.join(\"_\")}`;\n          }\n\n          attributesClauseParts.push(`CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(\", \")})`);\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClauseParts.push(`PRIMARY KEY (${pkString})`);\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClauseParts.push(`FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`);\n      }\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    return Utils.joinSQLFragments([`IF OBJECT_ID('${quotedTableName}', 'U') IS NULL`, `CREATE TABLE ${quotedTableName} (${attributesClauseParts.join(\", \")})`, \";\", commentStr]);\n  }\n\n  describeTableQuery(tableName, schema) {\n    let sql = [\"SELECT\", \"c.COLUMN_NAME AS 'Name',\", \"c.DATA_TYPE AS 'Type',\", \"c.CHARACTER_MAXIMUM_LENGTH AS 'Length',\", \"c.IS_NULLABLE as 'IsNull',\", \"COLUMN_DEFAULT AS 'Default',\", \"pk.CONSTRAINT_TYPE AS 'Constraint',\", \"COLUMNPROPERTY(OBJECT_ID(c.TABLE_SCHEMA+'.'+c.TABLE_NAME), c.COLUMN_NAME, 'IsIdentity') as 'IsIdentity',\", \"CAST(prop.value AS NVARCHAR) AS 'Comment'\", \"FROM\", \"INFORMATION_SCHEMA.TABLES t\", \"INNER JOIN\", \"INFORMATION_SCHEMA.COLUMNS c ON t.TABLE_NAME = c.TABLE_NAME AND t.TABLE_SCHEMA = c.TABLE_SCHEMA\", \"LEFT JOIN (SELECT tc.table_schema, tc.table_name, \", \"cu.column_name, tc.CONSTRAINT_TYPE \", \"FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc \", \"JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE  cu \", \"ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name \", \"and tc.constraint_name=cu.constraint_name \", \"and tc.CONSTRAINT_TYPE='PRIMARY KEY') pk \", \"ON pk.table_schema=c.table_schema \", \"AND pk.table_name=c.table_name \", \"AND pk.column_name=c.column_name \", \"INNER JOIN sys.columns AS sc\", \"ON sc.object_id = object_id(t.table_schema + '.' + t.table_name) AND sc.name = c.column_name\", \"LEFT JOIN sys.extended_properties prop ON prop.major_id = sc.object_id\", \"AND prop.minor_id = sc.column_id\", \"AND prop.name = 'MS_Description'\", \"WHERE t.TABLE_NAME =\", wrapSingleQuote(tableName)].join(\" \");\n\n    if (schema) {\n      sql += `AND t.TABLE_SCHEMA =${wrapSingleQuote(schema)}`;\n    }\n\n    return sql;\n  }\n\n  renameTableQuery(before, after) {\n    return `EXEC sp_rename ${this.quoteTable(before)}, ${this.quoteTable(after)};`;\n  }\n\n  showTablesQuery() {\n    return \"SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE';\";\n  }\n\n  tableExistsQuery(table) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema || \"dbo\";\n    return `SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = ${this.escape(tableName)} AND TABLE_SCHEMA = ${this.escape(schemaName)}`;\n  }\n\n  dropTableQuery(tableName) {\n    const quoteTbl = this.quoteTable(tableName);\n    return Utils.joinSQLFragments([`IF OBJECT_ID('${quoteTbl}', 'U') IS NOT NULL`, \"DROP TABLE\", quoteTbl, \";\"]);\n  }\n\n  addColumnQuery(table, key, dataType) {\n    dataType.field = key;\n    let commentStr = \"\";\n\n    if (dataType.comment && _.isString(dataType.comment)) {\n      commentStr = this.commentTemplate(dataType.comment, table, key);\n      delete dataType[\"comment\"];\n    }\n\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(table), \"ADD\", this.quoteIdentifier(key), this.attributeToSQL(dataType, {\n      context: \"addColumn\"\n    }), \";\", commentStr]);\n  }\n\n  commentTemplate(comment, table, column) {\n    return ` EXEC sp_addextendedproperty @name = N'MS_Description', @value = ${this.escape(comment)}, @level0type = N'Schema', @level0name = 'dbo', @level1type = N'Table', @level1name = ${this.quoteIdentifier(table)}, @level2type = N'Column', @level2name = ${this.quoteIdentifier(column)};`;\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"DROP COLUMN\", this.quoteIdentifier(attributeName), \";\"]);\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [],\n          constraintString = [];\n    let commentString = \"\";\n\n    for (const attributeName in attributes) {\n      const quotedAttrName = this.quoteIdentifier(attributeName);\n      let definition = attributes[attributeName];\n\n      if (definition.includes(\"COMMENT \")) {\n        const commentMatch = definition.match(/^(.+) (COMMENT.*)$/);\n        const commentText = commentMatch[2].replace(\"COMMENT\", \"\").trim();\n        commentString += this.commentTemplate(commentText, tableName, attributeName);\n        definition = commentMatch[1];\n      }\n\n      if (definition.includes(\"REFERENCES\")) {\n        constraintString.push(`FOREIGN KEY (${quotedAttrName}) ${definition.replace(/.+?(?=REFERENCES)/, \"\")}`);\n      } else {\n        attrString.push(`${quotedAttrName} ${definition}`);\n      }\n    }\n\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), attrString.length && `ALTER COLUMN ${attrString.join(\", \")}`, constraintString.length && `ADD ${constraintString.join(\", \")}`, \";\", commentString]);\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const newName = Object.keys(attributes)[0];\n    return Utils.joinSQLFragments([\"EXEC sp_rename\", `'${this.quoteTable(tableName)}.${attrBefore}',`, `'${newName}',`, \"'COLUMN'\", \";\"]);\n  }\n\n  bulkInsertQuery(tableName, attrValueHashes, options, attributes) {\n    const quotedTable = this.quoteTable(tableName);\n    options = options || {};\n    attributes = attributes || {};\n    const tuples = [];\n    const allAttributes = [];\n    const allQueries = [];\n    let needIdentityInsertWrapper = false,\n        outputFragment = \"\";\n\n    if (options.returning) {\n      const returnValues = this.generateReturnValues(attributes, options);\n      outputFragment = returnValues.outputFragment;\n    }\n\n    const emptyQuery = `INSERT INTO ${quotedTable}${outputFragment} DEFAULT VALUES`;\n    attrValueHashes.forEach(attrValueHash => {\n      const fields = Object.keys(attrValueHash);\n      const firstAttr = attributes[fields[0]];\n\n      if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {\n        allQueries.push(emptyQuery);\n        return;\n      }\n\n      _.forOwn(attrValueHash, (value, key) => {\n        if (value !== null && attributes[key] && attributes[key].autoIncrement) {\n          needIdentityInsertWrapper = true;\n        }\n\n        if (!allAttributes.includes(key)) {\n          if (value === null && attributes[key] && attributes[key].autoIncrement) return;\n          allAttributes.push(key);\n        }\n      });\n    });\n\n    if (allAttributes.length > 0) {\n      attrValueHashes.forEach(attrValueHash => {\n        tuples.push(`(${allAttributes.map(key => this.escape(attrValueHash[key])).join(\",\")})`);\n      });\n      const quotedAttributes = allAttributes.map(attr => this.quoteIdentifier(attr)).join(\",\");\n      allQueries.push(tupleStr => `INSERT INTO ${quotedTable} (${quotedAttributes})${outputFragment} VALUES ${tupleStr};`);\n    }\n\n    const commands = [];\n    let offset = 0;\n    const batch = Math.floor(250 / (allAttributes.length + 1)) + 1;\n\n    while (offset < Math.max(tuples.length, 1)) {\n      const tupleStr = tuples.slice(offset, Math.min(tuples.length, offset + batch));\n      let generatedQuery = allQueries.map(v => typeof v === \"string\" ? v : v(tupleStr)).join(\";\");\n\n      if (needIdentityInsertWrapper) {\n        generatedQuery = `SET IDENTITY_INSERT ${quotedTable} ON; ${generatedQuery}; SET IDENTITY_INSERT ${quotedTable} OFF;`;\n      }\n\n      commands.push(generatedQuery);\n      offset += batch;\n    }\n\n    return commands.join(\";\");\n  }\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);\n\n    if (options.limit) {\n      const updateArgs = `UPDATE TOP(${this.escape(options.limit)})`;\n      sql.query = sql.query.replace(\"UPDATE\", updateArgs);\n    }\n\n    return sql;\n  }\n\n  upsertQuery(tableName, insertValues, updateValues, where, model) {\n    const targetTableAlias = this.quoteTable(`${tableName}_target`);\n    const sourceTableAlias = this.quoteTable(`${tableName}_source`);\n    const primaryKeysAttrs = [];\n    const identityAttrs = [];\n    const uniqueAttrs = [];\n    const tableNameQuoted = this.quoteTable(tableName);\n    let needIdentityInsertWrapper = false;\n\n    for (const key in model.rawAttributes) {\n      if (model.rawAttributes[key].primaryKey) {\n        primaryKeysAttrs.push(model.rawAttributes[key].field || key);\n      }\n\n      if (model.rawAttributes[key].unique) {\n        uniqueAttrs.push(model.rawAttributes[key].field || key);\n      }\n\n      if (model.rawAttributes[key].autoIncrement) {\n        identityAttrs.push(model.rawAttributes[key].field || key);\n      }\n    }\n\n    for (const index of model._indexes) {\n      if (index.unique && index.fields) {\n        for (const field of index.fields) {\n          const fieldName = typeof field === \"string\" ? field : field.name || field.attribute;\n\n          if (!uniqueAttrs.includes(fieldName) && model.rawAttributes[fieldName]) {\n            uniqueAttrs.push(fieldName);\n          }\n        }\n      }\n    }\n\n    const updateKeys = Object.keys(updateValues);\n    const insertKeys = Object.keys(insertValues);\n    const insertKeysQuoted = insertKeys.map(key => this.quoteIdentifier(key)).join(\", \");\n    const insertValuesEscaped = insertKeys.map(key => this.escape(insertValues[key])).join(\", \");\n    const sourceTableQuery = `VALUES(${insertValuesEscaped})`;\n    let joinCondition;\n    identityAttrs.forEach(key => {\n      if (insertValues[key] && insertValues[key] !== null) {\n        needIdentityInsertWrapper = true;\n      }\n    });\n    const clauses = where[Op.or].filter(clause => {\n      let valid = true;\n\n      for (const key in clause) {\n        if (typeof clause[key] === \"undefined\" || clause[key] == null) {\n          valid = false;\n          break;\n        }\n      }\n\n      return valid;\n    });\n\n    const getJoinSnippet = array => {\n      return array.map(key => {\n        key = this.quoteIdentifier(key);\n        return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;\n      });\n    };\n\n    if (clauses.length === 0) {\n      throw new Error(\"Primary Key or Unique key should be passed to upsert query\");\n    } else {\n      for (const key in clauses) {\n        const keys = Object.keys(clauses[key]);\n\n        if (primaryKeysAttrs.includes(keys[0])) {\n          joinCondition = getJoinSnippet(primaryKeysAttrs).join(\" AND \");\n          break;\n        }\n      }\n\n      if (!joinCondition) {\n        joinCondition = getJoinSnippet(uniqueAttrs).join(\" AND \");\n      }\n    }\n\n    const filteredUpdateClauses = updateKeys.filter(key => !identityAttrs.includes(key)).map(key => {\n      const value = this.escape(updateValues[key]);\n      key = this.quoteIdentifier(key);\n      return `${targetTableAlias}.${key} = ${value}`;\n    });\n    const updateSnippet = filteredUpdateClauses.length > 0 ? `WHEN MATCHED THEN UPDATE SET ${filteredUpdateClauses.join(\", \")}` : \"\";\n    const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;\n    let query = `MERGE INTO ${tableNameQuoted} WITH(HOLDLOCK) AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;\n    query += ` ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet} OUTPUT $action, INSERTED.*;`;\n\n    if (needIdentityInsertWrapper) {\n      query = `SET IDENTITY_INSERT ${tableNameQuoted} ON; ${query} SET IDENTITY_INSERT ${tableNameQuoted} OFF;`;\n    }\n\n    return query;\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;\n  }\n\n  deleteQuery(tableName, where) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let model = arguments.length > 3 ? arguments[3] : undefined;\n    const table = this.quoteTable(tableName);\n    const whereClause = this.getWhereConditions(where, null, model, options);\n    return Utils.joinSQLFragments([\"DELETE\", options.limit && `TOP(${this.escape(options.limit)})`, \"FROM\", table, whereClause && `WHERE ${whereClause}`, \";\", \"SELECT @@ROWCOUNT AS AFFECTEDROWS\", \";\"]);\n  }\n\n  showIndexesQuery(tableName) {\n    return `EXEC sys.sp_helpindex @objname = N'${this.quoteTable(tableName)}';`;\n  }\n\n  showConstraintsQuery(tableName) {\n    return `EXEC sp_helpconstraint @objname = ${this.escape(this.quoteTable(tableName))};`;\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n\n    return `DROP INDEX ${this.quoteIdentifiers(indexName)} ON ${this.quoteIdentifiers(tableName)}`;\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    if (attribute.references) {\n      if (attribute.Model && attribute.Model.tableName === attribute.references.model) {\n        this.sequelize.log(\"MSSQL does not support self referencial constraints, we will remove it but we recommend restructuring your query\");\n        attribute.onDelete = \"\";\n        attribute.onUpdate = \"\";\n      }\n    }\n\n    let template;\n\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;\n      template = attribute.type.toSql();\n      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.values.map(value => {\n        return this.escape(value);\n      }).join(\", \")}))`;\n      return template;\n    }\n\n    template = attribute.type.toString();\n\n    if (attribute.allowNull === false) {\n      template += \" NOT NULL\";\n    } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += \" NULL\";\n    }\n\n    if (attribute.autoIncrement) {\n      template += \" IDENTITY(1,1)\";\n    }\n\n    if (attribute.type !== \"TEXT\" && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (attribute.unique === true) {\n      template += \" UNIQUE\";\n    }\n\n    if (attribute.primaryKey) {\n      template += \" PRIMARY KEY\";\n    }\n\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier(\"id\")})`;\n      }\n\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n\n    if (attribute.comment && typeof attribute.comment === \"string\") {\n      template += ` COMMENT ${attribute.comment}`;\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {},\n          existingConstraints = [];\n    let key, attribute;\n\n    for (key in attributes) {\n      attribute = attributes[key];\n\n      if (attribute.references) {\n        if (existingConstraints.includes(attribute.references.model.toString())) {\n          attribute.onDelete = \"\";\n          attribute.onUpdate = \"\";\n        } else {\n          existingConstraints.push(attribute.references.model.toString());\n          attribute.onUpdate = \"\";\n        }\n      }\n\n      if (key && !attribute.field) attribute.field = key;\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n\n  createTrigger() {\n    throwMethodUndefined(\"createTrigger\");\n  }\n\n  dropTrigger() {\n    throwMethodUndefined(\"dropTrigger\");\n  }\n\n  renameTrigger() {\n    throwMethodUndefined(\"renameTrigger\");\n  }\n\n  createFunction() {\n    throwMethodUndefined(\"createFunction\");\n  }\n\n  dropFunction() {\n    throwMethodUndefined(\"dropFunction\");\n  }\n\n  renameFunction() {\n    throwMethodUndefined(\"renameFunction\");\n  }\n\n  _getForeignKeysQueryPrefix(catalogName) {\n    return `${\"SELECT constraint_name = OBJ.NAME, constraintName = OBJ.NAME, \"}${catalogName ? `constraintCatalog = '${catalogName}', ` : \"\"}constraintSchema = SCHEMA_NAME(OBJ.SCHEMA_ID), tableName = TB.NAME, tableSchema = SCHEMA_NAME(TB.SCHEMA_ID), ${catalogName ? `tableCatalog = '${catalogName}', ` : \"\"}columnName = COL.NAME, referencedTableSchema = SCHEMA_NAME(RTB.SCHEMA_ID), ${catalogName ? `referencedCatalog = '${catalogName}', ` : \"\"}referencedTableName = RTB.NAME, referencedColumnName = RCOL.NAME FROM sys.foreign_key_columns FKC INNER JOIN sys.objects OBJ ON OBJ.OBJECT_ID = FKC.CONSTRAINT_OBJECT_ID INNER JOIN sys.tables TB ON TB.OBJECT_ID = FKC.PARENT_OBJECT_ID INNER JOIN sys.columns COL ON COL.COLUMN_ID = PARENT_COLUMN_ID AND COL.OBJECT_ID = TB.OBJECT_ID INNER JOIN sys.tables RTB ON RTB.OBJECT_ID = FKC.REFERENCED_OBJECT_ID INNER JOIN sys.columns RCOL ON RCOL.COLUMN_ID = REFERENCED_COLUMN_ID AND RCOL.OBJECT_ID = RTB.OBJECT_ID`;\n  }\n\n  getForeignKeysQuery(table, catalogName) {\n    const tableName = table.tableName || table;\n    let sql = `${this._getForeignKeysQueryPrefix(catalogName)} WHERE TB.NAME =${wrapSingleQuote(tableName)}`;\n\n    if (table.schema) {\n      sql += ` AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`;\n    }\n\n    return sql;\n  }\n\n  getForeignKeyQuery(table, attributeName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments([this._getForeignKeysQueryPrefix(), \"WHERE\", `TB.NAME =${wrapSingleQuote(tableName)}`, \"AND\", `COL.NAME =${wrapSingleQuote(attributeName)}`, table.schema && `AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`]);\n  }\n\n  getPrimaryKeyConstraintQuery(table, attributeName) {\n    const tableName = wrapSingleQuote(table.tableName || table);\n    return Utils.joinSQLFragments([\"SELECT K.TABLE_NAME AS tableName,\", \"K.COLUMN_NAME AS columnName,\", \"K.CONSTRAINT_NAME AS constraintName\", \"FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS C\", \"JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS K\", \"ON C.TABLE_NAME = K.TABLE_NAME\", \"AND C.CONSTRAINT_CATALOG = K.CONSTRAINT_CATALOG\", \"AND C.CONSTRAINT_SCHEMA = K.CONSTRAINT_SCHEMA\", \"AND C.CONSTRAINT_NAME = K.CONSTRAINT_NAME\", \"WHERE C.CONSTRAINT_TYPE = 'PRIMARY KEY'\", `AND K.COLUMN_NAME = ${wrapSingleQuote(attributeName)}`, `AND K.TABLE_NAME = ${tableName}`, \";\"]);\n  }\n\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"DROP\", this.quoteIdentifier(foreignKey)]);\n  }\n\n  getDefaultConstraintQuery(tableName, attributeName) {\n    const quotedTable = this.quoteTable(tableName);\n    return Utils.joinSQLFragments([\"SELECT name FROM sys.default_constraints\", `WHERE PARENT_OBJECT_ID = OBJECT_ID('${quotedTable}', 'U')`, `AND PARENT_COLUMN_ID = (SELECT column_id FROM sys.columns WHERE NAME = ('${attributeName}')`, `AND object_id = OBJECT_ID('${quotedTable}', 'U'))`, \";\"]);\n  }\n\n  dropConstraintQuery(tableName, constraintName) {\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"DROP CONSTRAINT\", this.quoteIdentifier(constraintName), \";\"]);\n  }\n\n  setIsolationLevelQuery() {}\n\n  generateTransactionId() {\n    return randomBytes(10).toString(\"hex\");\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return \"BEGIN TRANSACTION;\";\n  }\n\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n\n    return \"COMMIT TRANSACTION;\";\n  }\n\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return \"ROLLBACK TRANSACTION;\";\n  }\n\n  selectFromTableFragment(options, model, attributes, tables, mainTableAs, where) {\n    this._throwOnEmptyAttributes(attributes, {\n      modelName: model && model.name,\n      as: mainTableAs\n    });\n\n    const dbVersion = this.sequelize.options.databaseVersion;\n    const isSQLServer2008 = semver.valid(dbVersion) && semver.lt(dbVersion, \"11.0.0\");\n\n    if (isSQLServer2008 && options.offset) {\n      const offset = options.offset || 0;\n      const isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n      let orders = {\n        mainQueryOrder: []\n      };\n\n      if (options.order) {\n        orders = this.getQueryOrders(options, model, isSubQuery);\n      }\n\n      if (orders.mainQueryOrder.length === 0) {\n        orders.mainQueryOrder.push(this.quoteIdentifier(model.primaryKeyField));\n      }\n\n      const tmpTable = mainTableAs || \"OffsetTable\";\n\n      if (options.include) {\n        const subQuery = options.subQuery === void 0 ? options.limit && options.hasMultiAssociation : options.subQuery;\n        const mainTable = {\n          name: mainTableAs,\n          quotedName: null,\n          as: null,\n          model\n        };\n        const topLevelInfo = {\n          names: mainTable,\n          options,\n          subQuery\n        };\n        let mainJoinQueries = [];\n\n        for (const include of options.include) {\n          if (include.separate) {\n            continue;\n          }\n\n          const joinQueries = this.generateInclude(include, {\n            externalAs: mainTableAs,\n            internalAs: mainTableAs\n          }, topLevelInfo);\n          mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);\n        }\n\n        return Utils.joinSQLFragments([\"SELECT TOP 100 PERCENT\", attributes.join(\", \"), \"FROM (\", [\"SELECT\", options.limit && `TOP ${options.limit}`, \"* FROM (\", [\"SELECT ROW_NUMBER() OVER (\", [\"ORDER BY\", orders.mainQueryOrder.join(\", \")], `) as row_num, ${tmpTable}.* FROM (`, [\"SELECT DISTINCT\", `${tmpTable}.* FROM ${tables} AS ${tmpTable}`, mainJoinQueries, where && `WHERE ${where}`], `) AS ${tmpTable}`], `) AS ${tmpTable} WHERE row_num > ${offset}`], `) AS ${tmpTable}`]);\n      }\n\n      return Utils.joinSQLFragments([\"SELECT TOP 100 PERCENT\", attributes.join(\", \"), \"FROM (\", [\"SELECT\", options.limit && `TOP ${options.limit}`, \"* FROM (\", [\"SELECT ROW_NUMBER() OVER (\", [\"ORDER BY\", orders.mainQueryOrder.join(\", \")], `) as row_num, * FROM ${tables} AS ${tmpTable}`, where && `WHERE ${where}`], `) AS ${tmpTable} WHERE row_num > ${offset}`], `) AS ${tmpTable}`]);\n    }\n\n    return Utils.joinSQLFragments([\"SELECT\", isSQLServer2008 && options.limit && `TOP ${options.limit}`, attributes.join(\", \"), `FROM ${tables}`, mainTableAs && `AS ${mainTableAs}`, options.tableHint && TableHints[options.tableHint] && `WITH (${TableHints[options.tableHint]})`]);\n  }\n\n  addLimitAndOffset(options, model) {\n    if (semver.valid(this.sequelize.options.databaseVersion) && semver.lt(this.sequelize.options.databaseVersion, \"11.0.0\")) {\n      return \"\";\n    }\n\n    const offset = options.offset || 0;\n    const isSubQuery = options.subQuery === void 0 ? options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation : options.subQuery;\n    let fragment = \"\";\n    let orders = {};\n\n    if (options.order) {\n      orders = this.getQueryOrders(options, model, isSubQuery);\n    }\n\n    if (options.limit || options.offset) {\n      if (!options.order || options.order.length === 0 || options.include && orders.subQueryOrder.length === 0) {\n        let primaryKey = model.primaryKeyField;\n        const tablePkFragment = `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(primaryKey)}`;\n        const aliasedAttribute = (options.attributes || []).find(attr => Array.isArray(attr) && attr[1] && (attr[0] === primaryKey || attr[1] === primaryKey));\n\n        if (aliasedAttribute) {\n          const modelName = this.quoteIdentifier(options.tableAs || model.name);\n\n          const alias = this._getAliasForField(modelName, aliasedAttribute[1], options);\n\n          primaryKey = new Utils.Col(alias || aliasedAttribute[1]);\n        }\n\n        if (!options.order || !options.order.length) {\n          fragment += ` ORDER BY ${tablePkFragment}`;\n        } else {\n          const orderFieldNames = (options.order || []).map(order => {\n            const value = Array.isArray(order) ? order[0] : order;\n\n            if (value instanceof Utils.Col) {\n              return value.col;\n            }\n\n            if (value instanceof Utils.Literal) {\n              return value.val;\n            }\n\n            return value;\n          });\n          const primaryKeyFieldAlreadyPresent = orderFieldNames.some(fieldName => fieldName === (primaryKey.col || primaryKey));\n\n          if (!primaryKeyFieldAlreadyPresent) {\n            fragment += options.order && !isSubQuery ? \", \" : \" ORDER BY \";\n            fragment += tablePkFragment;\n          }\n        }\n      }\n\n      if (options.offset || options.limit) {\n        fragment += ` OFFSET ${this.escape(offset)} ROWS`;\n      }\n\n      if (options.limit) {\n        fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n      }\n    }\n\n    return fragment;\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n\n  quoteIdentifier(identifier, force) {\n    return `[${identifier.replace(/[[\\]']+/g, \"\")}]`;\n  }\n\n}\n\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(Utils.removeTicks(identifier, \"'\"), \"'\");\n}\n\nmodule.exports = MSSQLQueryGenerator;","map":{"version":3,"mappings":"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","names":["_","require","Utils","DataTypes","TableHints","AbstractQueryGenerator","randomBytes","semver","Op","throwMethodUndefined","methodName","Error","createDatabaseQuery","databaseName","options","__spreadValues","collate","collation","escape","wrapSingleQuote","quoteIdentifier","join","dropDatabaseQuery","createSchema","schema","dropSchema","quotedSchema","showSchemasQuery","versionQuery","createTableQuery","tableName","attributes","primaryKeys","foreignKeys","attributesClauseParts","commentStr","attr","Object","prototype","hasOwnProperty","call","dataType","match","includes","commentMatch","commentText","replace","trim","commentTemplate","push","pkString","map","pk","uniqueKeys","each","columns","indexName","customIndex","fields","field","length","fkey","quotedTableName","quoteTable","joinSQLFragments","describeTableQuery","sql","renameTableQuery","before","after","showTablesQuery","tableExistsQuery","table","schemaName","dropTableQuery","quoteTbl","addColumnQuery","key","comment","isString","attributeToSQL","context","column","removeColumnQuery","attributeName","changeColumnQuery","attrString","constraintString","commentString","quotedAttrName","definition","renameColumnQuery","attrBefore","newName","keys","bulkInsertQuery","attrValueHashes","quotedTable","tuples","allAttributes","allQueries","needIdentityInsertWrapper","outputFragment","returning","returnValues","generateReturnValues","emptyQuery","forEach","attrValueHash","firstAttr","autoIncrement","forOwn","value","quotedAttributes","tupleStr","commands","offset","batch","Math","floor","max","slice","min","generatedQuery","v","updateQuery","where","limit","updateArgs","query","upsertQuery","insertValues","updateValues","model","targetTableAlias","sourceTableAlias","primaryKeysAttrs","identityAttrs","uniqueAttrs","tableNameQuoted","rawAttributes","primaryKey","unique","index","_indexes","fieldName","name","attribute","updateKeys","insertKeys","insertKeysQuoted","insertValuesEscaped","sourceTableQuery","joinCondition","clauses","or","filter","clause","valid","getJoinSnippet","array","filteredUpdateClauses","updateSnippet","insertSnippet","truncateTableQuery","deleteQuery","whereClause","getWhereConditions","showIndexesQuery","showConstraintsQuery","removeIndexQuery","indexNameOrAttributes","underscore","quoteIdentifiers","isPlainObject","type","references","Model","sequelize","log","onDelete","onUpdate","template","ENUM","values","toSql","toString","allowNull","defaultValueSchemable","defaultValue","_binary","withoutForeignKeyConstraints","toUpperCase","attributesToSQL","result","existingConstraints","createTrigger","dropTrigger","renameTrigger","createFunction","dropFunction","renameFunction","_getForeignKeysQueryPrefix","catalogName","getForeignKeysQuery","getForeignKeyQuery","getPrimaryKeyConstraintQuery","dropForeignKeyQuery","foreignKey","getDefaultConstraintQuery","dropConstraintQuery","constraintName","setIsolationLevelQuery","generateTransactionId","startTransactionQuery","transaction","parent","commitTransactionQuery","rollbackTransactionQuery","selectFromTableFragment","tables","mainTableAs","_throwOnEmptyAttributes","modelName","as","dbVersion","databaseVersion","isSQLServer2008","lt","isSubQuery","hasIncludeWhere","hasIncludeRequired","hasMultiAssociation","orders","mainQueryOrder","order","getQueryOrders","primaryKeyField","tmpTable","include","subQuery","mainTable","quotedName","topLevelInfo","names","mainJoinQueries","separate","joinQueries","generateInclude","externalAs","internalAs","concat","mainQuery","tableHint","addLimitAndOffset","fragment","subQueryOrder","tablePkFragment","tableAs","aliasedAttribute","find","Array","isArray","alias","_getAliasForField","Col","orderFieldNames","col","Literal","val","primaryKeyFieldAlreadyPresent","some","booleanValue","identifier","force","addTicks","removeTicks","module","exports","MSSQLQueryGenerator"],"sources":["/Users/aurele/node_modules/sequelize/src/dialects/mssql/query-generator.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst DataTypes = require('../../data-types');\nconst TableHints = require('../../table-hints');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\nconst randomBytes = require('crypto').randomBytes;\nconst semver = require('semver');\nconst Op = require('../../operators');\n\n/* istanbul ignore next */\nconst throwMethodUndefined = function(methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n};\n\nclass MSSQLQueryGenerator extends AbstractQueryGenerator {\n  createDatabaseQuery(databaseName, options) {\n    options = { collate: null, ...options };\n\n    const collation = options.collate ? `COLLATE ${this.escape(options.collate)}` : '';\n\n    return [\n      'IF NOT EXISTS (SELECT * FROM sys.databases WHERE name =', wrapSingleQuote(databaseName), ')',\n      'BEGIN',\n      'CREATE DATABASE', this.quoteIdentifier(databaseName),\n      `${collation};`,\n      'END;'\n    ].join(' ');\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return [\n      'IF EXISTS (SELECT * FROM sys.databases WHERE name =', wrapSingleQuote(databaseName), ')',\n      'BEGIN',\n      'DROP DATABASE', this.quoteIdentifier(databaseName), ';',\n      'END;'\n    ].join(' ');\n  }\n\n  createSchema(schema) {\n    return [\n      'IF NOT EXISTS (SELECT schema_name',\n      'FROM information_schema.schemata',\n      'WHERE schema_name =', wrapSingleQuote(schema), ')',\n      'BEGIN',\n      \"EXEC sp_executesql N'CREATE SCHEMA\",\n      this.quoteIdentifier(schema),\n      \";'\",\n      'END;'\n    ].join(' ');\n  }\n\n  dropSchema(schema) {\n    // Mimics Postgres CASCADE, will drop objects belonging to the schema\n    const quotedSchema = wrapSingleQuote(schema);\n    return [\n      'IF EXISTS (SELECT schema_name',\n      'FROM information_schema.schemata',\n      'WHERE schema_name =', quotedSchema, ')',\n      'BEGIN',\n      'DECLARE @id INT, @ms_sql NVARCHAR(2000);',\n      'DECLARE @cascade TABLE (',\n      'id INT NOT NULL IDENTITY PRIMARY KEY,',\n      'ms_sql NVARCHAR(2000) NOT NULL );',\n      'INSERT INTO @cascade ( ms_sql )',\n      \"SELECT CASE WHEN o.type IN ('F','PK')\",\n      \"THEN N'ALTER TABLE ['+ s.name + N'].[' + p.name + N'] DROP CONSTRAINT [' + o.name + N']'\",\n      \"ELSE N'DROP TABLE ['+ s.name + N'].[' + o.name + N']' END\",\n      'FROM sys.objects o',\n      'JOIN sys.schemas s on o.schema_id = s.schema_id',\n      'LEFT OUTER JOIN sys.objects p on o.parent_object_id = p.object_id',\n      \"WHERE o.type IN ('F', 'PK', 'U') AND s.name = \", quotedSchema,\n      'ORDER BY o.type ASC;',\n      'SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;',\n      'WHILE @id IS NOT NULL',\n      'BEGIN',\n      'BEGIN TRY EXEC sp_executesql @ms_sql; END TRY',\n      'BEGIN CATCH BREAK; THROW; END CATCH;',\n      'DELETE FROM @cascade WHERE id = @id;',\n      'SELECT @id = NULL, @ms_sql = NULL;',\n      'SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;',\n      'END',\n      \"EXEC sp_executesql N'DROP SCHEMA\", this.quoteIdentifier(schema), \";'\",\n      'END;'\n    ].join(' ');\n  }\n\n  showSchemasQuery() {\n    return [\n      'SELECT \"name\" as \"schema_name\" FROM sys.schemas as s',\n      'WHERE \"s\".\"name\" NOT IN (',\n      \"'INFORMATION_SCHEMA', 'dbo', 'guest', 'sys', 'archive'\",\n      ')', 'AND', '\"s\".\"name\" NOT LIKE', \"'db_%'\"\n    ].join(' ');\n  }\n\n  versionQuery() {\n    // Uses string manipulation to convert the MS Maj.Min.Patch.Build to semver Maj.Min.Patch\n    return [\n      'DECLARE @ms_ver NVARCHAR(20);',\n      \"SET @ms_ver = REVERSE(CONVERT(NVARCHAR(20), SERVERPROPERTY('ProductVersion')));\",\n      \"SELECT REVERSE(SUBSTRING(@ms_ver, CHARINDEX('.', @ms_ver)+1, 20)) AS 'version'\"\n    ].join(' ');\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    const primaryKeys = [],\n      foreignKeys = {},\n      attributesClauseParts = [];\n\n    let commentStr = '';\n\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        let dataType = attributes[attr];\n        let match;\n\n        if (dataType.includes('COMMENT ')) {\n          const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);\n          const commentText = commentMatch[2].replace('COMMENT', '').trim();\n          commentStr += this.commentTemplate(commentText, tableName, attr);\n          // remove comment related substring from dataType\n          dataType = commentMatch[1];\n        }\n\n        if (dataType.includes('PRIMARY KEY')) {\n          primaryKeys.push(attr);\n\n          if (dataType.includes('REFERENCES')) {\n            // MSSQL doesn't support inline REFERENCES declarations: move to the end\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);\n            foreignKeys[attr] = match[2];\n          } else {\n            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);\n          }\n        } else if (dataType.includes('REFERENCES')) {\n          // MSSQL doesn't support inline REFERENCES declarations: move to the end\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n        }\n      }\n    }\n\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== 'string') {\n            indexName = `uniq_${tableName}_${columns.fields.join('_')}`;\n          }\n          attributesClauseParts.push(`CONSTRAINT ${\n            this.quoteIdentifier(indexName)\n          } UNIQUE (${\n            columns.fields.map(field => this.quoteIdentifier(field)).join(', ')\n          })`);\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClauseParts.push(`PRIMARY KEY (${pkString})`);\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClauseParts.push(`FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`);\n      }\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n\n    return Utils.joinSQLFragments([\n      `IF OBJECT_ID('${quotedTableName}', 'U') IS NULL`,\n      `CREATE TABLE ${quotedTableName} (${attributesClauseParts.join(', ')})`,\n      ';',\n      commentStr\n    ]);\n  }\n\n  describeTableQuery(tableName, schema) {\n    let sql = [\n      'SELECT',\n      \"c.COLUMN_NAME AS 'Name',\",\n      \"c.DATA_TYPE AS 'Type',\",\n      \"c.CHARACTER_MAXIMUM_LENGTH AS 'Length',\",\n      \"c.IS_NULLABLE as 'IsNull',\",\n      \"COLUMN_DEFAULT AS 'Default',\",\n      \"pk.CONSTRAINT_TYPE AS 'Constraint',\",\n      \"COLUMNPROPERTY(OBJECT_ID(c.TABLE_SCHEMA+'.'+c.TABLE_NAME), c.COLUMN_NAME, 'IsIdentity') as 'IsIdentity',\",\n      \"CAST(prop.value AS NVARCHAR) AS 'Comment'\",\n      'FROM',\n      'INFORMATION_SCHEMA.TABLES t',\n      'INNER JOIN',\n      'INFORMATION_SCHEMA.COLUMNS c ON t.TABLE_NAME = c.TABLE_NAME AND t.TABLE_SCHEMA = c.TABLE_SCHEMA',\n      'LEFT JOIN (SELECT tc.table_schema, tc.table_name, ',\n      'cu.column_name, tc.CONSTRAINT_TYPE ',\n      'FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc ',\n      'JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE  cu ',\n      'ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name ',\n      'and tc.constraint_name=cu.constraint_name ',\n      'and tc.CONSTRAINT_TYPE=\\'PRIMARY KEY\\') pk ',\n      'ON pk.table_schema=c.table_schema ',\n      'AND pk.table_name=c.table_name ',\n      'AND pk.column_name=c.column_name ',\n      'INNER JOIN sys.columns AS sc',\n      \"ON sc.object_id = object_id(t.table_schema + '.' + t.table_name) AND sc.name = c.column_name\",\n      'LEFT JOIN sys.extended_properties prop ON prop.major_id = sc.object_id',\n      'AND prop.minor_id = sc.column_id',\n      \"AND prop.name = 'MS_Description'\",\n      'WHERE t.TABLE_NAME =', wrapSingleQuote(tableName)\n    ].join(' ');\n\n    if (schema) {\n      sql += `AND t.TABLE_SCHEMA =${wrapSingleQuote(schema)}`;\n    }\n\n    return sql;\n  }\n\n  renameTableQuery(before, after) {\n    return `EXEC sp_rename ${this.quoteTable(before)}, ${this.quoteTable(after)};`;\n  }\n\n  showTablesQuery() {\n    return \"SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE';\";\n  }\n\n  tableExistsQuery(table) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema || 'dbo';\n\n    return `SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = ${this.escape(tableName)} AND TABLE_SCHEMA = ${this.escape(schemaName)}`;\n  }\n\n  dropTableQuery(tableName) {\n    const quoteTbl = this.quoteTable(tableName);\n    return Utils.joinSQLFragments([\n      `IF OBJECT_ID('${quoteTbl}', 'U') IS NOT NULL`,\n      'DROP TABLE',\n      quoteTbl,\n      ';'\n    ]);\n  }\n\n  addColumnQuery(table, key, dataType) {\n    // FIXME: attributeToSQL SHOULD be using attributes in addColumnQuery\n    //        but instead we need to pass the key along as the field here\n    dataType.field = key;\n    let commentStr = '';\n\n    if (dataType.comment && _.isString(dataType.comment)) {\n      commentStr = this.commentTemplate(dataType.comment, table, key);\n      // attributeToSQL will try to include `COMMENT 'Comment Text'` when it returns if the comment key\n      // is present. This is needed for createTable statement where that part is extracted with regex.\n      // Here we can intercept the object and remove comment property since we have the original object.\n      delete dataType['comment'];\n    }\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(table),\n      'ADD',\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, { context: 'addColumn' }),\n      ';',\n      commentStr\n    ]);\n  }\n\n  commentTemplate(comment, table, column) {\n    return ' EXEC sp_addextendedproperty ' +\n        `@name = N'MS_Description', @value = ${this.escape(comment)}, ` +\n        '@level0type = N\\'Schema\\', @level0name = \\'dbo\\', ' +\n        `@level1type = N'Table', @level1name = ${this.quoteIdentifier(table)}, ` +\n        `@level2type = N'Column', @level2name = ${this.quoteIdentifier(column)};`;\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP COLUMN',\n      this.quoteIdentifier(attributeName),\n      ';'\n    ]);\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [],\n      constraintString = [];\n    let commentString = '';\n\n    for (const attributeName in attributes) {\n      const quotedAttrName = this.quoteIdentifier(attributeName);\n      let definition = attributes[attributeName];\n      if (definition.includes('COMMENT ')) {\n        const commentMatch = definition.match(/^(.+) (COMMENT.*)$/);\n        const commentText = commentMatch[2].replace('COMMENT', '').trim();\n        commentString += this.commentTemplate(commentText, tableName, attributeName);\n        // remove comment related substring from dataType\n        definition = commentMatch[1];\n      }\n      if (definition.includes('REFERENCES')) {\n        constraintString.push(`FOREIGN KEY (${quotedAttrName}) ${definition.replace(/.+?(?=REFERENCES)/, '')}`);\n      } else {\n        attrString.push(`${quotedAttrName} ${definition}`);\n      }\n    }\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      attrString.length && `ALTER COLUMN ${attrString.join(', ')}`,\n      constraintString.length && `ADD ${constraintString.join(', ')}`,\n      ';',\n      commentString\n    ]);\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const newName = Object.keys(attributes)[0];\n    return Utils.joinSQLFragments([\n      'EXEC sp_rename',\n      `'${this.quoteTable(tableName)}.${attrBefore}',`,\n      `'${newName}',`,\n      \"'COLUMN'\",\n      ';'\n    ]);\n  }\n\n  bulkInsertQuery(tableName, attrValueHashes, options, attributes) {\n    const quotedTable = this.quoteTable(tableName);\n    options = options || {};\n    attributes = attributes || {};\n\n    const tuples = [];\n    const allAttributes = [];\n    const allQueries = [];\n\n    let needIdentityInsertWrapper = false,\n      outputFragment = '';\n\n    if (options.returning) {\n      const returnValues = this.generateReturnValues(attributes, options);\n\n      outputFragment = returnValues.outputFragment;\n    }\n\n    const emptyQuery = `INSERT INTO ${quotedTable}${outputFragment} DEFAULT VALUES`;\n\n    attrValueHashes.forEach(attrValueHash => {\n      // special case for empty objects with primary keys\n      const fields = Object.keys(attrValueHash);\n      const firstAttr = attributes[fields[0]];\n      if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {\n        allQueries.push(emptyQuery);\n        return;\n      }\n\n      // normal case\n      _.forOwn(attrValueHash, (value, key) => {\n        if (value !== null && attributes[key] && attributes[key].autoIncrement) {\n          needIdentityInsertWrapper = true;\n        }\n\n        if (!allAttributes.includes(key)) {\n          if (value === null && attributes[key] && attributes[key].autoIncrement)\n            return;\n\n          allAttributes.push(key);\n        }\n      });\n    });\n\n    if (allAttributes.length > 0) {\n      attrValueHashes.forEach(attrValueHash => {\n        tuples.push(`(${\n          allAttributes.map(key =>\n            this.escape(attrValueHash[key])).join(',')\n        })`);\n      });\n\n      const quotedAttributes = allAttributes.map(attr => this.quoteIdentifier(attr)).join(',');\n      allQueries.push(tupleStr => `INSERT INTO ${quotedTable} (${quotedAttributes})${outputFragment} VALUES ${tupleStr};`);\n    }\n    const commands = [];\n    let offset = 0;\n    const batch = Math.floor(250 / (allAttributes.length + 1)) + 1;\n    while (offset < Math.max(tuples.length, 1)) {\n      const tupleStr = tuples.slice(offset, Math.min(tuples.length, offset + batch));\n      let generatedQuery = allQueries.map(v => typeof v === 'string' ? v : v(tupleStr)).join(';');\n      if (needIdentityInsertWrapper) {\n        generatedQuery = `SET IDENTITY_INSERT ${quotedTable} ON; ${generatedQuery}; SET IDENTITY_INSERT ${quotedTable} OFF;`;\n      }\n      commands.push(generatedQuery);\n      offset += batch;\n    }\n    return commands.join(';');\n  }\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);\n    if (options.limit) {\n      const updateArgs = `UPDATE TOP(${this.escape(options.limit)})`;\n      sql.query = sql.query.replace('UPDATE', updateArgs);\n    }\n    return sql;\n  }\n\n  upsertQuery(tableName, insertValues, updateValues, where, model) {\n    const targetTableAlias = this.quoteTable(`${tableName}_target`);\n    const sourceTableAlias = this.quoteTable(`${tableName}_source`);\n    const primaryKeysAttrs = [];\n    const identityAttrs = [];\n    const uniqueAttrs = [];\n    const tableNameQuoted = this.quoteTable(tableName);\n    let needIdentityInsertWrapper = false;\n\n    //Obtain primaryKeys, uniquekeys and identity attrs from rawAttributes as model is not passed\n    for (const key in model.rawAttributes) {\n      if (model.rawAttributes[key].primaryKey) {\n        primaryKeysAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].unique) {\n        uniqueAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].autoIncrement) {\n        identityAttrs.push(model.rawAttributes[key].field || key);\n      }\n    }\n\n    //Add unique indexes defined by indexes option to uniqueAttrs\n    for (const index of model._indexes) {\n      if (index.unique && index.fields) {\n        for (const field of index.fields) {\n          const fieldName = typeof field === 'string' ? field : field.name || field.attribute;\n          if (!uniqueAttrs.includes(fieldName) && model.rawAttributes[fieldName]) {\n            uniqueAttrs.push(fieldName);\n          }\n        }\n      }\n    }\n\n    const updateKeys = Object.keys(updateValues);\n    const insertKeys = Object.keys(insertValues);\n    const insertKeysQuoted = insertKeys.map(key => this.quoteIdentifier(key)).join(', ');\n    const insertValuesEscaped = insertKeys.map(key => this.escape(insertValues[key])).join(', ');\n    const sourceTableQuery = `VALUES(${insertValuesEscaped})`; //Virtual Table\n    let joinCondition;\n\n    //IDENTITY_INSERT Condition\n    identityAttrs.forEach(key => {\n      if (insertValues[key] && insertValues[key] !== null) {\n        needIdentityInsertWrapper = true;\n        /*\n         * IDENTITY_INSERT Column Cannot be updated, only inserted\n         * http://stackoverflow.com/a/30176254/2254360\n         */\n      }\n    });\n\n    //Filter NULL Clauses\n    const clauses = where[Op.or].filter(clause => {\n      let valid = true;\n      /*\n       * Exclude NULL Composite PK/UK. Partial Composite clauses should also be excluded as it doesn't guarantee a single row\n       */\n      for (const key in clause) {\n        if (typeof clause[key] === 'undefined' || clause[key] == null) {\n          valid = false;\n          break;\n        }\n      }\n      return valid;\n    });\n\n    /*\n     * Generate ON condition using PK(s).\n     * If not, generate using UK(s). Else throw error\n     */\n    const getJoinSnippet = array => {\n      return array.map(key => {\n        key = this.quoteIdentifier(key);\n        return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;\n      });\n    };\n\n    if (clauses.length === 0) {\n      throw new Error('Primary Key or Unique key should be passed to upsert query');\n    } else {\n      // Search for primary key attribute in clauses -- Model can have two separate unique keys\n      for (const key in clauses) {\n        const keys = Object.keys(clauses[key]);\n        if (primaryKeysAttrs.includes(keys[0])) {\n          joinCondition = getJoinSnippet(primaryKeysAttrs).join(' AND ');\n          break;\n        }\n      }\n      if (!joinCondition) {\n        joinCondition = getJoinSnippet(uniqueAttrs).join(' AND ');\n      }\n    }\n\n    // Remove the IDENTITY_INSERT Column from update\n    const filteredUpdateClauses = updateKeys.filter(key => !identityAttrs.includes(key))\n      .map(key => {\n        const value = this.escape(updateValues[key]);\n        key = this.quoteIdentifier(key);\n        return `${targetTableAlias}.${key} = ${value}`;\n      });\n    const updateSnippet = filteredUpdateClauses.length > 0 ? `WHEN MATCHED THEN UPDATE SET ${filteredUpdateClauses.join(', ')}` : '';\n\n    const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;\n\n    let query = `MERGE INTO ${tableNameQuoted} WITH(HOLDLOCK) AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;\n    query += ` ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet} OUTPUT $action, INSERTED.*;`;\n    if (needIdentityInsertWrapper) {\n      query = `SET IDENTITY_INSERT ${tableNameQuoted} ON; ${query} SET IDENTITY_INSERT ${tableNameQuoted} OFF;`;\n    }\n    return query;\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    const whereClause = this.getWhereConditions(where, null, model, options);\n\n    return Utils.joinSQLFragments([\n      'DELETE',\n      options.limit && `TOP(${this.escape(options.limit)})`,\n      'FROM',\n      table,\n      whereClause && `WHERE ${whereClause}`,\n      ';',\n      'SELECT @@ROWCOUNT AS AFFECTEDROWS',\n      ';'\n    ]);\n  }\n\n  showIndexesQuery(tableName) {\n    return `EXEC sys.sp_helpindex @objname = N'${this.quoteTable(tableName)}';`;\n  }\n\n  showConstraintsQuery(tableName) {\n    return `EXEC sp_helpconstraint @objname = ${this.escape(this.quoteTable(tableName))};`;\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX ${this.quoteIdentifiers(indexName)} ON ${this.quoteIdentifiers(tableName)}`;\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    // handle self referential constraints\n    if (attribute.references) {\n\n      if (attribute.Model && attribute.Model.tableName === attribute.references.model) {\n        this.sequelize.log('MSSQL does not support self referencial constraints, '\n          + 'we will remove it but we recommend restructuring your query');\n        attribute.onDelete = '';\n        attribute.onUpdate = '';\n      }\n    }\n\n    let template;\n\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;\n\n      // enums are a special case\n      template = attribute.type.toSql();\n      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.values.map(value => {\n        return this.escape(value);\n      }).join(', ') }))`;\n      return template;\n    }\n    template = attribute.type.toString();\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ' NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' IDENTITY(1,1)';\n    }\n\n    // Blobs/texts cannot have a defaultValue\n    if (attribute.type !== 'TEXT' && attribute.type._binary !== true &&\n        Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier('id')})`;\n      }\n\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n\n    if (attribute.comment && typeof attribute.comment === 'string') {\n      template += ` COMMENT ${attribute.comment}`;\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {},\n      existingConstraints = [];\n    let key,\n      attribute;\n\n    for (key in attributes) {\n      attribute = attributes[key];\n\n      if (attribute.references) {\n        if (existingConstraints.includes(attribute.references.model.toString())) {\n          // no cascading constraints to a table more than once\n          attribute.onDelete = '';\n          attribute.onUpdate = '';\n        } else {\n          existingConstraints.push(attribute.references.model.toString());\n\n          // NOTE: this really just disables cascading updates for all\n          //       definitions. Can be made more robust to support the\n          //       few cases where MSSQL actually supports them\n          attribute.onUpdate = '';\n        }\n\n      }\n\n      if (key && !attribute.field) attribute.field = key;\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n\n  createTrigger() {\n    throwMethodUndefined('createTrigger');\n  }\n\n  dropTrigger() {\n    throwMethodUndefined('dropTrigger');\n  }\n\n  renameTrigger() {\n    throwMethodUndefined('renameTrigger');\n  }\n\n  createFunction() {\n    throwMethodUndefined('createFunction');\n  }\n\n  dropFunction() {\n    throwMethodUndefined('dropFunction');\n  }\n\n  renameFunction() {\n    throwMethodUndefined('renameFunction');\n  }\n\n  /**\n   * Generate common SQL prefix for ForeignKeysQuery.\n   *\n   * @param {string} catalogName\n   * @returns {string}\n   */\n  _getForeignKeysQueryPrefix(catalogName) {\n    return `${'SELECT ' +\n        'constraint_name = OBJ.NAME, ' +\n        'constraintName = OBJ.NAME, '}${\n      catalogName ? `constraintCatalog = '${catalogName}', ` : ''\n    }constraintSchema = SCHEMA_NAME(OBJ.SCHEMA_ID), ` +\n        'tableName = TB.NAME, ' +\n        `tableSchema = SCHEMA_NAME(TB.SCHEMA_ID), ${\n          catalogName ? `tableCatalog = '${catalogName}', ` : ''\n        }columnName = COL.NAME, ` +\n        `referencedTableSchema = SCHEMA_NAME(RTB.SCHEMA_ID), ${\n          catalogName ? `referencedCatalog = '${catalogName}', ` : ''\n        }referencedTableName = RTB.NAME, ` +\n        'referencedColumnName = RCOL.NAME ' +\n      'FROM sys.foreign_key_columns FKC ' +\n        'INNER JOIN sys.objects OBJ ON OBJ.OBJECT_ID = FKC.CONSTRAINT_OBJECT_ID ' +\n        'INNER JOIN sys.tables TB ON TB.OBJECT_ID = FKC.PARENT_OBJECT_ID ' +\n        'INNER JOIN sys.columns COL ON COL.COLUMN_ID = PARENT_COLUMN_ID AND COL.OBJECT_ID = TB.OBJECT_ID ' +\n        'INNER JOIN sys.tables RTB ON RTB.OBJECT_ID = FKC.REFERENCED_OBJECT_ID ' +\n        'INNER JOIN sys.columns RCOL ON RCOL.COLUMN_ID = REFERENCED_COLUMN_ID AND RCOL.OBJECT_ID = RTB.OBJECT_ID';\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys details of a table.\n   *\n   * @param {string|object} table\n   * @param {string} catalogName database name\n   * @returns {string}\n   */\n  getForeignKeysQuery(table, catalogName) {\n    const tableName = table.tableName || table;\n    let sql = `${this._getForeignKeysQueryPrefix(catalogName)\n    } WHERE TB.NAME =${wrapSingleQuote(tableName)}`;\n\n    if (table.schema) {\n      sql += ` AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`;\n    }\n    return sql;\n  }\n\n  getForeignKeyQuery(table, attributeName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments([\n      this._getForeignKeysQueryPrefix(),\n      'WHERE',\n      `TB.NAME =${wrapSingleQuote(tableName)}`,\n      'AND',\n      `COL.NAME =${wrapSingleQuote(attributeName)}`,\n      table.schema && `AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`\n    ]);\n  }\n\n  getPrimaryKeyConstraintQuery(table, attributeName) {\n    const tableName = wrapSingleQuote(table.tableName || table);\n    return Utils.joinSQLFragments([\n      'SELECT K.TABLE_NAME AS tableName,',\n      'K.COLUMN_NAME AS columnName,',\n      'K.CONSTRAINT_NAME AS constraintName',\n      'FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS C',\n      'JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS K',\n      'ON C.TABLE_NAME = K.TABLE_NAME',\n      'AND C.CONSTRAINT_CATALOG = K.CONSTRAINT_CATALOG',\n      'AND C.CONSTRAINT_SCHEMA = K.CONSTRAINT_SCHEMA',\n      'AND C.CONSTRAINT_NAME = K.CONSTRAINT_NAME',\n      'WHERE C.CONSTRAINT_TYPE = \\'PRIMARY KEY\\'',\n      `AND K.COLUMN_NAME = ${wrapSingleQuote(attributeName)}`,\n      `AND K.TABLE_NAME = ${tableName}`,\n      ';'\n    ]);\n  }\n\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP',\n      this.quoteIdentifier(foreignKey)\n    ]);\n  }\n\n  getDefaultConstraintQuery(tableName, attributeName) {\n    const quotedTable = this.quoteTable(tableName);\n    return Utils.joinSQLFragments([\n      'SELECT name FROM sys.default_constraints',\n      `WHERE PARENT_OBJECT_ID = OBJECT_ID('${quotedTable}', 'U')`,\n      `AND PARENT_COLUMN_ID = (SELECT column_id FROM sys.columns WHERE NAME = ('${attributeName}')`,\n      `AND object_id = OBJECT_ID('${quotedTable}', 'U'))`,\n      ';'\n    ]);\n  }\n\n  dropConstraintQuery(tableName, constraintName) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP CONSTRAINT',\n      this.quoteIdentifier(constraintName),\n      ';'\n    ]);\n  }\n\n  setIsolationLevelQuery() {\n\n  }\n\n  generateTransactionId() {\n    return randomBytes(10).toString('hex');\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return 'BEGIN TRANSACTION;';\n  }\n\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n\n    return 'COMMIT TRANSACTION;';\n  }\n\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return 'ROLLBACK TRANSACTION;';\n  }\n\n  selectFromTableFragment(options, model, attributes, tables, mainTableAs, where) {\n    this._throwOnEmptyAttributes(attributes, { modelName: model && model.name, as: mainTableAs });\n\n    const dbVersion = this.sequelize.options.databaseVersion;\n    const isSQLServer2008 = semver.valid(dbVersion) && semver.lt(dbVersion, '11.0.0');\n\n    if (isSQLServer2008 && options.offset) {\n      // For earlier versions of SQL server, we need to nest several queries\n      // in order to emulate the OFFSET behavior.\n      //\n      // 1. The outermost query selects all items from the inner query block.\n      //    This is due to a limitation in SQL server with the use of computed\n      //    columns (e.g. SELECT ROW_NUMBER()...AS x) in WHERE clauses.\n      // 2. The next query handles the LIMIT and OFFSET behavior by getting\n      //    the TOP N rows of the query where the row number is > OFFSET\n      // 3. The innermost query is the actual set we want information from\n\n      const offset = options.offset || 0;\n      const isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n      let orders = { mainQueryOrder: [] };\n      if (options.order) {\n        orders = this.getQueryOrders(options, model, isSubQuery);\n      }\n\n      if (orders.mainQueryOrder.length === 0) {\n        orders.mainQueryOrder.push(this.quoteIdentifier(model.primaryKeyField));\n      }\n\n      const tmpTable = mainTableAs || 'OffsetTable';\n\n      if (options.include) {\n        const subQuery = options.subQuery === undefined ? options.limit && options.hasMultiAssociation : options.subQuery;\n        const mainTable = {\n          name: mainTableAs,\n          quotedName: null,\n          as: null,\n          model\n        };\n        const topLevelInfo = {\n          names: mainTable,\n          options,\n          subQuery\n        };\n\n        let mainJoinQueries = [];\n        for (const include of options.include) {\n          if (include.separate) {\n            continue;\n          }\n          const joinQueries = this.generateInclude(include, { externalAs: mainTableAs, internalAs: mainTableAs }, topLevelInfo);\n          mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);\n        }\n\n        return Utils.joinSQLFragments([\n          'SELECT TOP 100 PERCENT',\n          attributes.join(', '),\n          'FROM (',\n          [\n            'SELECT',\n            options.limit && `TOP ${options.limit}`,\n            '* FROM (',\n            [\n              'SELECT ROW_NUMBER() OVER (',\n              [\n                'ORDER BY',\n                orders.mainQueryOrder.join(', ')\n              ],\n              `) as row_num, ${tmpTable}.* FROM (`,\n              [\n                'SELECT DISTINCT',\n                `${tmpTable}.* FROM ${tables} AS ${tmpTable}`,\n                mainJoinQueries,\n                where && `WHERE ${where}`\n              ],\n              `) AS ${tmpTable}`\n            ],\n            `) AS ${tmpTable} WHERE row_num > ${offset}`\n          ],\n          `) AS ${tmpTable}`\n        ]);\n      }\n      return Utils.joinSQLFragments([\n        'SELECT TOP 100 PERCENT',\n        attributes.join(', '),\n        'FROM (',\n        [\n          'SELECT',\n          options.limit && `TOP ${options.limit}`,\n          '* FROM (',\n          [\n            'SELECT ROW_NUMBER() OVER (',\n            [\n              'ORDER BY',\n              orders.mainQueryOrder.join(', ')\n            ],\n            `) as row_num, * FROM ${tables} AS ${tmpTable}`,\n            where && `WHERE ${where}`\n          ],\n          `) AS ${tmpTable} WHERE row_num > ${offset}`\n        ],\n        `) AS ${tmpTable}`\n      ]);\n    }\n\n    return Utils.joinSQLFragments([\n      'SELECT',\n      isSQLServer2008 && options.limit && `TOP ${options.limit}`,\n      attributes.join(', '),\n      `FROM ${tables}`,\n      mainTableAs && `AS ${mainTableAs}`,\n      options.tableHint && TableHints[options.tableHint] && `WITH (${TableHints[options.tableHint]})`\n    ]);\n  }\n\n  addLimitAndOffset(options, model) {\n    // Skip handling of limit and offset as postfixes for older SQL Server versions\n    if (semver.valid(this.sequelize.options.databaseVersion) && semver.lt(this.sequelize.options.databaseVersion, '11.0.0')) {\n      return '';\n    }\n\n    const offset = options.offset || 0;\n    const isSubQuery = options.subQuery === undefined\n      ? options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation\n      : options.subQuery;\n\n    let fragment = '';\n    let orders = {};\n\n    if (options.order) {\n      orders = this.getQueryOrders(options, model, isSubQuery);\n    }\n\n    if (options.limit || options.offset) {\n      // TODO: document why this is adding the primary key of the model in ORDER BY\n      //  if options.include is set\n      if (!options.order || options.order.length === 0 || options.include && orders.subQueryOrder.length === 0) {\n        let primaryKey = model.primaryKeyField;\n\n        const tablePkFragment = `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(primaryKey)}`;\n        const aliasedAttribute = (options.attributes || []).find(attr => Array.isArray(attr)\n            && attr[1]\n            && (attr[0] === primaryKey || attr[1] === primaryKey));\n\n        if (aliasedAttribute) {\n          const modelName = this.quoteIdentifier(options.tableAs || model.name);\n          const alias = this._getAliasForField(modelName, aliasedAttribute[1], options);\n\n          primaryKey = new Utils.Col(alias || aliasedAttribute[1]);\n        }\n\n        if (!options.order || !options.order.length) {\n          fragment += ` ORDER BY ${tablePkFragment}`;\n        } else {\n          const orderFieldNames = (options.order || []).map(order => {\n            const value = Array.isArray(order) ? order[0] : order;\n\n            if (value instanceof Utils.Col) {\n              return value.col;\n            }\n\n            if (value instanceof Utils.Literal) {\n              return value.val;\n            }\n\n            return value;\n          });\n          const primaryKeyFieldAlreadyPresent = orderFieldNames.some(\n            fieldName => fieldName === (primaryKey.col || primaryKey)\n          );\n\n          if (!primaryKeyFieldAlreadyPresent) {\n            fragment += options.order && !isSubQuery ? ', ' : ' ORDER BY ';\n            fragment += tablePkFragment;\n          }\n        }\n      }\n\n      if (options.offset || options.limit) {\n        fragment += ` OFFSET ${this.escape(offset)} ROWS`;\n      }\n\n      if (options.limit) {\n        fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n      }\n    }\n\n    return fragment;\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n\n  /**\n   * Quote identifier in sql clause\n   *\n   * @param {string} identifier\n   * @param {boolean} force\n   *\n   * @returns {string}\n   */\n  quoteIdentifier(identifier, force) {\n    return `[${identifier.replace(/[[\\]']+/g, '')}]`;\n  }\n}\n\n// private methods\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(Utils.removeTicks(identifier, \"'\"), \"'\");\n}\n\nmodule.exports = MSSQLQueryGenerator;\n"]},"metadata":{},"sourceType":"script"}