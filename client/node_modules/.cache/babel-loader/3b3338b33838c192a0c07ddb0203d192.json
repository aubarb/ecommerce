{"ast":null,"code":"'use strict'; // XXX: This shares a lot in common with extract.js\n// maybe some DRY opportunity here?\n// tar -t\n\nconst hlo = require('./high-level-opt.js');\n\nconst Parser = require('./parse.js');\n\nconst fs = require('fs');\n\nconst fsm = require('fs-minipass');\n\nconst path = require('path');\n\nconst stripSlash = require('./strip-trailing-slashes.js');\n\nmodule.exports = (opt_, files, cb) => {\n  if (typeof opt_ === 'function') {\n    cb = opt_, files = null, opt_ = {};\n  } else if (Array.isArray(opt_)) {\n    files = opt_, opt_ = {};\n  }\n\n  if (typeof files === 'function') {\n    cb = files, files = null;\n  }\n\n  if (!files) {\n    files = [];\n  } else {\n    files = Array.from(files);\n  }\n\n  const opt = hlo(opt_);\n\n  if (opt.sync && typeof cb === 'function') {\n    throw new TypeError('callback not supported for sync tar functions');\n  }\n\n  if (!opt.file && typeof cb === 'function') {\n    throw new TypeError('callback only supported with file option');\n  }\n\n  if (files.length) {\n    filesFilter(opt, files);\n  }\n\n  if (!opt.noResume) {\n    onentryFunction(opt);\n  }\n\n  return opt.file && opt.sync ? listFileSync(opt) : opt.file ? listFile(opt, cb) : list(opt);\n};\n\nconst onentryFunction = opt => {\n  const onentry = opt.onentry;\n  opt.onentry = onentry ? e => {\n    onentry(e);\n    e.resume();\n  } : e => e.resume();\n}; // construct a filter that limits the file entries listed\n// include child entries if a dir is included\n\n\nconst filesFilter = (opt, files) => {\n  const map = new Map(files.map(f => [stripSlash(f), true]));\n  const filter = opt.filter;\n\n  const mapHas = (file, r) => {\n    const root = r || path.parse(file).root || '.';\n    const ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path.dirname(file), root);\n    map.set(file, ret);\n    return ret;\n  };\n\n  opt.filter = filter ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file)) : file => mapHas(stripSlash(file));\n};\n\nconst listFileSync = opt => {\n  const p = list(opt);\n  const file = opt.file;\n  let threw = true;\n  let fd;\n\n  try {\n    const stat = fs.statSync(file);\n    const readSize = opt.maxReadSize || 16 * 1024 * 1024;\n\n    if (stat.size < readSize) {\n      p.end(fs.readFileSync(file));\n    } else {\n      let pos = 0;\n      const buf = Buffer.allocUnsafe(readSize);\n      fd = fs.openSync(file, 'r');\n\n      while (pos < stat.size) {\n        const bytesRead = fs.readSync(fd, buf, 0, readSize, pos);\n        pos += bytesRead;\n        p.write(buf.slice(0, bytesRead));\n      }\n\n      p.end();\n    }\n\n    threw = false;\n  } finally {\n    if (threw && fd) {\n      try {\n        fs.closeSync(fd);\n      } catch (er) {}\n    }\n  }\n};\n\nconst listFile = (opt, cb) => {\n  const parse = new Parser(opt);\n  const readSize = opt.maxReadSize || 16 * 1024 * 1024;\n  const file = opt.file;\n  const p = new Promise((resolve, reject) => {\n    parse.on('error', reject);\n    parse.on('end', resolve);\n    fs.stat(file, (er, stat) => {\n      if (er) {\n        reject(er);\n      } else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size\n        });\n        stream.on('error', reject);\n        stream.pipe(parse);\n      }\n    });\n  });\n  return cb ? p.then(cb, cb) : p;\n};\n\nconst list = opt => new Parser(opt);","map":{"version":3,"names":["hlo","require","Parser","fs","fsm","path","stripSlash","module","exports","opt_","files","cb","Array","isArray","from","opt","sync","TypeError","file","length","filesFilter","noResume","onentryFunction","listFileSync","listFile","list","onentry","e","resume","map","Map","f","filter","mapHas","r","root","parse","ret","has","get","dirname","set","entry","p","threw","fd","stat","statSync","readSize","maxReadSize","size","end","readFileSync","pos","buf","Buffer","allocUnsafe","openSync","bytesRead","readSync","write","slice","closeSync","er","Promise","resolve","reject","on","stream","ReadStream","pipe","then"],"sources":["/Users/aurele/Desktop/E-Commerce App/views/node_modules/tar/lib/list.js"],"sourcesContent":["'use strict'\n\n// XXX: This shares a lot in common with extract.js\n// maybe some DRY opportunity here?\n\n// tar -t\nconst hlo = require('./high-level-opt.js')\nconst Parser = require('./parse.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst path = require('path')\nconst stripSlash = require('./strip-trailing-slashes.js')\n\nmodule.exports = (opt_, files, cb) => {\n  if (typeof opt_ === 'function') {\n    cb = opt_, files = null, opt_ = {}\n  } else if (Array.isArray(opt_)) {\n    files = opt_, opt_ = {}\n  }\n\n  if (typeof files === 'function') {\n    cb = files, files = null\n  }\n\n  if (!files) {\n    files = []\n  } else {\n    files = Array.from(files)\n  }\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function') {\n    throw new TypeError('callback not supported for sync tar functions')\n  }\n\n  if (!opt.file && typeof cb === 'function') {\n    throw new TypeError('callback only supported with file option')\n  }\n\n  if (files.length) {\n    filesFilter(opt, files)\n  }\n\n  if (!opt.noResume) {\n    onentryFunction(opt)\n  }\n\n  return opt.file && opt.sync ? listFileSync(opt)\n    : opt.file ? listFile(opt, cb)\n    : list(opt)\n}\n\nconst onentryFunction = opt => {\n  const onentry = opt.onentry\n  opt.onentry = onentry ? e => {\n    onentry(e)\n    e.resume()\n  } : e => e.resume()\n}\n\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n  const map = new Map(files.map(f => [stripSlash(f), true]))\n  const filter = opt.filter\n\n  const mapHas = (file, r) => {\n    const root = r || path.parse(file).root || '.'\n    const ret = file === root ? false\n      : map.has(file) ? map.get(file)\n      : mapHas(path.dirname(file), root)\n\n    map.set(file, ret)\n    return ret\n  }\n\n  opt.filter = filter\n    ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file))\n    : file => mapHas(stripSlash(file))\n}\n\nconst listFileSync = opt => {\n  const p = list(opt)\n  const file = opt.file\n  let threw = true\n  let fd\n  try {\n    const stat = fs.statSync(file)\n    const readSize = opt.maxReadSize || 16 * 1024 * 1024\n    if (stat.size < readSize) {\n      p.end(fs.readFileSync(file))\n    } else {\n      let pos = 0\n      const buf = Buffer.allocUnsafe(readSize)\n      fd = fs.openSync(file, 'r')\n      while (pos < stat.size) {\n        const bytesRead = fs.readSync(fd, buf, 0, readSize, pos)\n        pos += bytesRead\n        p.write(buf.slice(0, bytesRead))\n      }\n      p.end()\n    }\n    threw = false\n  } finally {\n    if (threw && fd) {\n      try {\n        fs.closeSync(fd)\n      } catch (er) {}\n    }\n  }\n}\n\nconst listFile = (opt, cb) => {\n  const parse = new Parser(opt)\n  const readSize = opt.maxReadSize || 16 * 1024 * 1024\n\n  const file = opt.file\n  const p = new Promise((resolve, reject) => {\n    parse.on('error', reject)\n    parse.on('end', resolve)\n\n    fs.stat(file, (er, stat) => {\n      if (er) {\n        reject(er)\n      } else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size,\n        })\n        stream.on('error', reject)\n        stream.pipe(parse)\n      }\n    })\n  })\n  return cb ? p.then(cb, cb) : p\n}\n\nconst list = opt => new Parser(opt)\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}