{"ast":null,"code":"\"use strict\";\n\nconst {\n  Pool,\n  TimeoutError\n} = require(\"sequelize-pool\");\n\nconst _ = require(\"lodash\");\n\nconst semver = require(\"semver\");\n\nconst errors = require(\"../../errors\");\n\nconst {\n  logger\n} = require(\"../../utils/logger\");\n\nconst deprecations = require(\"../../utils/deprecations\");\n\nconst debug = logger.debugContext(\"pool\");\n\nclass ConnectionManager {\n  constructor(dialect, sequelize) {\n    const config = _.cloneDeep(sequelize.config);\n\n    this.sequelize = sequelize;\n    this.config = config;\n    this.dialect = dialect;\n    this.versionPromise = null;\n    this.dialectName = this.sequelize.options.dialect;\n\n    if (config.pool === false) {\n      throw new Error(\"Support for pool:false was removed in v4.0\");\n    }\n\n    config.pool = _.defaults(config.pool || {}, {\n      max: 5,\n      min: 0,\n      idle: 1e4,\n      acquire: 6e4,\n      evict: 1e3,\n      validate: this._validate.bind(this)\n    });\n    this.initPools();\n  }\n\n  refreshTypeParser(dataTypes) {\n    _.each(dataTypes, dataType => {\n      if (Object.prototype.hasOwnProperty.call(dataType, \"parse\")) {\n        if (dataType.types[this.dialectName]) {\n          this._refreshTypeParser(dataType);\n        } else {\n          throw new Error(`Parse function not supported for type ${dataType.key} in dialect ${this.dialectName}`);\n        }\n      }\n    });\n  }\n\n  _loadDialectModule(moduleName) {\n    try {\n      if (this.sequelize.config.dialectModulePath) {\n        return require(this.sequelize.config.dialectModulePath);\n      }\n\n      if (this.sequelize.config.dialectModule) {\n        return this.sequelize.config.dialectModule;\n      }\n\n      return require(moduleName);\n    } catch (err) {\n      if (err.code === \"MODULE_NOT_FOUND\") {\n        if (this.sequelize.config.dialectModulePath) {\n          throw new Error(`Unable to find dialect at ${this.sequelize.config.dialectModulePath}`);\n        }\n\n        throw new Error(`Please install ${moduleName} package manually`);\n      }\n\n      throw err;\n    }\n  }\n\n  async _onProcessExit() {\n    if (!this.pool) {\n      return;\n    }\n\n    await this.pool.drain();\n    debug(\"connection drain due to process exit\");\n    return await this.pool.destroyAllNow();\n  }\n\n  async close() {\n    this.getConnection = async function getConnection() {\n      throw new Error(\"ConnectionManager.getConnection was called after the connection manager was closed!\");\n    };\n\n    return await this._onProcessExit();\n  }\n\n  initPools() {\n    const config = this.config;\n\n    if (!config.replication) {\n      this.pool = new Pool({\n        name: \"sequelize\",\n        create: () => this._connect(config),\n        destroy: async connection => {\n          const result = await this._disconnect(connection);\n          debug(\"connection destroy\");\n          return result;\n        },\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      });\n      debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, no replication`);\n      return;\n    }\n\n    if (!Array.isArray(config.replication.read)) {\n      config.replication.read = [config.replication.read];\n    }\n\n    config.replication.write = _.defaults(config.replication.write, _.omit(config, \"replication\"));\n    config.replication.read = config.replication.read.map(readConfig => _.defaults(readConfig, _.omit(this.config, \"replication\")));\n    let reads = 0;\n    this.pool = {\n      release: client => {\n        if (client.queryType === \"read\") {\n          this.pool.read.release(client);\n        } else {\n          this.pool.write.release(client);\n        }\n      },\n      acquire: (queryType, useMaster) => {\n        useMaster = useMaster === void 0 ? false : useMaster;\n\n        if (queryType === \"SELECT\" && !useMaster) {\n          return this.pool.read.acquire();\n        }\n\n        return this.pool.write.acquire();\n      },\n      destroy: connection => {\n        this.pool[connection.queryType].destroy(connection);\n        debug(\"connection destroy\");\n      },\n      destroyAllNow: async () => {\n        await Promise.all([this.pool.read.destroyAllNow(), this.pool.write.destroyAllNow()]);\n        debug(\"all connections destroyed\");\n      },\n      drain: async () => Promise.all([this.pool.write.drain(), this.pool.read.drain()]),\n      read: new Pool({\n        name: \"sequelize:read\",\n        create: async () => {\n          const nextRead = reads++ % config.replication.read.length;\n          const connection = await this._connect(config.replication.read[nextRead]);\n          connection.queryType = \"read\";\n          return connection;\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      }),\n      write: new Pool({\n        name: \"sequelize:write\",\n        create: async () => {\n          const connection = await this._connect(config.replication.write);\n          connection.queryType = \"write\";\n          return connection;\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      })\n    };\n    debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, with replication`);\n  }\n\n  async getConnection(options) {\n    options = options || {};\n\n    if (this.sequelize.options.databaseVersion === 0) {\n      if (!this.versionPromise) {\n        this.versionPromise = (async () => {\n          try {\n            const connection = await this._connect(this.config.replication.write || this.config);\n            const _options = {};\n            _options.transaction = {\n              connection\n            };\n\n            _options.logging = () => {};\n\n            _options.logging.__testLoggingFn = true;\n\n            if (this.sequelize.options.databaseVersion === 0) {\n              const version = await this.sequelize.databaseVersion(_options);\n              const parsedVersion = _.get(semver.coerce(version), \"version\") || version;\n              this.sequelize.options.databaseVersion = semver.valid(parsedVersion) ? parsedVersion : this.dialect.defaultVersion;\n            }\n\n            if (semver.lt(this.sequelize.options.databaseVersion, this.dialect.defaultVersion)) {\n              deprecations.unsupportedEngine();\n              debug(`Unsupported database engine version ${this.sequelize.options.databaseVersion}`);\n            }\n\n            this.versionPromise = null;\n            return await this._disconnect(connection);\n          } catch (err) {\n            this.versionPromise = null;\n            throw err;\n          }\n        })();\n      }\n\n      await this.versionPromise;\n    }\n\n    let result;\n\n    try {\n      result = await this.pool.acquire(options.type, options.useMaster);\n    } catch (error) {\n      if (error instanceof TimeoutError) throw new errors.ConnectionAcquireTimeoutError(error);\n      throw error;\n    }\n\n    debug(\"connection acquired\");\n    return result;\n  }\n\n  releaseConnection(connection) {\n    this.pool.release(connection);\n    debug(\"connection released\");\n  }\n\n  async destroyConnection(connection) {\n    await this.pool.destroy(connection);\n    debug(`connection ${connection.uuid} destroyed`);\n  }\n\n  async _connect(config) {\n    await this.sequelize.runHooks(\"beforeConnect\", config);\n    const connection = await this.dialect.connectionManager.connect(config);\n    await this.sequelize.runHooks(\"afterConnect\", connection, config);\n    return connection;\n  }\n\n  async _disconnect(connection) {\n    await this.sequelize.runHooks(\"beforeDisconnect\", connection);\n    await this.dialect.connectionManager.disconnect(connection);\n    return this.sequelize.runHooks(\"afterDisconnect\", connection);\n  }\n\n  _validate(connection) {\n    if (!this.dialect.connectionManager.validate) {\n      return true;\n    }\n\n    return this.dialect.connectionManager.validate(connection);\n  }\n\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"mappings":"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","names":["Pool","TimeoutError","require","_","semver","errors","logger","deprecations","debug","debugContext","constructor","dialect","sequelize","config","cloneDeep","versionPromise","dialectName","options","pool","Error","defaults","max","min","idle","acquire","evict","validate","_validate","bind","initPools","refreshTypeParser","dataTypes","each","dataType","Object","prototype","hasOwnProperty","call","types","_refreshTypeParser","key","_loadDialectModule","moduleName","dialectModulePath","dialectModule","err","code","drain","destroyAllNow","getConnection","_onProcessExit","replication","name","create","_connect","destroy","connection","result","_disconnect","acquireTimeoutMillis","idleTimeoutMillis","reapIntervalMillis","maxUses","Array","isArray","read","write","omit","map","readConfig","reads","release","client","queryType","useMaster","Promise","all","nextRead","length","databaseVersion","_options","transaction","logging","__testLoggingFn","version","parsedVersion","get","coerce","valid","defaultVersion","lt","unsupportedEngine","type","error","ConnectionAcquireTimeoutError","releaseConnection","uuid","runHooks","connectionManager","connect","disconnect","module","exports","ConnectionManager","default"],"sources":["/Users/aurele/node_modules/sequelize/src/dialects/abstract/connection-manager.js"],"sourcesContent":["'use strict';\n\nconst { Pool, TimeoutError } = require('sequelize-pool');\nconst _ = require('lodash');\nconst semver = require('semver');\nconst errors = require('../../errors');\nconst { logger } = require('../../utils/logger');\nconst deprecations = require('../../utils/deprecations');\nconst debug = logger.debugContext('pool');\n\n/**\n * Abstract Connection Manager\n *\n * Connection manager which handles pooling & replication.\n * Uses sequelize-pool for pooling\n *\n * @private\n */\nclass ConnectionManager {\n  constructor(dialect, sequelize) {\n    const config = _.cloneDeep(sequelize.config);\n\n    this.sequelize = sequelize;\n    this.config = config;\n    this.dialect = dialect;\n    this.versionPromise = null;\n    this.dialectName = this.sequelize.options.dialect;\n\n    if (config.pool === false) {\n      throw new Error('Support for pool:false was removed in v4.0');\n    }\n\n    config.pool = _.defaults(config.pool || {}, {\n      max: 5,\n      min: 0,\n      idle: 10000,\n      acquire: 60000,\n      evict: 1000,\n      validate: this._validate.bind(this)\n    });\n\n    this.initPools();\n  }\n\n  refreshTypeParser(dataTypes) {\n    _.each(dataTypes, dataType => {\n      if (Object.prototype.hasOwnProperty.call(dataType, 'parse')) {\n        if (dataType.types[this.dialectName]) {\n          this._refreshTypeParser(dataType);\n        } else {\n          throw new Error(`Parse function not supported for type ${dataType.key} in dialect ${this.dialectName}`);\n        }\n      }\n    });\n  }\n\n  /**\n   * Try to load dialect module from various configured options.\n   * Priority goes like dialectModulePath > dialectModule > require(default)\n   *\n   * @param {string} moduleName Name of dialect module to lookup\n   *\n   * @private\n   * @returns {object}\n   */\n  _loadDialectModule(moduleName) {\n    try {\n      if (this.sequelize.config.dialectModulePath) {\n        return require(this.sequelize.config.dialectModulePath);\n      }\n      if (this.sequelize.config.dialectModule) {\n        return this.sequelize.config.dialectModule;\n      }\n      return require(moduleName);\n\n    } catch (err) {\n      if (err.code === 'MODULE_NOT_FOUND') {\n        if (this.sequelize.config.dialectModulePath) {\n          throw new Error(`Unable to find dialect at ${this.sequelize.config.dialectModulePath}`);\n        }\n        throw new Error(`Please install ${moduleName} package manually`);\n      }\n\n      throw err;\n    }\n  }\n\n  /**\n   * Handler which executes on process exit or connection manager shutdown\n   *\n   * @private\n   * @returns {Promise}\n   */\n  async _onProcessExit() {\n    if (!this.pool) {\n      return;\n    }\n\n    await this.pool.drain();\n    debug('connection drain due to process exit');\n\n    return await this.pool.destroyAllNow();\n  }\n\n  /**\n   * Drain the pool and close it permanently\n   *\n   * @returns {Promise}\n   */\n  async close() {\n    // Mark close of pool\n    this.getConnection = async function getConnection() {\n      throw new Error('ConnectionManager.getConnection was called after the connection manager was closed!');\n    };\n\n    return await this._onProcessExit();\n  }\n\n  /**\n   * Initialize connection pool. By default pool autostart is set to false, so no connection will be\n   * be created unless `pool.acquire` is called.\n   */\n  initPools() {\n    const config = this.config;\n\n    if (!config.replication) {\n      this.pool = new Pool({\n        name: 'sequelize',\n        create: () => this._connect(config),\n        destroy: async connection => {\n          const result = await this._disconnect(connection);\n          debug('connection destroy');\n          return result;\n        },\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      });\n\n      debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, no replication`);\n\n      return;\n    }\n\n    if (!Array.isArray(config.replication.read)) {\n      config.replication.read = [config.replication.read];\n    }\n\n    // Map main connection config\n    config.replication.write = _.defaults(config.replication.write, _.omit(config, 'replication'));\n\n    // Apply defaults to each read config\n    config.replication.read = config.replication.read.map(readConfig =>\n      _.defaults(readConfig, _.omit(this.config, 'replication'))\n    );\n\n    // custom pooling for replication (original author @janmeier)\n    let reads = 0;\n    this.pool = {\n      release: client => {\n        if (client.queryType === 'read') {\n          this.pool.read.release(client);\n        } else {\n          this.pool.write.release(client);\n        }\n      },\n      acquire: (queryType, useMaster) => {\n        useMaster = useMaster === undefined ? false : useMaster;\n        if (queryType === 'SELECT' && !useMaster) {\n          return this.pool.read.acquire();\n        }\n        return this.pool.write.acquire();\n      },\n      destroy: connection => {\n        this.pool[connection.queryType].destroy(connection);\n        debug('connection destroy');\n      },\n      destroyAllNow: async () => {\n        await Promise.all([\n          this.pool.read.destroyAllNow(),\n          this.pool.write.destroyAllNow()\n        ]);\n\n        debug('all connections destroyed');\n      },\n      drain: async () => Promise.all([\n        this.pool.write.drain(),\n        this.pool.read.drain()\n      ]),\n      read: new Pool({\n        name: 'sequelize:read',\n        create: async () => {\n          // round robin config\n          const nextRead = reads++ % config.replication.read.length;\n          const connection = await this._connect(config.replication.read[nextRead]);\n          connection.queryType = 'read';\n          return connection;\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      }),\n      write: new Pool({\n        name: 'sequelize:write',\n        create: async () => {\n          const connection = await this._connect(config.replication.write);\n          connection.queryType = 'write';\n          return connection;\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      })\n    };\n\n    debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, with replication`);\n  }\n\n  /**\n   * Get connection from pool. It sets database version if it's not already set.\n   * Call pool.acquire to get a connection\n   *\n   * @param {object}   [options]                 Pool options\n   * @param {string}   [options.type]            Set which replica to use. Available options are `read` and `write`\n   * @param {boolean}  [options.useMaster=false] Force master or write replica to get connection from\n   *\n   * @returns {Promise<Connection>}\n   */\n  async getConnection(options) {\n    options = options || {};\n\n    if (this.sequelize.options.databaseVersion === 0) {\n      if (!this.versionPromise) {\n        this.versionPromise = (async () => {\n          try {\n            const connection = await this._connect(this.config.replication.write || this.config);\n            const _options = {};\n\n            _options.transaction = { connection }; // Cheat .query to use our private connection\n            _options.logging = () => {};\n            _options.logging.__testLoggingFn = true;\n\n            //connection might have set databaseVersion value at initialization,\n            //avoiding a useless round trip\n            if (this.sequelize.options.databaseVersion === 0) {\n              const version = await this.sequelize.databaseVersion(_options);\n              const parsedVersion = _.get(semver.coerce(version), 'version') || version;\n              this.sequelize.options.databaseVersion = semver.valid(parsedVersion)\n                ? parsedVersion\n                : this.dialect.defaultVersion;\n            }\n\n            if (semver.lt(this.sequelize.options.databaseVersion, this.dialect.defaultVersion)) {\n              deprecations.unsupportedEngine();\n              debug(`Unsupported database engine version ${this.sequelize.options.databaseVersion}`);\n            }\n\n            this.versionPromise = null;\n            return await this._disconnect(connection);\n          } catch (err) {\n            this.versionPromise = null;\n            throw err;\n          }\n        })();\n      }\n      await this.versionPromise;\n    }\n\n    let result;\n\n    try {\n      result = await this.pool.acquire(options.type, options.useMaster);\n    } catch (error) {\n      if (error instanceof TimeoutError) throw new errors.ConnectionAcquireTimeoutError(error);\n      throw error;\n    }\n\n    debug('connection acquired');\n\n    return result;\n  }\n\n  /**\n   * Release a pooled connection so it can be utilized by other connection requests\n   *\n   * @param {Connection} connection\n   */\n  releaseConnection(connection) {\n    this.pool.release(connection);\n    debug('connection released');\n  }\n\n  /**\n   * Destroys a pooled connection and removes it from the pool.\n   *\n   * @param {Connection} connection\n   */\n  async destroyConnection(connection) {\n    await this.pool.destroy(connection);\n    debug(`connection ${connection.uuid} destroyed`);\n  }\n\n  /**\n   * Call dialect library to get connection\n   *\n   * @param {*} config Connection config\n   * @private\n   * @returns {Promise<Connection>}\n   */\n  async _connect(config) {\n    await this.sequelize.runHooks('beforeConnect', config);\n    const connection = await this.dialect.connectionManager.connect(config);\n    await this.sequelize.runHooks('afterConnect', connection, config);\n    return connection;\n  }\n\n  /**\n   * Call dialect library to disconnect a connection\n   *\n   * @param {Connection} connection\n   * @private\n   * @returns {Promise}\n   */\n  async _disconnect(connection) {\n    await this.sequelize.runHooks('beforeDisconnect', connection);\n    await this.dialect.connectionManager.disconnect(connection);\n    return this.sequelize.runHooks('afterDisconnect', connection);\n  }\n\n  /**\n   * Determine if a connection is still valid or not\n   *\n   * @param {Connection} connection\n   *\n   * @returns {boolean}\n   */\n  _validate(connection) {\n    if (!this.dialect.connectionManager.validate) {\n      return true;\n    }\n\n    return this.dialect.connectionManager.validate(connection);\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"]},"metadata":{},"sourceType":"script"}