{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nconst sequelizeErrors = require(\"../../errors\");\n\nconst QueryTypes = require(\"../../query-types\");\n\nconst {\n  QueryInterface\n} = require(\"../abstract/query-interface\");\n\nconst {\n  cloneDeep\n} = require(\"../../utils\");\n\nconst _ = require(\"lodash\");\n\nclass SQLiteQueryInterface extends QueryInterface {\n  async removeColumn(tableName, attributeName, options) {\n    options = options || {};\n    const fields = await this.describeTable(tableName, options);\n    delete fields[attributeName];\n    const sql = this.queryGenerator.removeColumnQuery(tableName, fields);\n    const subQueries = sql.split(\";\").filter(q => q !== \"\");\n\n    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, __spreadValues({\n      raw: true\n    }, options));\n  }\n\n  async changeColumn(tableName, attributeName, dataTypeOrOptions, options) {\n    options = options || {};\n    const fields = await this.describeTable(tableName, options);\n    Object.assign(fields[attributeName], this.normalizeAttribute(dataTypeOrOptions));\n    const sql = this.queryGenerator.removeColumnQuery(tableName, fields);\n    const subQueries = sql.split(\";\").filter(q => q !== \"\");\n\n    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, __spreadValues({\n      raw: true\n    }, options));\n  }\n\n  async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {\n    options = options || {};\n    const fields = await this.assertTableHasColumn(tableName, attrNameBefore, options);\n    fields[attrNameAfter] = __spreadValues({}, fields[attrNameBefore]);\n    delete fields[attrNameBefore];\n    const sql = this.queryGenerator.renameColumnQuery(tableName, attrNameBefore, attrNameAfter, fields);\n    const subQueries = sql.split(\";\").filter(q => q !== \"\");\n\n    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, __spreadValues({\n      raw: true\n    }, options));\n  }\n\n  async removeConstraint(tableName, constraintName, options) {\n    let createTableSql;\n    const constraints = await this.showConstraint(tableName, constraintName);\n    const constraint = constraints.find(constaint => constaint.constraintName === constraintName);\n\n    if (!constraint) {\n      throw new sequelizeErrors.UnknownConstraintError({\n        message: `Constraint ${constraintName} on table ${tableName} does not exist`,\n        constraint: constraintName,\n        table: tableName\n      });\n    }\n\n    createTableSql = constraint.sql;\n    constraint.constraintName = this.queryGenerator.quoteIdentifier(constraint.constraintName);\n    let constraintSnippet = `, CONSTRAINT ${constraint.constraintName} ${constraint.constraintType} ${constraint.constraintCondition}`;\n\n    if (constraint.constraintType === \"FOREIGN KEY\") {\n      const referenceTableName = this.queryGenerator.quoteTable(constraint.referenceTableName);\n      constraint.referenceTableKeys = constraint.referenceTableKeys.map(columnName => this.queryGenerator.quoteIdentifier(columnName));\n      const referenceTableKeys = constraint.referenceTableKeys.join(\", \");\n      constraintSnippet += ` REFERENCES ${referenceTableName} (${referenceTableKeys})`;\n      constraintSnippet += ` ON UPDATE ${constraint.updateAction}`;\n      constraintSnippet += ` ON DELETE ${constraint.deleteAction}`;\n    }\n\n    createTableSql = createTableSql.replace(constraintSnippet, \"\");\n    createTableSql += \";\";\n    const fields = await this.describeTable(tableName, options);\n\n    const sql = this.queryGenerator._alterConstraintQuery(tableName, fields, createTableSql);\n\n    const subQueries = sql.split(\";\").filter(q => q !== \"\");\n\n    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, __spreadValues({\n      raw: true\n    }, options));\n  }\n\n  async addConstraint(tableName, options) {\n    if (!options.fields) {\n      throw new Error(\"Fields must be specified through options.fields\");\n    }\n\n    if (!options.type) {\n      throw new Error(\"Constraint type must be specified through options.type\");\n    }\n\n    options = cloneDeep(options);\n    const constraintSnippet = this.queryGenerator.getConstraintSnippet(tableName, options);\n    const describeCreateTableSql = this.queryGenerator.describeCreateTableQuery(tableName);\n    const constraints = await this.sequelize.query(describeCreateTableSql, __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.SELECT,\n      raw: true\n    }));\n    let sql = constraints[0].sql;\n    const index = sql.length - 1;\n    const createTableSql = `${sql.substr(0, index)}, ${constraintSnippet})${sql.substr(index + 1)};`;\n    const fields = await this.describeTable(tableName, options);\n    sql = this.queryGenerator._alterConstraintQuery(tableName, fields, createTableSql);\n    const subQueries = sql.split(\";\").filter(q => q !== \"\");\n\n    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, __spreadValues({\n      raw: true\n    }, options));\n  }\n\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const database = this.sequelize.config.database;\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, database);\n    const result = await this.sequelize.query(query, options);\n    return result.map(row => ({\n      tableName,\n      columnName: row.from,\n      referencedTableName: row.table,\n      referencedColumnName: row.to,\n      tableCatalog: database,\n      referencedTableCatalog: database\n    }));\n  }\n\n  async dropAllTables(options) {\n    options = options || {};\n    const skip = options.skip || [];\n    const tableNames = await this.showAllTables(options);\n    await this.sequelize.query(\"PRAGMA foreign_keys = OFF\", options);\n    await this._dropAllTables(tableNames, skip, options);\n    await this.sequelize.query(\"PRAGMA foreign_keys = ON\", options);\n  }\n\n  async describeTable(tableName, options) {\n    let schema = null;\n    let schemaDelimiter = null;\n\n    if (typeof options === \"string\") {\n      schema = options;\n    } else if (typeof options === \"object\" && options !== null) {\n      schema = options.schema || null;\n      schemaDelimiter = options.schemaDelimiter || null;\n    }\n\n    if (typeof tableName === \"object\" && tableName !== null) {\n      schema = tableName.schema;\n      tableName = tableName.tableName;\n    }\n\n    const sql = this.queryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);\n    options = __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.DESCRIBE\n    });\n    const sqlIndexes = this.queryGenerator.showIndexesQuery(tableName);\n\n    try {\n      const data = await this.sequelize.query(sql, options);\n\n      if (_.isEmpty(data)) {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n\n      const indexes = await this.sequelize.query(sqlIndexes, options);\n\n      for (const prop in data) {\n        data[prop].unique = false;\n      }\n\n      for (const index of indexes) {\n        for (const field of index.fields) {\n          if (index.unique !== void 0) {\n            data[field.attribute].unique = index.unique;\n          }\n        }\n      }\n\n      const foreignKeys = await this.getForeignKeyReferencesForTable(tableName, options);\n\n      for (const foreignKey of foreignKeys) {\n        data[foreignKey.columnName].references = {\n          model: foreignKey.referencedTableName,\n          key: foreignKey.referencedColumnName\n        };\n      }\n\n      return data;\n    } catch (e) {\n      if (e.original && e.original.code === \"ER_NO_SUCH_TABLE\") {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n\n      throw e;\n    }\n  }\n\n}\n\nexports.SQLiteQueryInterface = SQLiteQueryInterface;","map":{"version":3,"mappings":"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","names":["sequelizeErrors","require","QueryTypes","QueryInterface","cloneDeep","_","tableName","attributeName","options","fields","describeTable","sql","queryGenerator","removeColumnQuery","subQueries","split","filter","q","subQuery","sequelize","query","__spreadValues","raw","dataTypeOrOptions","Object","assign","normalizeAttribute","attrNameBefore","attrNameAfter","assertTableHasColumn","renameColumnQuery","constraintName","createTableSql","constraints","showConstraint","constraint","find","constaint","UnknownConstraintError","message","table","quoteIdentifier","constraintSnippet","constraintType","constraintCondition","referenceTableName","quoteTable","referenceTableKeys","map","columnName","join","updateAction","deleteAction","replace","_alterConstraintQuery","Error","type","getConstraintSnippet","describeCreateTableSql","describeCreateTableQuery","__spreadProps","SELECT","index","length","substr","database","config","getForeignKeysQuery","result","row","from","referencedTableName","referencedColumnName","to","tableCatalog","referencedTableCatalog","skip","tableNames","showAllTables","_dropAllTables","schema","schemaDelimiter","describeTableQuery","DESCRIBE","sqlIndexes","showIndexesQuery","data","isEmpty","indexes","prop","unique","field","attribute","foreignKeys","getForeignKeyReferencesForTable","foreignKey","references","model","key","e","original","code","exports","SQLiteQueryInterface"],"sources":["/Users/aurele/node_modules/sequelize/src/dialects/sqlite/query-interface.js"],"sourcesContent":["'use strict';\n\nconst sequelizeErrors = require('../../errors');\nconst QueryTypes = require('../../query-types');\nconst { QueryInterface } = require('../abstract/query-interface');\nconst { cloneDeep } = require('../../utils');\nconst _ = require('lodash');\n\n/**\n * The interface that Sequelize uses to talk with SQLite database\n */\nclass SQLiteQueryInterface extends QueryInterface {\n  /**\n   * A wrapper that fixes SQLite's inability to remove columns from existing tables.\n   * It will create a backup of the table, drop the table afterwards and create a\n   * new table with the same name but without the obsolete column.\n   *\n   * @override\n   */\n  async removeColumn(tableName, attributeName, options) {\n    options = options || {};\n\n    const fields = await this.describeTable(tableName, options);\n    delete fields[attributeName];\n\n    const sql = this.queryGenerator.removeColumnQuery(tableName, fields);\n    const subQueries = sql.split(';').filter(q => q !== '');\n\n    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, { raw: true, ...options });\n  }\n\n  /**\n   * A wrapper that fixes SQLite's inability to change columns from existing tables.\n   * It will create a backup of the table, drop the table afterwards and create a\n   * new table with the same name but with a modified version of the respective column.\n   *\n   * @override\n   */\n  async changeColumn(tableName, attributeName, dataTypeOrOptions, options) {\n    options = options || {};\n\n    const fields = await this.describeTable(tableName, options);\n    Object.assign(fields[attributeName], this.normalizeAttribute(dataTypeOrOptions));\n\n    const sql = this.queryGenerator.removeColumnQuery(tableName, fields);\n    const subQueries = sql.split(';').filter(q => q !== '');\n\n    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, { raw: true, ...options });\n  }\n\n  /**\n   * A wrapper that fixes SQLite's inability to rename columns from existing tables.\n   * It will create a backup of the table, drop the table afterwards and create a\n   * new table with the same name but with a renamed version of the respective column.\n   *\n   * @override\n   */\n  async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {\n    options = options || {};\n    const fields = await this.assertTableHasColumn(tableName, attrNameBefore, options);\n\n    fields[attrNameAfter] = { ...fields[attrNameBefore] };\n    delete fields[attrNameBefore];\n\n    const sql = this.queryGenerator.renameColumnQuery(tableName, attrNameBefore, attrNameAfter, fields);\n    const subQueries = sql.split(';').filter(q => q !== '');\n\n    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, { raw: true, ...options });\n  }\n\n  /**\n   * @override\n   */\n  async removeConstraint(tableName, constraintName, options) {\n    let createTableSql;\n\n    const constraints = await this.showConstraint(tableName, constraintName);\n    // sqlite can't show only one constraint, so we find here the one to remove\n    const constraint = constraints.find(constaint => constaint.constraintName === constraintName);\n\n    if (!constraint) {\n      throw new sequelizeErrors.UnknownConstraintError({\n        message: `Constraint ${constraintName} on table ${tableName} does not exist`,\n        constraint: constraintName,\n        table: tableName\n      });\n    }\n    createTableSql = constraint.sql;\n    constraint.constraintName = this.queryGenerator.quoteIdentifier(constraint.constraintName);\n    let constraintSnippet = `, CONSTRAINT ${constraint.constraintName} ${constraint.constraintType} ${constraint.constraintCondition}`;\n\n    if (constraint.constraintType === 'FOREIGN KEY') {\n      const referenceTableName = this.queryGenerator.quoteTable(constraint.referenceTableName);\n      constraint.referenceTableKeys = constraint.referenceTableKeys.map(columnName => this.queryGenerator.quoteIdentifier(columnName));\n      const referenceTableKeys = constraint.referenceTableKeys.join(', ');\n      constraintSnippet += ` REFERENCES ${referenceTableName} (${referenceTableKeys})`;\n      constraintSnippet += ` ON UPDATE ${constraint.updateAction}`;\n      constraintSnippet += ` ON DELETE ${constraint.deleteAction}`;\n    }\n\n    createTableSql = createTableSql.replace(constraintSnippet, '');\n    createTableSql += ';';\n\n    const fields = await this.describeTable(tableName, options);\n\n    const sql = this.queryGenerator._alterConstraintQuery(tableName, fields, createTableSql);\n    const subQueries = sql.split(';').filter(q => q !== '');\n\n    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, { raw: true, ...options });\n  }\n\n  /**\n   * @override\n   */\n  async addConstraint(tableName, options) {\n    if (!options.fields) {\n      throw new Error('Fields must be specified through options.fields');\n    }\n\n    if (!options.type) {\n      throw new Error('Constraint type must be specified through options.type');\n    }\n\n    options = cloneDeep(options);\n\n    const constraintSnippet = this.queryGenerator.getConstraintSnippet(tableName, options);\n    const describeCreateTableSql = this.queryGenerator.describeCreateTableQuery(tableName);\n\n    const constraints = await this.sequelize.query(describeCreateTableSql, { ...options, type: QueryTypes.SELECT, raw: true });\n    let sql = constraints[0].sql;\n    const index = sql.length - 1;\n    //Replace ending ')' with constraint snippet - Simulates String.replaceAt\n    //http://stackoverflow.com/questions/1431094\n    const createTableSql = `${sql.substr(0, index)}, ${constraintSnippet})${sql.substr(index + 1)};`;\n\n    const fields = await this.describeTable(tableName, options);\n    sql = this.queryGenerator._alterConstraintQuery(tableName, fields, createTableSql);\n    const subQueries = sql.split(';').filter(q => q !== '');\n\n    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, { raw: true, ...options });\n  }\n\n  /**\n   * @override\n   */\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const database = this.sequelize.config.database;\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, database);\n    const result = await this.sequelize.query(query, options);\n    return result.map(row => ({\n      tableName,\n      columnName: row.from,\n      referencedTableName: row.table,\n      referencedColumnName: row.to,\n      tableCatalog: database,\n      referencedTableCatalog: database\n    }));\n  }\n\n  /**\n   * @override\n   */\n  async dropAllTables(options) {\n    options = options || {};\n    const skip = options.skip || [];\n\n    const tableNames = await this.showAllTables(options);\n    await this.sequelize.query('PRAGMA foreign_keys = OFF', options);\n    await this._dropAllTables(tableNames, skip, options);\n    await this.sequelize.query('PRAGMA foreign_keys = ON', options);\n  }\n\n  /**\n   * @override\n   */\n  async describeTable(tableName, options) {\n    let schema = null;\n    let schemaDelimiter = null;\n\n    if (typeof options === 'string') {\n      schema = options;\n    } else if (typeof options === 'object' && options !== null) {\n      schema = options.schema || null;\n      schemaDelimiter = options.schemaDelimiter || null;\n    }\n\n    if (typeof tableName === 'object' && tableName !== null) {\n      schema = tableName.schema;\n      tableName = tableName.tableName;\n    }\n\n    const sql = this.queryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);\n    options = { ...options, type: QueryTypes.DESCRIBE };\n    const sqlIndexes = this.queryGenerator.showIndexesQuery(tableName);\n\n    try {\n      const data = await this.sequelize.query(sql, options);\n      /*\n       * If no data is returned from the query, then the table name may be wrong.\n       * Query generators that use information_schema for retrieving table info will just return an empty result set,\n       * it will not throw an error like built-ins do (e.g. DESCRIBE on MySql).\n       */\n      if (_.isEmpty(data)) {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n\n      const indexes = await this.sequelize.query(sqlIndexes, options);\n      for (const prop in data) {\n        data[prop].unique = false;\n      }\n      for (const index of indexes) {\n        for (const field of index.fields) {\n          if (index.unique !== undefined) {\n            data[field.attribute].unique = index.unique;\n          }\n        }\n      }\n\n      const foreignKeys = await this.getForeignKeyReferencesForTable(tableName, options);\n      for (const foreignKey of foreignKeys) {\n        data[foreignKey.columnName].references = {\n          model: foreignKey.referencedTableName,\n          key: foreignKey.referencedColumnName\n        };\n      }\n\n      return data;\n    } catch (e) {\n      if (e.original && e.original.code === 'ER_NO_SUCH_TABLE') {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n\n      throw e;\n    }\n  }\n}\n\nexports.SQLiteQueryInterface = SQLiteQueryInterface;\n"]},"metadata":{},"sourceType":"script"}