{"ast":null,"code":"\"use strict\";\n\nconst dataTypes = require(\"./data-types\");\n\nconst {\n  logger\n} = require(\"./utils/logger\");\n\nfunction arrayToList(array, timeZone, dialect, format2) {\n  return array.reduce((sql, val, i) => {\n    if (i !== 0) {\n      sql += \", \";\n    }\n\n    if (Array.isArray(val)) {\n      sql += `(${arrayToList(val, timeZone, dialect, format2)})`;\n    } else {\n      sql += escape(val, timeZone, dialect, format2);\n    }\n\n    return sql;\n  }, \"\");\n}\n\nexports.arrayToList = arrayToList;\n\nfunction escape(val, timeZone, dialect, format2) {\n  let prependN = false;\n\n  if (val === void 0 || val === null) {\n    return \"NULL\";\n  }\n\n  switch (typeof val) {\n    case \"boolean\":\n      if ([\"sqlite\", \"mssql\", \"oracle\"].includes(dialect)) {\n        return +!!val;\n      }\n\n      return (!!val).toString();\n\n    case \"number\":\n    case \"bigint\":\n      return val.toString();\n\n    case \"string\":\n      prependN = dialect === \"mssql\";\n      break;\n  }\n\n  if (val instanceof Date) {\n    val = dataTypes[dialect].DATE.prototype.stringify(val, {\n      timezone: timeZone\n    });\n  }\n\n  if (Buffer.isBuffer(val)) {\n    if (dataTypes[dialect].BLOB) {\n      return dataTypes[dialect].BLOB.prototype.stringify(val);\n    }\n\n    return dataTypes.BLOB.prototype.stringify(val);\n  }\n\n  if (Array.isArray(val)) {\n    const partialEscape = escVal => escape(escVal, timeZone, dialect, format2);\n\n    if (dialect === \"postgres\" && !format2) {\n      return dataTypes.ARRAY.prototype.stringify(val, {\n        escape: partialEscape\n      });\n    }\n\n    return arrayToList(val, timeZone, dialect, format2);\n  }\n\n  if (!val.replace) {\n    throw new Error(`Invalid value ${logger.inspect(val)}`);\n  }\n\n  if ([\"postgres\", \"sqlite\", \"mssql\", \"snowflake\", \"db2\"].includes(dialect)) {\n    val = val.replace(/'/g, \"''\");\n\n    if (dialect === \"postgres\") {\n      val = val.replace(/\\0/g, \"\\\\0\");\n    }\n  } else if (dialect === \"oracle\" && typeof val === \"string\") {\n    if (val.startsWith(\"TO_TIMESTAMP\") || val.startsWith(\"TO_DATE\")) {\n      return val;\n    }\n\n    val = val.replace(/'/g, \"''\");\n  } else {\n    val = val.replace(/[\\0\\n\\r\\b\\t\\\\'\"\\x1a]/g, s => {\n      switch (s) {\n        case \"\\0\":\n          return \"\\\\0\";\n\n        case \"\\n\":\n          return \"\\\\n\";\n\n        case \"\\r\":\n          return \"\\\\r\";\n\n        case \"\\b\":\n          return \"\\\\b\";\n\n        case \"\t\":\n          return \"\\\\t\";\n\n        case \"\u001a\":\n          return \"\\\\Z\";\n\n        default:\n          return `\\\\${s}`;\n      }\n    });\n  }\n\n  return `${(prependN ? \"N'\" : \"'\") + val}'`;\n}\n\nexports.escape = escape;\n\nfunction format(sql, values, timeZone, dialect) {\n  values = [].concat(values);\n\n  if (typeof sql !== \"string\") {\n    throw new Error(`Invalid SQL string provided: ${sql}`);\n  }\n\n  return sql.replace(/\\?/g, match => {\n    if (!values.length) {\n      return match;\n    }\n\n    return escape(values.shift(), timeZone, dialect, true);\n  });\n}\n\nexports.format = format;\n\nfunction formatNamedParameters(sql, values, timeZone, dialect) {\n  return sql.replace(/:+(?!\\d)(\\w+)/g, (value, key) => {\n    if (dialect === \"postgres\" && value.slice(0, 2) === \"::\") {\n      return value;\n    }\n\n    if (values[key] !== void 0) {\n      return escape(values[key], timeZone, dialect, true);\n    }\n\n    throw new Error(`Named parameter \"${value}\" has no value in the given object.`);\n  });\n}\n\nexports.formatNamedParameters = formatNamedParameters;","map":{"version":3,"mappings":"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","names":["dataTypes","require","logger","array","timeZone","dialect","format2","reduce","sql","val","i","Array","isArray","arrayToList","escape","exports","prependN","includes","toString","Date","DATE","prototype","stringify","timezone","Buffer","isBuffer","BLOB","partialEscape","escVal","ARRAY","replace","Error","inspect","startsWith","s","values","concat","match","length","shift","format","value","key","slice","formatNamedParameters"],"sources":["/Users/aurele/node_modules/sequelize/src/sql-string.js"],"sourcesContent":["'use strict';\n\nconst dataTypes = require('./data-types');\nconst { logger } = require('./utils/logger');\n\nfunction arrayToList(array, timeZone, dialect, format) {\n  return array.reduce((sql, val, i) => {\n    if (i !== 0) {\n      sql += ', ';\n    }\n    if (Array.isArray(val)) {\n      sql += `(${arrayToList(val, timeZone, dialect, format)})`;\n    } else {\n      sql += escape(val, timeZone, dialect, format);\n    }\n    return sql;\n  }, '');\n}\nexports.arrayToList = arrayToList;\n\nfunction escape(val, timeZone, dialect, format) {\n  let prependN = false;\n  if (val === undefined || val === null) {\n    return 'NULL';\n  }\n  switch (typeof val) {\n    case 'boolean':\n    // SQLite doesn't have true/false support. MySQL aliases true/false to 1/0\n    // for us. Postgres actually has a boolean type with true/false literals,\n    // but sequelize doesn't use it yet.\n      if (['sqlite', 'mssql', 'oracle'].includes(dialect)) {\n        return +!!val;\n      }\n      return (!!val).toString();\n    case 'number':\n    case 'bigint':\n      return val.toString();\n    case 'string':\n    // In mssql, prepend N to all quoted vals which are originally a string (for\n    // unicode compatibility)\n      prependN = dialect === 'mssql';\n      break;\n  }\n\n  if (val instanceof Date) {\n    val = dataTypes[dialect].DATE.prototype.stringify(val, { timezone: timeZone });\n  }\n\n  if (Buffer.isBuffer(val)) {\n    if (dataTypes[dialect].BLOB) {\n      return dataTypes[dialect].BLOB.prototype.stringify(val);\n    }\n\n    return dataTypes.BLOB.prototype.stringify(val);\n  }\n\n  if (Array.isArray(val)) {\n    const partialEscape = escVal => escape(escVal, timeZone, dialect, format);\n    if (dialect === 'postgres' && !format) {\n      return dataTypes.ARRAY.prototype.stringify(val, { escape: partialEscape });\n    }\n    return arrayToList(val, timeZone, dialect, format);\n  }\n\n  if (!val.replace) {\n    throw new Error(`Invalid value ${logger.inspect(val)}`);\n  }\n\n  if (['postgres', 'sqlite', 'mssql', 'snowflake', 'db2'].includes(dialect)) {\n    // http://www.postgresql.org/docs/8.2/static/sql-syntax-lexical.html#SQL-SYNTAX-STRINGS\n    // http://stackoverflow.com/q/603572/130598\n    val = val.replace(/'/g, \"''\");\n\n    if (dialect === 'postgres') {\n      // null character is not allowed in Postgres\n      val = val.replace(/\\0/g, '\\\\0');\n    }\n  } else if (dialect === 'oracle' && typeof val === 'string') {\n    if (val.startsWith('TO_TIMESTAMP') || val.startsWith('TO_DATE')) {\n      return val;\n    }\n    val = val.replace(/'/g, \"''\");\n  } else {\n\n    // eslint-disable-next-line no-control-regex\n    val = val.replace(/[\\0\\n\\r\\b\\t\\\\'\"\\x1a]/g, s => {\n      switch (s) {\n        case '\\0': return '\\\\0';\n        case '\\n': return '\\\\n';\n        case '\\r': return '\\\\r';\n        case '\\b': return '\\\\b';\n        case '\\t': return '\\\\t';\n        case '\\x1a': return '\\\\Z';\n        default: return `\\\\${s}`;\n      }\n    });\n  }\n  return `${(prependN ? \"N'\" : \"'\") + val}'`;\n}\nexports.escape = escape;\n\nfunction format(sql, values, timeZone, dialect) {\n  values = [].concat(values);\n\n  if (typeof sql !== 'string') {\n    throw new Error(`Invalid SQL string provided: ${sql}`);\n  }\n\n  return sql.replace(/\\?/g, match => {\n    if (!values.length) {\n      return match;\n    }\n\n    return escape(values.shift(), timeZone, dialect, true);\n  });\n}\nexports.format = format;\n\nfunction formatNamedParameters(sql, values, timeZone, dialect) {\n  return sql.replace(/:+(?!\\d)(\\w+)/g, (value, key) => {\n    if ('postgres' === dialect && '::' === value.slice(0, 2)) {\n      return value;\n    }\n\n    if (values[key] !== undefined) {\n      return escape(values[key], timeZone, dialect, true);\n    }\n    throw new Error(`Named parameter \"${value}\" has no value in the given object.`);\n  });\n}\nexports.formatNamedParameters = formatNamedParameters;\n"]},"metadata":{},"sourceType":"script"}