{"ast":null,"code":"'use strict';\n\nconst proc = typeof process === 'object' && process ? process : {\n  stdout: null,\n  stderr: null\n};\n\nconst EE = require('events');\n\nconst Stream = require('stream');\n\nconst stringdecoder = require('string_decoder');\n\nconst SD = stringdecoder.StringDecoder;\nconst EOF = Symbol('EOF');\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd');\nconst EMITTED_END = Symbol('emittedEnd');\nconst EMITTING_END = Symbol('emittingEnd');\nconst EMITTED_ERROR = Symbol('emittedError');\nconst CLOSED = Symbol('closed');\nconst READ = Symbol('read');\nconst FLUSH = Symbol('flush');\nconst FLUSHCHUNK = Symbol('flushChunk');\nconst ENCODING = Symbol('encoding');\nconst DECODER = Symbol('decoder');\nconst FLOWING = Symbol('flowing');\nconst PAUSED = Symbol('paused');\nconst RESUME = Symbol('resume');\nconst BUFFER = Symbol('buffer');\nconst PIPES = Symbol('pipes');\nconst BUFFERLENGTH = Symbol('bufferLength');\nconst BUFFERPUSH = Symbol('bufferPush');\nconst BUFFERSHIFT = Symbol('bufferShift');\nconst OBJECTMODE = Symbol('objectMode'); // internal event when stream is destroyed\n\nconst DESTROYED = Symbol('destroyed'); // internal event when stream has an error\n\nconst ERROR = Symbol('error');\nconst EMITDATA = Symbol('emitData');\nconst EMITEND = Symbol('emitEnd');\nconst EMITEND2 = Symbol('emitEnd2');\nconst ASYNC = Symbol('async');\nconst ABORT = Symbol('abort');\nconst ABORTED = Symbol('aborted');\nconst SIGNAL = Symbol('signal');\n\nconst defer = fn => Promise.resolve().then(fn); // TODO remove when Node v8 support drops\n\n\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== '1';\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol('asyncIterator not implemented');\nconst ITERATOR = doIter && Symbol.iterator || Symbol('iterator not implemented'); // events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\n\nconst isEndish = ev => ev === 'end' || ev === 'finish' || ev === 'prefinish';\n\nconst isArrayBuffer = b => b instanceof ArrayBuffer || typeof b === 'object' && b.constructor && b.constructor.name === 'ArrayBuffer' && b.byteLength >= 0;\n\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);\n\nclass Pipe {\n  constructor(src, dest, opts) {\n    this.src = src;\n    this.dest = dest;\n    this.opts = opts;\n\n    this.ondrain = () => src[RESUME]();\n\n    dest.on('drain', this.ondrain);\n  }\n\n  unpipe() {\n    this.dest.removeListener('drain', this.ondrain);\n  } // istanbul ignore next - only here for the prototype\n\n\n  proxyErrors() {}\n\n  end() {\n    this.unpipe();\n    if (this.opts.end) this.dest.end();\n  }\n\n}\n\nclass PipeProxyErrors extends Pipe {\n  unpipe() {\n    this.src.removeListener('error', this.proxyErrors);\n    super.unpipe();\n  }\n\n  constructor(src, dest, opts) {\n    super(src, dest, opts);\n\n    this.proxyErrors = er => dest.emit('error', er);\n\n    src.on('error', this.proxyErrors);\n  }\n\n}\n\nclass Minipass extends Stream {\n  constructor(options) {\n    super();\n    this[SIGNAL] = options && options.signal;\n\n    if (this[SIGNAL]) {\n      this[SIGNAL].addEventListener('abort', () => this[ABORT]());\n    }\n\n    this[ABORTED] = false;\n    this[FLOWING] = false; // whether we're explicitly paused\n\n    this[PAUSED] = false;\n    this[PIPES] = [];\n    this[BUFFER] = [];\n    this[OBJECTMODE] = options && options.objectMode || false;\n    if (this[OBJECTMODE]) this[ENCODING] = null;else this[ENCODING] = options && options.encoding || null;\n    if (this[ENCODING] === 'buffer') this[ENCODING] = null;\n    this[ASYNC] = options && !!options.async || false;\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;\n    this[EOF] = false;\n    this[EMITTED_END] = false;\n    this[EMITTING_END] = false;\n    this[CLOSED] = false;\n    this[EMITTED_ERROR] = null;\n    this.writable = true;\n    this.readable = true;\n    this[BUFFERLENGTH] = 0;\n    this[DESTROYED] = false;\n\n    if (options && options.debugExposeBuffer === true) {\n      Object.defineProperty(this, 'buffer', {\n        get: () => this[BUFFER]\n      });\n    }\n\n    if (options && options.debugExposePipes === true) {\n      Object.defineProperty(this, 'pipes', {\n        get: () => this[PIPES]\n      });\n    }\n  }\n\n  get bufferLength() {\n    return this[BUFFERLENGTH];\n  }\n\n  get encoding() {\n    return this[ENCODING];\n  }\n\n  set encoding(enc) {\n    if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode');\n    if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH])) throw new Error('cannot change encoding');\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null;\n      if (this[BUFFER].length) this[BUFFER] = this[BUFFER].map(chunk => this[DECODER].write(chunk));\n    }\n\n    this[ENCODING] = enc;\n  }\n\n  setEncoding(enc) {\n    this.encoding = enc;\n  }\n\n  get objectMode() {\n    return this[OBJECTMODE];\n  }\n\n  set objectMode(om) {\n    this[OBJECTMODE] = this[OBJECTMODE] || !!om;\n  }\n\n  get ['async']() {\n    return this[ASYNC];\n  }\n\n  set ['async'](a) {\n    this[ASYNC] = this[ASYNC] || !!a;\n  } // drop everything and get out of the flow completely\n\n\n  [ABORT]() {\n    this[ABORTED] = true;\n    const signal = this[SIGNAL];\n    /* istanbul ignore next */\n\n    if (this.write) this.write = () => {};\n    /* istanbul ignore next */\n\n    if (this.end) this.end = () => {};\n    /* istanbul ignore next */\n\n    if (this.pipe) this.pipe = () => {};\n    /* istanbul ignore next */\n\n    this.on = this.addListener = () => {};\n    /* istanbul ignore next */\n\n\n    this.off = this.removeListener = () => {};\n    /* istanbul ignore next */\n\n\n    this[ABORT] = () => {};\n    /* istanbul ignore next */\n\n\n    this.emit = () => {};\n\n    for (const p of this[PIPES]) {\n      p.unpipe();\n    }\n\n    super.removeAllListeners('data');\n    super.removeAllListeners('end');\n    super.removeAllListeners('drain');\n    super.removeAllListeners('resume');\n    this[BUFFER].length = 0;\n    this.readable = false;\n    this.writable = false;\n    super.emit(ABORT, signal.reason);\n    super.emit('abort', signal.reason);\n    super.emit('end');\n    super.emit('prefinish');\n    super.emit('finish');\n    super.emit('close');\n  }\n\n  get aborted() {\n    return this[ABORTED];\n  }\n\n  set aborted(_) {}\n\n  write(chunk, encoding, cb) {\n    if (this[EOF]) throw new Error('write after end');\n\n    if (this[DESTROYED]) {\n      this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), {\n        code: 'ERR_STREAM_DESTROYED'\n      }));\n      return true;\n    }\n\n    if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n    if (!encoding) encoding = 'utf8';\n    const fn = this[ASYNC] ? defer : f => f(); // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk)) chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk);else if (typeof chunk !== 'string') // use the setter so we throw if we have encoding set\n        this.objectMode = true;\n    } // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n\n\n    if (this[OBJECTMODE]) {\n      /* istanbul ignore if - maybe impossible? */\n      if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);\n      if (this.flowing) this.emit('data', chunk);else this[BUFFERPUSH](chunk);\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n      if (cb) fn(cb);\n      return this.flowing;\n    } // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n\n\n    if (!chunk.length) {\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n      if (cb) fn(cb);\n      return this.flowing;\n    } // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n\n\n    if (typeof chunk === 'string' && // unless it is a string already ready for us to use\n    !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n      chunk = Buffer.from(chunk, encoding);\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING]) chunk = this[DECODER].write(chunk); // Note: flushing CAN potentially switch us into not-flowing mode\n\n    if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);\n    if (this.flowing) this.emit('data', chunk);else this[BUFFERPUSH](chunk);\n    if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n    if (cb) fn(cb);\n    return this.flowing;\n  }\n\n  read(n) {\n    if (this[DESTROYED]) return null;\n\n    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {\n      this[MAYBE_EMIT_END]();\n      return null;\n    }\n\n    if (this[OBJECTMODE]) n = null;\n\n    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n      if (this.encoding) this[BUFFER] = [this[BUFFER].join('')];else this[BUFFER] = [Buffer.concat(this[BUFFER], this[BUFFERLENGTH])];\n    }\n\n    const ret = this[READ](n || null, this[BUFFER][0]);\n    this[MAYBE_EMIT_END]();\n    return ret;\n  }\n\n  [READ](n, chunk) {\n    if (n === chunk.length || n === null) this[BUFFERSHIFT]();else {\n      this[BUFFER][0] = chunk.slice(n);\n      chunk = chunk.slice(0, n);\n      this[BUFFERLENGTH] -= n;\n    }\n    this.emit('data', chunk);\n    if (!this[BUFFER].length && !this[EOF]) this.emit('drain');\n    return chunk;\n  }\n\n  end(chunk, encoding, cb) {\n    if (typeof chunk === 'function') cb = chunk, chunk = null;\n    if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n    if (chunk) this.write(chunk, encoding);\n    if (cb) this.once('end', cb);\n    this[EOF] = true;\n    this.writable = false; // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n\n    if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();\n    return this;\n  } // don't let the internal resume be overwritten\n\n\n  [RESUME]() {\n    if (this[DESTROYED]) return;\n    this[PAUSED] = false;\n    this[FLOWING] = true;\n    this.emit('resume');\n    if (this[BUFFER].length) this[FLUSH]();else if (this[EOF]) this[MAYBE_EMIT_END]();else this.emit('drain');\n  }\n\n  resume() {\n    return this[RESUME]();\n  }\n\n  pause() {\n    this[FLOWING] = false;\n    this[PAUSED] = true;\n  }\n\n  get destroyed() {\n    return this[DESTROYED];\n  }\n\n  get flowing() {\n    return this[FLOWING];\n  }\n\n  get paused() {\n    return this[PAUSED];\n  }\n\n  [BUFFERPUSH](chunk) {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;else this[BUFFERLENGTH] += chunk.length;\n    this[BUFFER].push(chunk);\n  }\n\n  [BUFFERSHIFT]() {\n    if (this[BUFFER].length) {\n      if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;else this[BUFFERLENGTH] -= this[BUFFER][0].length;\n    }\n\n    return this[BUFFER].shift();\n  }\n\n  [FLUSH](noDrain) {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));\n\n    if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit('drain');\n  }\n\n  [FLUSHCHUNK](chunk) {\n    return chunk ? (this.emit('data', chunk), this.flowing) : false;\n  }\n\n  pipe(dest, opts) {\n    if (this[DESTROYED]) return;\n    const ended = this[EMITTED_END];\n    opts = opts || {};\n    if (dest === proc.stdout || dest === proc.stderr) opts.end = false;else opts.end = opts.end !== false;\n    opts.proxyErrors = !!opts.proxyErrors; // piping an ended stream ends immediately\n\n    if (ended) {\n      if (opts.end) dest.end();\n    } else {\n      this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));\n      if (this[ASYNC]) defer(() => this[RESUME]());else this[RESUME]();\n    }\n\n    return dest;\n  }\n\n  unpipe(dest) {\n    const p = this[PIPES].find(p => p.dest === dest);\n\n    if (p) {\n      this[PIPES].splice(this[PIPES].indexOf(p), 1);\n      p.unpipe();\n    }\n  }\n\n  addListener(ev, fn) {\n    return this.on(ev, fn);\n  }\n\n  on(ev, fn) {\n    const ret = super.on(ev, fn);\n    if (ev === 'data' && !this[PIPES].length && !this.flowing) this[RESUME]();else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) super.emit('readable');else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev);\n      this.removeAllListeners(ev);\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      if (this[ASYNC]) defer(() => fn.call(this, this[EMITTED_ERROR]));else fn.call(this, this[EMITTED_ERROR]);\n    }\n    return ret;\n  }\n\n  get emittedEnd() {\n    return this[EMITTED_END];\n  }\n\n  [MAYBE_EMIT_END]() {\n    if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {\n      this[EMITTING_END] = true;\n      this.emit('end');\n      this.emit('prefinish');\n      this.emit('finish');\n      if (this[CLOSED]) this.emit('close');\n      this[EMITTING_END] = false;\n    }\n  }\n\n  emit(ev, data) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED]) return;else if (ev === 'data') {\n      return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? defer(() => this[EMITDATA](data)) : this[EMITDATA](data);\n    } else if (ev === 'end') {\n      return this[EMITEND]();\n    } else if (ev === 'close') {\n      this[CLOSED] = true; // don't emit close before 'end' and 'finish'\n\n      if (!this[EMITTED_END] && !this[DESTROYED]) return;\n      const ret = super.emit('close');\n      this.removeAllListeners('close');\n      return ret;\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data;\n      super.emit(ERROR, data);\n      const ret = super.emit('error', data);\n      this[MAYBE_EMIT_END]();\n      return ret;\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume');\n      this[MAYBE_EMIT_END]();\n      return ret;\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev);\n      this.removeAllListeners(ev);\n      return ret;\n    } // Some other unknown event\n\n    for (var _len = arguments.length, extra = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      extra[_key - 2] = arguments[_key];\n    }\n\n    const ret = super.emit(ev, data, ...extra);\n    this[MAYBE_EMIT_END]();\n    return ret;\n  }\n\n  [EMITDATA](data) {\n    for (const p of this[PIPES]) {\n      if (p.dest.write(data) === false) this.pause();\n    }\n\n    const ret = super.emit('data', data);\n    this[MAYBE_EMIT_END]();\n    return ret;\n  }\n\n  [EMITEND]() {\n    if (this[EMITTED_END]) return;\n    this[EMITTED_END] = true;\n    this.readable = false;\n    if (this[ASYNC]) defer(() => this[EMITEND2]());else this[EMITEND2]();\n  }\n\n  [EMITEND2]() {\n    if (this[DECODER]) {\n      const data = this[DECODER].end();\n\n      if (data) {\n        for (const p of this[PIPES]) {\n          p.dest.write(data);\n        }\n\n        super.emit('data', data);\n      }\n    }\n\n    for (const p of this[PIPES]) {\n      p.end();\n    }\n\n    const ret = super.emit('end');\n    this.removeAllListeners('end');\n    return ret;\n  } // const all = await stream.collect()\n\n\n  collect() {\n    const buf = [];\n    if (!this[OBJECTMODE]) buf.dataLength = 0; // set the promise first, in case an error is raised\n    // by triggering the flow here.\n\n    const p = this.promise();\n    this.on('data', c => {\n      buf.push(c);\n      if (!this[OBJECTMODE]) buf.dataLength += c.length;\n    });\n    return p.then(() => buf);\n  } // const data = await stream.concat()\n\n\n  concat() {\n    return this[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : this.collect().then(buf => this[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : this[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength));\n  } // stream.promise().then(() => done, er => emitted error)\n\n\n  promise() {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')));\n      this.on('error', er => reject(er));\n      this.on(ABORT, er => reject(er));\n      this.on('end', () => resolve());\n    });\n  } // for await (let chunk of stream)\n\n\n  [ASYNCITERATOR]() {\n    let stopped = false;\n\n    const stop = () => {\n      this.pause();\n      stopped = true;\n      return Promise.resolve({\n        done: true\n      });\n    };\n\n    const next = () => {\n      if (stopped) return stop();\n      const res = this.read();\n      if (res !== null) return Promise.resolve({\n        done: false,\n        value: res\n      });\n      if (this[EOF]) return stop();\n      let resolve = null;\n      let reject = null;\n\n      const onerr = er => {\n        this.removeListener('data', ondata);\n        this.removeListener('end', onend);\n        stop();\n        reject(er);\n      };\n\n      const ondata = value => {\n        this.removeListener('error', onerr);\n        this.removeListener(ABORT, onerr);\n        this.removeListener('end', onend);\n        this.pause();\n        resolve({\n          value: value,\n          done: !!this[EOF]\n        });\n      };\n\n      const onend = () => {\n        this.removeListener('error', onerr);\n        this.removeListener(ABORT, onerr);\n        this.removeListener('data', ondata);\n        stop();\n        resolve({\n          done: true\n        });\n      };\n\n      const ondestroy = () => onerr(new Error('stream destroyed'));\n\n      return new Promise((res, rej) => {\n        reject = rej;\n        resolve = res;\n        this.once(DESTROYED, ondestroy);\n        this.once('error', onerr);\n        this.once(ABORT, onerr);\n        this.once('end', onend);\n        this.once('data', ondata);\n      });\n    };\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n\n      [ASYNCITERATOR]() {\n        return this;\n      }\n\n    };\n  } // for (let chunk of stream)\n\n\n  [ITERATOR]() {\n    let stopped = false;\n\n    const stop = () => {\n      this.pause();\n      this.removeListener(ERROR, stop);\n      this.removeListener(ABORT, stop);\n      this.removeListener('end', stop);\n      stopped = true;\n      return {\n        done: true\n      };\n    };\n\n    const next = () => {\n      if (stopped) return stop();\n      const value = this.read();\n      return value === null ? stop() : {\n        value\n      };\n    };\n\n    this.once('end', stop);\n    this.once(ERROR, stop);\n    this.once(ABORT, stop);\n    return {\n      next,\n      throw: stop,\n      return: stop,\n\n      [ITERATOR]() {\n        return this;\n      }\n\n    };\n  }\n\n  destroy(er) {\n    if (this[DESTROYED]) {\n      if (er) this.emit('error', er);else this.emit(DESTROYED);\n      return this;\n    }\n\n    this[DESTROYED] = true; // throw away all buffered data, it's never coming out\n\n    this[BUFFER].length = 0;\n    this[BUFFERLENGTH] = 0;\n    if (typeof this.close === 'function' && !this[CLOSED]) this.close();\n    if (er) this.emit('error', er); // if no error to emit, still reject pending promises\n    else this.emit(DESTROYED);\n    return this;\n  }\n\n  static isStream(s) {\n    return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && ( // readable\n    typeof s.pipe === 'function' || // writable\n    typeof s.write === 'function' && typeof s.end === 'function'));\n  }\n\n}\n\nmodule.exports = Minipass;","map":{"version":3,"names":["proc","process","stdout","stderr","EE","require","Stream","stringdecoder","SD","StringDecoder","EOF","Symbol","MAYBE_EMIT_END","EMITTED_END","EMITTING_END","EMITTED_ERROR","CLOSED","READ","FLUSH","FLUSHCHUNK","ENCODING","DECODER","FLOWING","PAUSED","RESUME","BUFFER","PIPES","BUFFERLENGTH","BUFFERPUSH","BUFFERSHIFT","OBJECTMODE","DESTROYED","ERROR","EMITDATA","EMITEND","EMITEND2","ASYNC","ABORT","ABORTED","SIGNAL","defer","fn","Promise","resolve","then","doIter","global","_MP_NO_ITERATOR_SYMBOLS_","ASYNCITERATOR","asyncIterator","ITERATOR","iterator","isEndish","ev","isArrayBuffer","b","ArrayBuffer","constructor","name","byteLength","isArrayBufferView","Buffer","isBuffer","isView","Pipe","src","dest","opts","ondrain","on","unpipe","removeListener","proxyErrors","end","PipeProxyErrors","er","emit","Minipass","options","signal","addEventListener","objectMode","encoding","async","writable","readable","debugExposeBuffer","Object","defineProperty","get","debugExposePipes","bufferLength","enc","Error","lastNeed","length","map","chunk","write","setEncoding","om","a","pipe","addListener","off","p","removeAllListeners","reason","aborted","_","cb","assign","code","f","from","buffer","byteOffset","flowing","read","n","join","concat","ret","slice","once","resume","pause","destroyed","paused","push","shift","noDrain","ended","find","splice","indexOf","call","emittedEnd","data","extra","collect","buf","dataLength","promise","c","reject","stopped","stop","done","next","res","value","onerr","ondata","onend","ondestroy","rej","throw","return","destroy","close","isStream","s","module","exports"],"sources":["/Users/aurele/Desktop/E-Commerce App/views/node_modules/minipass/index.js"],"sourcesContent":["'use strict'\nconst proc =\n  typeof process === 'object' && process\n    ? process\n    : {\n        stdout: null,\n        stderr: null,\n      }\nconst EE = require('events')\nconst Stream = require('stream')\nconst stringdecoder = require('string_decoder')\nconst SD = stringdecoder.StringDecoder\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst EMITTED_ERROR = Symbol('emittedError')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFER = Symbol('buffer')\nconst PIPES = Symbol('pipes')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\n// internal event when stream is destroyed\nconst DESTROYED = Symbol('destroyed')\n// internal event when stream has an error\nconst ERROR = Symbol('error')\nconst EMITDATA = Symbol('emitData')\nconst EMITEND = Symbol('emitEnd')\nconst EMITEND2 = Symbol('emitEnd2')\nconst ASYNC = Symbol('async')\nconst ABORT = Symbol('abort')\nconst ABORTED = Symbol('aborted')\nconst SIGNAL = Symbol('signal')\n\nconst defer = fn => Promise.resolve().then(fn)\n\n// TODO remove when Node v8 support drops\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== '1'\nconst ASYNCITERATOR =\n  (doIter && Symbol.asyncIterator) || Symbol('asyncIterator not implemented')\nconst ITERATOR =\n  (doIter && Symbol.iterator) || Symbol('iterator not implemented')\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\nconst isEndish = ev => ev === 'end' || ev === 'finish' || ev === 'prefinish'\n\nconst isArrayBuffer = b =>\n  b instanceof ArrayBuffer ||\n  (typeof b === 'object' &&\n    b.constructor &&\n    b.constructor.name === 'ArrayBuffer' &&\n    b.byteLength >= 0)\n\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b)\n\nclass Pipe {\n  constructor(src, dest, opts) {\n    this.src = src\n    this.dest = dest\n    this.opts = opts\n    this.ondrain = () => src[RESUME]()\n    dest.on('drain', this.ondrain)\n  }\n  unpipe() {\n    this.dest.removeListener('drain', this.ondrain)\n  }\n  // istanbul ignore next - only here for the prototype\n  proxyErrors() {}\n  end() {\n    this.unpipe()\n    if (this.opts.end) this.dest.end()\n  }\n}\n\nclass PipeProxyErrors extends Pipe {\n  unpipe() {\n    this.src.removeListener('error', this.proxyErrors)\n    super.unpipe()\n  }\n  constructor(src, dest, opts) {\n    super(src, dest, opts)\n    this.proxyErrors = er => dest.emit('error', er)\n    src.on('error', this.proxyErrors)\n  }\n}\n\nclass Minipass extends Stream {\n  constructor(options) {\n    super()\n    this[SIGNAL] = options && options.signal\n    if (this[SIGNAL]) {\n      this[SIGNAL].addEventListener('abort', () => this[ABORT]())\n    }\n    this[ABORTED] = false\n    this[FLOWING] = false\n    // whether we're explicitly paused\n    this[PAUSED] = false\n    this[PIPES] = []\n    this[BUFFER] = []\n    this[OBJECTMODE] = (options && options.objectMode) || false\n    if (this[OBJECTMODE]) this[ENCODING] = null\n    else this[ENCODING] = (options && options.encoding) || null\n    if (this[ENCODING] === 'buffer') this[ENCODING] = null\n    this[ASYNC] = (options && !!options.async) || false\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null\n    this[EOF] = false\n    this[EMITTED_END] = false\n    this[EMITTING_END] = false\n    this[CLOSED] = false\n    this[EMITTED_ERROR] = null\n    this.writable = true\n    this.readable = true\n    this[BUFFERLENGTH] = 0\n    this[DESTROYED] = false\n    if (options && options.debugExposeBuffer === true) {\n      Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] })\n    }\n    if (options && options.debugExposePipes === true) {\n      Object.defineProperty(this, 'pipes', { get: () => this[PIPES] })\n    }\n  }\n\n  get bufferLength() {\n    return this[BUFFERLENGTH]\n  }\n\n  get encoding() {\n    return this[ENCODING]\n  }\n  set encoding(enc) {\n    if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode')\n\n    if (\n      this[ENCODING] &&\n      enc !== this[ENCODING] &&\n      ((this[DECODER] && this[DECODER].lastNeed) || this[BUFFERLENGTH])\n    )\n      throw new Error('cannot change encoding')\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null\n      if (this[BUFFER].length)\n        this[BUFFER] = this[BUFFER].map(chunk => this[DECODER].write(chunk))\n    }\n\n    this[ENCODING] = enc\n  }\n\n  setEncoding(enc) {\n    this.encoding = enc\n  }\n\n  get objectMode() {\n    return this[OBJECTMODE]\n  }\n  set objectMode(om) {\n    this[OBJECTMODE] = this[OBJECTMODE] || !!om\n  }\n\n  get ['async']() {\n    return this[ASYNC]\n  }\n  set ['async'](a) {\n    this[ASYNC] = this[ASYNC] || !!a\n  }\n\n  // drop everything and get out of the flow completely\n  [ABORT]() {\n    this[ABORTED] = true\n    const signal = this[SIGNAL]\n    /* istanbul ignore next */\n    if (this.write) this.write = () => {}\n    /* istanbul ignore next */\n    if (this.end) this.end = () => {}\n    /* istanbul ignore next */\n    if (this.pipe) this.pipe = () => {}\n    /* istanbul ignore next */\n    this.on = this.addListener = () => {}\n    /* istanbul ignore next */\n    this.off = this.removeListener = () => {}\n    /* istanbul ignore next */\n    this[ABORT] = () => {}\n    /* istanbul ignore next */\n    this.emit = () => {}\n    for (const p of this[PIPES]) {\n      p.unpipe()\n    }\n    super.removeAllListeners('data')\n    super.removeAllListeners('end')\n    super.removeAllListeners('drain')\n    super.removeAllListeners('resume')\n    this[BUFFER].length = 0\n    this.readable = false\n    this.writable = false\n    super.emit(ABORT, signal.reason)\n    super.emit('abort', signal.reason)\n    super.emit('end')\n    super.emit('prefinish')\n    super.emit('finish')\n    super.emit('close')\n  }\n\n  get aborted() {\n    return this[ABORTED]\n  }\n  set aborted(_) {}\n\n  write(chunk, encoding, cb) {\n    if (this[EOF]) throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit(\n        'error',\n        Object.assign(\n          new Error('Cannot call write after a stream was destroyed'),\n          { code: 'ERR_STREAM_DESTROYED' }\n        )\n      )\n      return true\n    }\n\n    if (typeof encoding === 'function') (cb = encoding), (encoding = 'utf8')\n\n    if (!encoding) encoding = 'utf8'\n\n    const fn = this[ASYNC] ? defer : f => f()\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk))\n        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n      else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk)\n      else if (typeof chunk !== 'string')\n        // use the setter so we throw if we have encoding set\n        this.objectMode = true\n    }\n\n    // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n    if (this[OBJECTMODE]) {\n      /* istanbul ignore if - maybe impossible? */\n      if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n\n      if (this.flowing) this.emit('data', chunk)\n      else this[BUFFERPUSH](chunk)\n\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n      if (cb) fn(cb)\n\n      return this.flowing\n    }\n\n    // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!chunk.length) {\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n      if (cb) fn(cb)\n      return this.flowing\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (\n      typeof chunk === 'string' &&\n      // unless it is a string already ready for us to use\n      !(encoding === this[ENCODING] && !this[DECODER].lastNeed)\n    ) {\n      chunk = Buffer.from(chunk, encoding)\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING])\n      chunk = this[DECODER].write(chunk)\n\n    // Note: flushing CAN potentially switch us into not-flowing mode\n    if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n\n    if (this.flowing) this.emit('data', chunk)\n    else this[BUFFERPUSH](chunk)\n\n    if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n    if (cb) fn(cb)\n\n    return this.flowing\n  }\n\n  read(n) {\n    if (this[DESTROYED]) return null\n\n    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {\n      this[MAYBE_EMIT_END]()\n      return null\n    }\n\n    if (this[OBJECTMODE]) n = null\n\n    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n      if (this.encoding) this[BUFFER] = [this[BUFFER].join('')]\n      else this[BUFFER] = [Buffer.concat(this[BUFFER], this[BUFFERLENGTH])]\n    }\n\n    const ret = this[READ](n || null, this[BUFFER][0])\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [READ](n, chunk) {\n    if (n === chunk.length || n === null) this[BUFFERSHIFT]()\n    else {\n      this[BUFFER][0] = chunk.slice(n)\n      chunk = chunk.slice(0, n)\n      this[BUFFERLENGTH] -= n\n    }\n\n    this.emit('data', chunk)\n\n    if (!this[BUFFER].length && !this[EOF]) this.emit('drain')\n\n    return chunk\n  }\n\n  end(chunk, encoding, cb) {\n    if (typeof chunk === 'function') (cb = chunk), (chunk = null)\n    if (typeof encoding === 'function') (cb = encoding), (encoding = 'utf8')\n    if (chunk) this.write(chunk, encoding)\n    if (cb) this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME]() {\n    if (this[DESTROYED]) return\n\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this[BUFFER].length) this[FLUSH]()\n    else if (this[EOF]) this[MAYBE_EMIT_END]()\n    else this.emit('drain')\n  }\n\n  resume() {\n    return this[RESUME]()\n  }\n\n  pause() {\n    this[FLOWING] = false\n    this[PAUSED] = true\n  }\n\n  get destroyed() {\n    return this[DESTROYED]\n  }\n\n  get flowing() {\n    return this[FLOWING]\n  }\n\n  get paused() {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH](chunk) {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1\n    else this[BUFFERLENGTH] += chunk.length\n    this[BUFFER].push(chunk)\n  }\n\n  [BUFFERSHIFT]() {\n    if (this[BUFFER].length) {\n      if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1\n      else this[BUFFERLENGTH] -= this[BUFFER][0].length\n    }\n    return this[BUFFER].shift()\n  }\n\n  [FLUSH](noDrain) {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))\n\n    if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit('drain')\n  }\n\n  [FLUSHCHUNK](chunk) {\n    return chunk ? (this.emit('data', chunk), this.flowing) : false\n  }\n\n  pipe(dest, opts) {\n    if (this[DESTROYED]) return\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === proc.stdout || dest === proc.stderr) opts.end = false\n    else opts.end = opts.end !== false\n    opts.proxyErrors = !!opts.proxyErrors\n\n    // piping an ended stream ends immediately\n    if (ended) {\n      if (opts.end) dest.end()\n    } else {\n      this[PIPES].push(\n        !opts.proxyErrors\n          ? new Pipe(this, dest, opts)\n          : new PipeProxyErrors(this, dest, opts)\n      )\n      if (this[ASYNC]) defer(() => this[RESUME]())\n      else this[RESUME]()\n    }\n\n    return dest\n  }\n\n  unpipe(dest) {\n    const p = this[PIPES].find(p => p.dest === dest)\n    if (p) {\n      this[PIPES].splice(this[PIPES].indexOf(p), 1)\n      p.unpipe()\n    }\n  }\n\n  addListener(ev, fn) {\n    return this.on(ev, fn)\n  }\n\n  on(ev, fn) {\n    const ret = super.on(ev, fn)\n    if (ev === 'data' && !this[PIPES].length && !this.flowing) this[RESUME]()\n    else if (ev === 'readable' && this[BUFFERLENGTH] !== 0)\n      super.emit('readable')\n    else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev)\n      this.removeAllListeners(ev)\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      if (this[ASYNC]) defer(() => fn.call(this, this[EMITTED_ERROR]))\n      else fn.call(this, this[EMITTED_ERROR])\n    }\n    return ret\n  }\n\n  get emittedEnd() {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END]() {\n    if (\n      !this[EMITTING_END] &&\n      !this[EMITTED_END] &&\n      !this[DESTROYED] &&\n      this[BUFFER].length === 0 &&\n      this[EOF]\n    ) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED]) this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  emit(ev, data, ...extra) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])\n      return\n    else if (ev === 'data') {\n      return !this[OBJECTMODE] && !data\n        ? false\n        : this[ASYNC]\n        ? defer(() => this[EMITDATA](data))\n        : this[EMITDATA](data)\n    } else if (ev === 'end') {\n      return this[EMITEND]()\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED]) return\n      const ret = super.emit('close')\n      this.removeAllListeners('close')\n      return ret\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data\n      super.emit(ERROR, data)\n      const ret = super.emit('error', data)\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume')\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev)\n      this.removeAllListeners(ev)\n      return ret\n    }\n\n    // Some other unknown event\n    const ret = super.emit(ev, data, ...extra)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITDATA](data) {\n    for (const p of this[PIPES]) {\n      if (p.dest.write(data) === false) this.pause()\n    }\n    const ret = super.emit('data', data)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITEND]() {\n    if (this[EMITTED_END]) return\n\n    this[EMITTED_END] = true\n    this.readable = false\n    if (this[ASYNC]) defer(() => this[EMITEND2]())\n    else this[EMITEND2]()\n  }\n\n  [EMITEND2]() {\n    if (this[DECODER]) {\n      const data = this[DECODER].end()\n      if (data) {\n        for (const p of this[PIPES]) {\n          p.dest.write(data)\n        }\n        super.emit('data', data)\n      }\n    }\n\n    for (const p of this[PIPES]) {\n      p.end()\n    }\n    const ret = super.emit('end')\n    this.removeAllListeners('end')\n    return ret\n  }\n\n  // const all = await stream.collect()\n  collect() {\n    const buf = []\n    if (!this[OBJECTMODE]) buf.dataLength = 0\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise()\n    this.on('data', c => {\n      buf.push(c)\n      if (!this[OBJECTMODE]) buf.dataLength += c.length\n    })\n    return p.then(() => buf)\n  }\n\n  // const data = await stream.concat()\n  concat() {\n    return this[OBJECTMODE]\n      ? Promise.reject(new Error('cannot concat in objectMode'))\n      : this.collect().then(buf =>\n          this[OBJECTMODE]\n            ? Promise.reject(new Error('cannot concat in objectMode'))\n            : this[ENCODING]\n            ? buf.join('')\n            : Buffer.concat(buf, buf.dataLength)\n        )\n  }\n\n  // stream.promise().then(() => done, er => emitted error)\n  promise() {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('error', er => reject(er))\n      this.on(ABORT, er => reject(er))\n      this.on('end', () => resolve())\n    })\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR]() {\n    let stopped = false\n    const stop = () => {\n      this.pause()\n      stopped = true\n      return Promise.resolve({ done: true })\n    }\n    const next = () => {\n      if (stopped) return stop()\n      const res = this.read()\n      if (res !== null) return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF]) return stop()\n\n      let resolve = null\n      let reject = null\n      const onerr = er => {\n        this.removeListener('data', ondata)\n        this.removeListener('end', onend)\n        stop()\n        reject(er)\n      }\n      const ondata = value => {\n        this.removeListener('error', onerr)\n        this.removeListener(ABORT, onerr)\n        this.removeListener('end', onend)\n        this.pause()\n        resolve({ value: value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.removeListener('error', onerr)\n        this.removeListener(ABORT, onerr)\n        this.removeListener('data', ondata)\n        stop()\n        resolve({ done: true })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once(ABORT, onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [ASYNCITERATOR]() {\n        return this\n      },\n    }\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR]() {\n    let stopped = false\n    const stop = () => {\n      this.pause()\n      this.removeListener(ERROR, stop)\n      this.removeListener(ABORT, stop)\n      this.removeListener('end', stop)\n      stopped = true\n      return { done: true }\n    }\n\n    const next = () => {\n      if (stopped) return stop()\n      const value = this.read()\n      return value === null ? stop() : { value }\n    }\n    this.once('end', stop)\n    this.once(ERROR, stop)\n    this.once(ABORT, stop)\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [ITERATOR]() {\n        return this\n      },\n    }\n  }\n\n  destroy(er) {\n    if (this[DESTROYED]) {\n      if (er) this.emit('error', er)\n      else this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n\n    // throw away all buffered data, it's never coming out\n    this[BUFFER].length = 0\n    this[BUFFERLENGTH] = 0\n\n    if (typeof this.close === 'function' && !this[CLOSED]) this.close()\n\n    if (er) this.emit('error', er)\n    // if no error to emit, still reject pending promises\n    else this.emit(DESTROYED)\n\n    return this\n  }\n\n  static isStream(s) {\n    return (\n      !!s &&\n      (s instanceof Minipass ||\n        s instanceof Stream ||\n        (s instanceof EE &&\n          // readable\n          (typeof s.pipe === 'function' ||\n            // writable\n            (typeof s.write === 'function' && typeof s.end === 'function'))))\n    )\n  }\n}\n\nmodule.exports = Minipass\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}