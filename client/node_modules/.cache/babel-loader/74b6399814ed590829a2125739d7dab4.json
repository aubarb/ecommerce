{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nconst Utils = require(\"./../utils\");\n\nconst Helpers = require(\"./helpers\");\n\nconst _ = require(\"lodash\");\n\nconst Association = require(\"./base\");\n\nconst Op = require(\"../operators\");\n\nclass HasOne extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n    this.associationType = \"HasOne\";\n    this.isSingleAssociation = true;\n    this.foreignKeyAttribute = {};\n\n    if (this.as) {\n      this.isAliased = true;\n      this.options.name = {\n        singular: this.as\n      };\n    } else {\n      this.as = this.target.options.name.singular;\n      this.options.name = this.target.options.name;\n    }\n\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelize([Utils.singularize(this.options.as || this.source.name), this.source.primaryKeyAttribute].join(\"_\"));\n    }\n\n    if (this.options.sourceKey && !this.source.rawAttributes[this.options.sourceKey]) {\n      throw new Error(`Unknown attribute \"${this.options.sourceKey}\" passed as sourceKey, define this attribute on model \"${this.source.name}\" first`);\n    }\n\n    this.sourceKey = this.sourceKeyAttribute = this.options.sourceKey || this.source.primaryKeyAttribute;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    this.sourceKeyIsPrimary = this.sourceKey === this.source.primaryKeyAttribute;\n    this.associationAccessor = this.as;\n    this.options.useHooks = options.useHooks;\n\n    if (this.target.rawAttributes[this.foreignKey]) {\n      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    }\n\n    const singular = _.upperFirst(this.options.name.singular);\n\n    this.accessors = {\n      get: `get${singular}`,\n      set: `set${singular}`,\n      create: `create${singular}`\n    };\n  }\n\n  _injectAttributes() {\n    const newAttributes = {\n      [this.foreignKey]: __spreadValues({\n        type: this.options.keyType || this.source.rawAttributes[this.sourceKey].type,\n        allowNull: true\n      }, this.foreignKeyAttribute)\n    };\n\n    if (this.options.constraints !== false) {\n      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      this.options.onDelete = this.options.onDelete || (target.allowNull ? \"SET NULL\" : \"CASCADE\");\n      this.options.onUpdate = this.options.onUpdate || \"CASCADE\";\n    }\n\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, this.options, this.sourceKeyField);\n    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);\n    this.target.refreshAttributes();\n    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    Helpers.checkNamingCollision(this);\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = [\"get\", \"set\", \"create\"];\n    Helpers.mixinMethods(this, obj, methods);\n  }\n\n  async get(instances, options) {\n    const where = {};\n    let Target = this.target;\n    let instance;\n    options = Utils.cloneDeep(options);\n\n    if (Object.prototype.hasOwnProperty.call(options, \"scope\")) {\n      if (!options.scope) {\n        Target = Target.unscoped();\n      } else {\n        Target = Target.scope(options.scope);\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, \"schema\")) {\n      Target = Target.schema(options.schema, options.schemaDelimiter);\n    }\n\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = void 0;\n    }\n\n    if (instances) {\n      where[this.foreignKey] = {\n        [Op.in]: instances.map(_instance => _instance.get(this.sourceKey))\n      };\n    } else {\n      where[this.foreignKey] = instance.get(this.sourceKey);\n    }\n\n    if (this.scope) {\n      Object.assign(where, this.scope);\n    }\n\n    options.where = options.where ? {\n      [Op.and]: [where, options.where]\n    } : where;\n\n    if (instances) {\n      const results = await Target.findAll(options);\n      const result = {};\n\n      for (const _instance of instances) {\n        result[_instance.get(this.sourceKey, {\n          raw: true\n        })] = null;\n      }\n\n      for (const _instance of results) {\n        result[_instance.get(this.foreignKey, {\n          raw: true\n        })] = _instance;\n      }\n\n      return result;\n    }\n\n    return Target.findOne(options);\n  }\n\n  async set(sourceInstance, associatedInstance, options) {\n    options = __spreadProps(__spreadValues({}, options), {\n      scope: false\n    });\n    const oldInstance = await sourceInstance[this.accessors.get](options);\n    const alreadyAssociated = oldInstance && associatedInstance && this.target.primaryKeyAttributes.every(attribute => oldInstance.get(attribute, {\n      raw: true\n    }) === (associatedInstance.get ? associatedInstance.get(attribute, {\n      raw: true\n    }) : associatedInstance));\n\n    if (oldInstance && !alreadyAssociated) {\n      oldInstance[this.foreignKey] = null;\n      await oldInstance.save(__spreadProps(__spreadValues({}, options), {\n        fields: [this.foreignKey],\n        allowNull: [this.foreignKey],\n        association: true\n      }));\n    }\n\n    if (associatedInstance && !alreadyAssociated) {\n      if (!(associatedInstance instanceof this.target)) {\n        const tmpInstance = {};\n        tmpInstance[this.target.primaryKeyAttribute] = associatedInstance;\n        associatedInstance = this.target.build(tmpInstance, {\n          isNewRecord: false\n        });\n      }\n\n      Object.assign(associatedInstance, this.scope);\n      associatedInstance.set(this.foreignKey, sourceInstance.get(this.sourceKeyAttribute));\n      return associatedInstance.save(options);\n    }\n\n    return null;\n  }\n\n  async create(sourceInstance, values, options) {\n    values = values || {};\n    options = options || {};\n\n    if (this.scope) {\n      for (const attribute of Object.keys(this.scope)) {\n        values[attribute] = this.scope[attribute];\n\n        if (options.fields) {\n          options.fields.push(attribute);\n        }\n      }\n    }\n\n    values[this.foreignKey] = sourceInstance.get(this.sourceKeyAttribute);\n\n    if (options.fields) {\n      options.fields.push(this.foreignKey);\n    }\n\n    return await this.target.create(values, options);\n  }\n\n  verifyAssociationAlias(alias) {\n    if (typeof alias === \"string\") {\n      return this.as === alias;\n    }\n\n    if (alias && alias.singular) {\n      return this.as === alias.singular;\n    }\n\n    return !this.isAliased;\n  }\n\n}\n\nmodule.exports = HasOne;","map":{"version":3,"mappings":"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","names":["Utils","require","Helpers","_","Association","Op","constructor","source","target","options","associationType","isSingleAssociation","foreignKeyAttribute","as","isAliased","name","singular","isObject","foreignKey","fieldName","camelize","singularize","primaryKeyAttribute","join","sourceKey","rawAttributes","Error","sourceKeyAttribute","sourceKeyField","field","sourceKeyIsPrimary","associationAccessor","useHooks","identifierField","upperFirst","accessors","get","set","create","_injectAttributes","newAttributes","__spreadValues","type","keyType","allowNull","constraints","onDelete","onUpdate","addForeignKeyConstraints","mergeDefaults","refreshAttributes","checkNamingCollision","mixin","obj","methods","mixinMethods","instances","where","Target","instance","cloneDeep","Object","prototype","hasOwnProperty","call","scope","unscoped","schema","schemaDelimiter","Array","isArray","in","map","_instance","assign","and","results","findAll","result","raw","findOne","sourceInstance","associatedInstance","__spreadProps","oldInstance","alreadyAssociated","primaryKeyAttributes","every","attribute","save","fields","association","tmpInstance","build","isNewRecord","values","keys","push","verifyAssociationAlias","alias","module","exports","HasOne"],"sources":["/Users/aurele/node_modules/sequelize/src/associations/has-one.js"],"sourcesContent":["'use strict';\n\nconst Utils = require('./../utils');\nconst Helpers = require('./helpers');\nconst _ = require('lodash');\nconst Association = require('./base');\nconst Op = require('../operators');\n\n/**\n * One-to-one association\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.hasOne(Project)` the getter will be `user.getProject()`.\n * This is almost the same as `belongsTo` with one exception - The foreign key will be defined on the target model.\n *\n * @see {@link Model.hasOne}\n */\nclass HasOne extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n\n    this.associationType = 'HasOne';\n    this.isSingleAssociation = true;\n    this.foreignKeyAttribute = {};\n\n    if (this.as) {\n      this.isAliased = true;\n      this.options.name = {\n        singular: this.as\n      };\n    } else {\n      this.as = this.target.options.name.singular;\n      this.options.name = this.target.options.name;\n    }\n\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelize(\n        [\n          Utils.singularize(this.options.as || this.source.name),\n          this.source.primaryKeyAttribute\n        ].join('_')\n      );\n    }\n\n    if (\n      this.options.sourceKey\n      && !this.source.rawAttributes[this.options.sourceKey]\n    ) {\n      throw new Error(`Unknown attribute \"${this.options.sourceKey}\" passed as sourceKey, define this attribute on model \"${this.source.name}\" first`);\n    }\n\n    this.sourceKey = this.sourceKeyAttribute = this.options.sourceKey || this.source.primaryKeyAttribute;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    this.sourceKeyIsPrimary = this.sourceKey === this.source.primaryKeyAttribute;\n\n    this.associationAccessor = this.as;\n    this.options.useHooks = options.useHooks;\n\n    if (this.target.rawAttributes[this.foreignKey]) {\n      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    }\n\n    // Get singular name, trying to uppercase the first letter, unless the model forbids it\n    const singular = _.upperFirst(this.options.name.singular);\n\n    this.accessors = {\n      get: `get${singular}`,\n      set: `set${singular}`,\n      create: `create${singular}`\n    };\n  }\n\n  // the id is in the target table\n  _injectAttributes() {\n    const newAttributes = {\n      [this.foreignKey]: {\n        type: this.options.keyType || this.source.rawAttributes[this.sourceKey].type,\n        allowNull: true,\n        ...this.foreignKeyAttribute\n      }\n    };\n\n    if (this.options.constraints !== false) {\n      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      this.options.onDelete = this.options.onDelete || (target.allowNull ? 'SET NULL' : 'CASCADE');\n      this.options.onUpdate = this.options.onUpdate || 'CASCADE';\n    }\n\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, this.options, this.sourceKeyField);\n    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);\n\n    this.target.refreshAttributes();\n\n    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n\n    Helpers.checkNamingCollision(this);\n\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'set', 'create'];\n\n    Helpers.mixinMethods(this, obj, methods);\n  }\n\n  /**\n   * Get the associated instance.\n   *\n   * @param {Model|Array<Model>} instances source instances\n   * @param {object}         [options] find options\n   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @param {string} [options.schema] Apply a schema on the related model\n   *\n   * @see\n   * {@link Model.findOne} for a full explanation of options\n   *\n   * @returns {Promise<Model>}\n   */\n  async get(instances, options) {\n    const where = {};\n\n    let Target = this.target;\n    let instance;\n\n    options = Utils.cloneDeep(options);\n\n    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {\n      if (!options.scope) {\n        Target = Target.unscoped();\n      } else {\n        Target = Target.scope(options.scope);\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {\n      Target = Target.schema(options.schema, options.schemaDelimiter);\n    }\n\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = undefined;\n    }\n\n    if (instances) {\n      where[this.foreignKey] = {\n        [Op.in]: instances.map(_instance => _instance.get(this.sourceKey))\n      };\n    } else {\n      where[this.foreignKey] = instance.get(this.sourceKey);\n    }\n\n    if (this.scope) {\n      Object.assign(where, this.scope);\n    }\n\n    options.where = options.where ?\n      { [Op.and]: [where, options.where] } :\n      where;\n\n    if (instances) {\n      const results = await Target.findAll(options);\n      const result = {};\n      for (const _instance of instances) {\n        result[_instance.get(this.sourceKey, { raw: true })] = null;\n      }\n\n      for (const _instance of results) {\n        result[_instance.get(this.foreignKey, { raw: true })] = _instance;\n      }\n\n      return result;\n    }\n\n    return Target.findOne(options);\n  }\n\n  /**\n   * Set the associated model.\n   *\n   * @param {Model} sourceInstance the source instance\n   * @param {?Model|string|number} [associatedInstance] An persisted instance or the primary key of an instance to associate with this. Pass `null` or `undefined` to remove the association.\n   * @param {object} [options] Options passed to getAssociation and `target.save`\n   *\n   * @returns {Promise}\n   */\n  async set(sourceInstance, associatedInstance, options) {\n    options = { ...options, scope: false };\n\n    const oldInstance = await sourceInstance[this.accessors.get](options);\n    // TODO Use equals method once #5605 is resolved\n    const alreadyAssociated = oldInstance && associatedInstance && this.target.primaryKeyAttributes.every(attribute =>\n      oldInstance.get(attribute, { raw: true }) === (associatedInstance.get ? associatedInstance.get(attribute, { raw: true }) : associatedInstance)\n    );\n\n    if (oldInstance && !alreadyAssociated) {\n      oldInstance[this.foreignKey] = null;\n\n      await oldInstance.save({\n        ...options,\n        fields: [this.foreignKey],\n        allowNull: [this.foreignKey],\n        association: true\n      });\n    }\n    if (associatedInstance && !alreadyAssociated) {\n      if (!(associatedInstance instanceof this.target)) {\n        const tmpInstance = {};\n        tmpInstance[this.target.primaryKeyAttribute] = associatedInstance;\n        associatedInstance = this.target.build(tmpInstance, {\n          isNewRecord: false\n        });\n      }\n\n      Object.assign(associatedInstance, this.scope);\n      associatedInstance.set(this.foreignKey, sourceInstance.get(this.sourceKeyAttribute));\n\n      return associatedInstance.save(options);\n    }\n\n    return null;\n  }\n\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Model} sourceInstance the source instance\n   * @param {object} [values={}] values to create associated model instance with\n   * @param {object} [options] Options passed to `target.create` and setAssociation.\n   *\n   * @see\n   * {@link Model#create} for a full explanation of options\n   *\n   * @returns {Promise<Model>} The created target model\n   */\n  async create(sourceInstance, values, options) {\n    values = values || {};\n    options = options || {};\n\n    if (this.scope) {\n      for (const attribute of Object.keys(this.scope)) {\n        values[attribute] = this.scope[attribute];\n        if (options.fields) {\n          options.fields.push(attribute);\n        }\n      }\n    }\n\n    values[this.foreignKey] = sourceInstance.get(this.sourceKeyAttribute);\n    if (options.fields) {\n      options.fields.push(this.foreignKey);\n    }\n\n    return await this.target.create(values, options);\n  }\n\n  verifyAssociationAlias(alias) {\n    if (typeof alias === 'string') {\n      return this.as === alias;\n    }\n\n    if (alias && alias.singular) {\n      return this.as === alias.singular;\n    }\n\n    return !this.isAliased;\n  }\n}\n\nmodule.exports = HasOne;\n"]},"metadata":{},"sourceType":"script"}