{"ast":null,"code":"\"use strict\";\n\nmodule.exports = BaseTypes => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(void 0, \"https://www.sqlite.org/datatype3.html\");\n\n  function removeUnsupportedIntegerOptions(dataType) {\n    if (dataType._zerofill || dataType._unsigned) {\n      warn(`SQLite does not support '${dataType.key}' with UNSIGNED or ZEROFILL. Plain '${dataType.key}' will be used instead.`);\n      dataType._unsigned = void 0;\n      dataType._zerofill = void 0;\n    }\n  }\n\n  BaseTypes.DATE.types.sqlite = [\"DATETIME\"];\n  BaseTypes.STRING.types.sqlite = [\"VARCHAR\", \"VARCHAR BINARY\"];\n  BaseTypes.CHAR.types.sqlite = [\"CHAR\", \"CHAR BINARY\"];\n  BaseTypes.TEXT.types.sqlite = [\"TEXT\"];\n  BaseTypes.TINYINT.types.sqlite = [\"TINYINT\"];\n  BaseTypes.SMALLINT.types.sqlite = [\"SMALLINT\"];\n  BaseTypes.MEDIUMINT.types.sqlite = [\"MEDIUMINT\"];\n  BaseTypes.INTEGER.types.sqlite = [\"INTEGER\"];\n  BaseTypes.BIGINT.types.sqlite = [\"BIGINT\"];\n  BaseTypes.FLOAT.types.sqlite = [\"FLOAT\"];\n  BaseTypes.TIME.types.sqlite = [\"TIME\"];\n  BaseTypes.DATEONLY.types.sqlite = [\"DATE\"];\n  BaseTypes.BOOLEAN.types.sqlite = [\"TINYINT\"];\n  BaseTypes.BLOB.types.sqlite = [\"TINYBLOB\", \"BLOB\", \"LONGBLOB\"];\n  BaseTypes.DECIMAL.types.sqlite = [\"DECIMAL\"];\n  BaseTypes.UUID.types.sqlite = [\"UUID\"];\n  BaseTypes.ENUM.types.sqlite = false;\n  BaseTypes.REAL.types.sqlite = [\"REAL\"];\n  BaseTypes.DOUBLE.types.sqlite = [\"DOUBLE PRECISION\"];\n  BaseTypes.GEOMETRY.types.sqlite = false;\n  BaseTypes.JSON.types.sqlite = [\"JSON\", \"JSONB\"];\n\n  class JSONTYPE extends BaseTypes.JSON {\n    static parse(data) {\n      return JSON.parse(data);\n    }\n\n  }\n\n  class DATE extends BaseTypes.DATE {\n    static parse(date, options) {\n      if (!date.includes(\"+\")) {\n        return new Date(date + options.timezone);\n      }\n\n      return new Date(date);\n    }\n\n  }\n\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(date) {\n      return date;\n    }\n\n  }\n\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (this._binary) {\n        return `VARCHAR BINARY(${this._length})`;\n      }\n\n      return super.toSql(this);\n    }\n\n  }\n\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      if (this._length) {\n        warn(\"SQLite does not support TEXT with options. Plain `TEXT` will be used instead.\");\n        this._length = void 0;\n      }\n\n      return \"TEXT\";\n    }\n\n  }\n\n  class CITEXT extends BaseTypes.CITEXT {\n    toSql() {\n      return \"TEXT COLLATE NOCASE\";\n    }\n\n  }\n\n  class CHAR extends BaseTypes.CHAR {\n    toSql() {\n      if (this._binary) {\n        return `CHAR BINARY(${this._length})`;\n      }\n\n      return super.toSql();\n    }\n\n  }\n\n  class NUMBER extends BaseTypes.NUMBER {\n    toSql() {\n      let result = this.key;\n\n      if (this._unsigned) {\n        result += \" UNSIGNED\";\n      }\n\n      if (this._zerofill) {\n        result += \" ZEROFILL\";\n      }\n\n      if (this._length) {\n        result += `(${this._length}`;\n\n        if (typeof this._decimals === \"number\") {\n          result += `,${this._decimals}`;\n        }\n\n        result += \")\";\n      }\n\n      return result;\n    }\n\n  }\n\n  class TINYINT extends BaseTypes.TINYINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n\n  }\n\n  class SMALLINT extends BaseTypes.SMALLINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n\n  }\n\n  class MEDIUMINT extends BaseTypes.MEDIUMINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n\n  }\n\n  class INTEGER extends BaseTypes.INTEGER {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n\n  }\n\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n\n  }\n\n  class FLOAT extends BaseTypes.FLOAT {}\n\n  class DOUBLE extends BaseTypes.DOUBLE {}\n\n  class REAL extends BaseTypes.REAL {}\n\n  function parseFloating(value) {\n    if (typeof value !== \"string\") {\n      return value;\n    }\n\n    if (value === \"NaN\") {\n      return NaN;\n    }\n\n    if (value === \"Infinity\") {\n      return Infinity;\n    }\n\n    if (value === \"-Infinity\") {\n      return -Infinity;\n    }\n  }\n\n  for (const floating of [FLOAT, DOUBLE, REAL]) {\n    floating.parse = parseFloating;\n  }\n\n  for (const num of [FLOAT, DOUBLE, REAL, TINYINT, SMALLINT, MEDIUMINT, INTEGER, BIGINT]) {\n    num.prototype.toSql = NUMBER.prototype.toSql;\n  }\n\n  class ENUM extends BaseTypes.ENUM {\n    toSql() {\n      return \"TEXT\";\n    }\n\n  }\n\n  return {\n    DATE,\n    DATEONLY,\n    STRING,\n    CHAR,\n    NUMBER,\n    FLOAT,\n    REAL,\n    \"DOUBLE PRECISION\": DOUBLE,\n    TINYINT,\n    SMALLINT,\n    MEDIUMINT,\n    INTEGER,\n    BIGINT,\n    TEXT,\n    ENUM,\n    JSON: JSONTYPE,\n    CITEXT\n  };\n};","map":{"version":3,"mappings":"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","names":["module","exports","BaseTypes","warn","ABSTRACT","bind","dataType","_zerofill","_unsigned","key","DATE","types","sqlite","STRING","CHAR","TEXT","TINYINT","SMALLINT","MEDIUMINT","INTEGER","BIGINT","FLOAT","TIME","DATEONLY","BOOLEAN","BLOB","DECIMAL","UUID","ENUM","REAL","DOUBLE","GEOMETRY","JSON","data","parse","date","options","includes","Date","timezone","toSql","_binary","_length","CITEXT","NUMBER","result","_decimals","constructor","length","removeUnsupportedIntegerOptions","value","NaN","Infinity","floating","parseFloating","num","prototype","JSONTYPE"],"sources":["/Users/aurele/node_modules/sequelize/src/dialects/sqlite/data-types.js"],"sourcesContent":["'use strict';\n\nmodule.exports = BaseTypes => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(undefined, 'https://www.sqlite.org/datatype3.html');\n\n  /**\n   * Removes unsupported SQLite options, i.e., UNSIGNED and ZEROFILL, for the integer data types.\n   *\n   * @param {object} dataType The base integer data type.\n   * @private\n   */\n  function removeUnsupportedIntegerOptions(dataType) {\n    if (dataType._zerofill || dataType._unsigned) {\n      warn(`SQLite does not support '${dataType.key}' with UNSIGNED or ZEROFILL. Plain '${dataType.key}' will be used instead.`);\n      dataType._unsigned = undefined;\n      dataType._zerofill = undefined;\n    }\n  }\n\n  /**\n   * @see https://sqlite.org/datatype3.html\n   */\n\n  BaseTypes.DATE.types.sqlite = ['DATETIME'];\n  BaseTypes.STRING.types.sqlite = ['VARCHAR', 'VARCHAR BINARY'];\n  BaseTypes.CHAR.types.sqlite = ['CHAR', 'CHAR BINARY'];\n  BaseTypes.TEXT.types.sqlite = ['TEXT'];\n  BaseTypes.TINYINT.types.sqlite = ['TINYINT'];\n  BaseTypes.SMALLINT.types.sqlite = ['SMALLINT'];\n  BaseTypes.MEDIUMINT.types.sqlite = ['MEDIUMINT'];\n  BaseTypes.INTEGER.types.sqlite = ['INTEGER'];\n  BaseTypes.BIGINT.types.sqlite = ['BIGINT'];\n  BaseTypes.FLOAT.types.sqlite = ['FLOAT'];\n  BaseTypes.TIME.types.sqlite = ['TIME'];\n  BaseTypes.DATEONLY.types.sqlite = ['DATE'];\n  BaseTypes.BOOLEAN.types.sqlite = ['TINYINT'];\n  BaseTypes.BLOB.types.sqlite = ['TINYBLOB', 'BLOB', 'LONGBLOB'];\n  BaseTypes.DECIMAL.types.sqlite = ['DECIMAL'];\n  BaseTypes.UUID.types.sqlite = ['UUID'];\n  BaseTypes.ENUM.types.sqlite = false;\n  BaseTypes.REAL.types.sqlite = ['REAL'];\n  BaseTypes.DOUBLE.types.sqlite = ['DOUBLE PRECISION'];\n  BaseTypes.GEOMETRY.types.sqlite = false;\n  BaseTypes.JSON.types.sqlite = ['JSON', 'JSONB'];\n\n  class JSONTYPE extends BaseTypes.JSON {\n    static parse(data) {\n      return JSON.parse(data);\n    }\n  }\n\n  class DATE extends BaseTypes.DATE {\n    static parse(date, options) {\n      if (!date.includes('+')) {\n        // For backwards compat. Dates inserted by sequelize < 2.0dev12 will not have a timestamp set\n        return new Date(date + options.timezone);\n      }\n      return new Date(date); // We already have a timezone stored in the string\n    }\n  }\n\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(date) {\n      return date;\n    }\n  }\n\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (this._binary) {\n        return `VARCHAR BINARY(${this._length})`;\n      }\n      return super.toSql(this);\n    }\n  }\n\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      if (this._length) {\n        warn('SQLite does not support TEXT with options. Plain `TEXT` will be used instead.');\n        this._length = undefined;\n      }\n      return 'TEXT';\n    }\n  }\n\n  class CITEXT extends BaseTypes.CITEXT {\n    toSql() {\n      return 'TEXT COLLATE NOCASE';\n    }\n  }\n\n  class CHAR extends BaseTypes.CHAR {\n    toSql() {\n      if (this._binary) {\n        return `CHAR BINARY(${this._length})`;\n      }\n      return super.toSql();\n    }\n  }\n\n  class NUMBER extends BaseTypes.NUMBER {\n    toSql() {\n      let result = this.key;\n      if (this._unsigned) {\n        result += ' UNSIGNED';\n      }\n      if (this._zerofill) {\n        result += ' ZEROFILL';\n      }\n      if (this._length) {\n        result += `(${this._length}`;\n        if (typeof this._decimals === 'number') {\n          result += `,${this._decimals}`;\n        }\n        result += ')';\n      }\n      return result;\n    }\n  }\n\n  class TINYINT extends BaseTypes.TINYINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n\n  class SMALLINT extends BaseTypes.SMALLINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n\n  class MEDIUMINT extends BaseTypes.MEDIUMINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n\n  class INTEGER extends BaseTypes.INTEGER {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n\n  class FLOAT extends BaseTypes.FLOAT {\n  }\n\n  class DOUBLE extends BaseTypes.DOUBLE {\n  }\n\n  class REAL extends BaseTypes.REAL { }\n\n  function parseFloating(value) {\n    if (typeof value !== 'string') {\n      return value;\n    }\n    if (value === 'NaN') {\n      return NaN;\n    }\n    if (value === 'Infinity') {\n      return Infinity;\n    }\n    if (value === '-Infinity') {\n      return -Infinity;\n    }\n  }\n  for (const floating of [FLOAT, DOUBLE, REAL]) {\n    floating.parse = parseFloating;\n  }\n\n\n  for (const num of [FLOAT, DOUBLE, REAL, TINYINT, SMALLINT, MEDIUMINT, INTEGER, BIGINT]) {\n    num.prototype.toSql = NUMBER.prototype.toSql;\n  }\n\n  class ENUM extends BaseTypes.ENUM {\n    toSql() {\n      return 'TEXT';\n    }\n  }\n\n  return {\n    DATE,\n    DATEONLY,\n    STRING,\n    CHAR,\n    NUMBER,\n    FLOAT,\n    REAL,\n    'DOUBLE PRECISION': DOUBLE,\n    TINYINT,\n    SMALLINT,\n    MEDIUMINT,\n    INTEGER,\n    BIGINT,\n    TEXT,\n    ENUM,\n    JSON: JSONTYPE,\n    CITEXT\n  };\n};\n"]},"metadata":{},"sourceType":"script"}