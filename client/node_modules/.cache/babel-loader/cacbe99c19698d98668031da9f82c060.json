{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\n\nconst AbstractConnectionManager = require(\"../abstract/connection-manager\");\n\nconst {\n  logger\n} = require(\"../../utils/logger\");\n\nconst debug = logger.debugContext(\"connection:pg\");\n\nconst sequelizeErrors = require(\"../../errors\");\n\nconst semver = require(\"semver\");\n\nconst dataTypes = require(\"../../data-types\");\n\nconst momentTz = require(\"moment-timezone\");\n\nconst {\n  promisify\n} = require(\"util\");\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 5432;\n    super(dialect, sequelize);\n\n    const pgLib = this._loadDialectModule(\"pg\");\n\n    this.lib = this.sequelize.config.native ? pgLib.native : pgLib;\n\n    this._clearDynamicOIDs();\n\n    this._clearTypeParser();\n\n    this.refreshTypeParser(dataTypes.postgres);\n  }\n\n  _refreshTypeParser(dataType) {\n    const arrayParserBuilder = parser2 => {\n      return value => this.lib.types.arrayParser.create(value, parser2).parse();\n    };\n\n    const rangeParserBuilder = parser2 => {\n      return value => dataType.parse(value, {\n        parser: parser2\n      });\n    };\n\n    if (dataType.key.toLowerCase() === \"range\") {\n      for (const name in this.nameOidMap) {\n        const entry = this.nameOidMap[name];\n        if (!entry.rangeOid) continue;\n        const rangeParser = rangeParserBuilder(this.getTypeParser(entry.oid));\n        const arrayRangeParser = arrayParserBuilder(rangeParser);\n        this.oidParserMap.set(entry.rangeOid, rangeParser);\n        if (!entry.arrayRangeOid) continue;\n        this.oidParserMap.set(entry.arrayRangeOid, arrayRangeParser);\n      }\n\n      return;\n    }\n\n    const parser = value => dataType.parse(value);\n\n    const arrayParser = arrayParserBuilder(parser);\n\n    if (dataType.key.toLowerCase() === \"enum\") {\n      this.enumOids.oids.forEach(oid => {\n        this.oidParserMap.set(oid, parser);\n      });\n      this.enumOids.arrayOids.forEach(arrayOid => {\n        this.oidParserMap.set(arrayOid, arrayParser);\n      });\n      return;\n    }\n\n    dataType.types.postgres.forEach(name => {\n      if (!this.nameOidMap[name]) return;\n      this.oidParserMap.set(this.nameOidMap[name].oid, parser);\n      if (!this.nameOidMap[name].arrayOid) return;\n      this.oidParserMap.set(this.nameOidMap[name].arrayOid, arrayParser);\n    });\n  }\n\n  _clearTypeParser() {\n    this.oidParserMap = /* @__PURE__ */new Map();\n  }\n\n  getTypeParser(oid) {\n    if (this.oidParserMap.get(oid)) return this.oidParserMap.get(oid);\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return this.lib.types.getTypeParser(oid, ...args);\n  }\n\n  async connect(config) {\n    config.user = config.username;\n\n    const connectionConfig = _.pick(config, [\"user\", \"password\", \"host\", \"database\", \"port\"]);\n\n    connectionConfig.types = {\n      getTypeParser: ConnectionManager.prototype.getTypeParser.bind(this)\n    };\n\n    if (config.dialectOptions) {\n      _.merge(connectionConfig, _.pick(config.dialectOptions, [\"application_name\", \"ssl\", \"client_encoding\", \"binary\", \"keepAlive\", \"statement_timeout\", \"query_timeout\", \"idle_in_transaction_session_timeout\", \"lock_timeout\", \"options\"]));\n    }\n\n    const connection = await new Promise((resolve, reject) => {\n      let responded = false;\n      const connection2 = new this.lib.Client(connectionConfig);\n\n      const parameterHandler = message => {\n        switch (message.parameterName) {\n          case \"server_version\":\n            if (this.sequelize.options.databaseVersion === 0) {\n              const version = semver.coerce(message.parameterValue).version;\n              this.sequelize.options.databaseVersion = semver.valid(version) ? version : this.dialect.defaultVersion;\n            }\n\n            break;\n\n          case \"standard_conforming_strings\":\n            connection2[\"standard_conforming_strings\"] = message.parameterValue;\n            break;\n        }\n      };\n\n      const endHandler = () => {\n        debug(\"connection timeout\");\n\n        if (!responded) {\n          reject(new sequelizeErrors.ConnectionTimedOutError(new Error(\"Connection timed out\")));\n        }\n      };\n\n      connection2.once(\"end\", endHandler);\n\n      if (!this.sequelize.config.native) {\n        connection2.connection.on(\"parameterStatus\", parameterHandler);\n      }\n\n      connection2.connect(err => {\n        responded = true;\n\n        if (!this.sequelize.config.native) {\n          connection2.connection.removeListener(\"parameterStatus\", parameterHandler);\n        }\n\n        if (err) {\n          if (err.code) {\n            switch (err.code) {\n              case \"ECONNREFUSED\":\n                reject(new sequelizeErrors.ConnectionRefusedError(err));\n                break;\n\n              case \"ENOTFOUND\":\n                reject(new sequelizeErrors.HostNotFoundError(err));\n                break;\n\n              case \"EHOSTUNREACH\":\n                reject(new sequelizeErrors.HostNotReachableError(err));\n                break;\n\n              case \"EINVAL\":\n                reject(new sequelizeErrors.InvalidConnectionError(err));\n                break;\n\n              default:\n                reject(new sequelizeErrors.ConnectionError(err));\n                break;\n            }\n          } else {\n            reject(new sequelizeErrors.ConnectionError(err));\n          }\n        } else {\n          debug(\"connection acquired\");\n          connection2.removeListener(\"end\", endHandler);\n          resolve(connection2);\n        }\n      });\n    });\n    connection.once(\"error\", error => {\n      connection._invalid = true;\n      debug(`connection error ${error.code || error.message}`);\n      this.pool.destroy(connection);\n    });\n    let query = \"\";\n\n    if (this.sequelize.options.standardConformingStrings !== false && connection[\"standard_conforming_strings\"] !== \"on\") {\n      query += \"SET standard_conforming_strings=on;\";\n    }\n\n    if (this.sequelize.options.clientMinMessages !== void 0) {\n      console.warn('Usage of \"options.clientMinMessages\" is deprecated and will be removed in v7.');\n      console.warn('Please use the sequelize option \"dialectOptions.clientMinMessages\" instead.');\n    }\n\n    if (!(config.dialectOptions && config.dialectOptions.clientMinMessages && config.dialectOptions.clientMinMessages.toLowerCase() === \"ignore\" || this.sequelize.options.clientMinMessages === false)) {\n      const clientMinMessages = config.dialectOptions && config.dialectOptions.clientMinMessages || this.sequelize.options.clientMinMessages || \"warning\";\n      query += `SET client_min_messages TO ${clientMinMessages};`;\n    }\n\n    if (!this.sequelize.config.keepDefaultTimezone) {\n      const isZone = !!momentTz.tz.zone(this.sequelize.options.timezone);\n\n      if (isZone) {\n        query += `SET TIME ZONE '${this.sequelize.options.timezone}';`;\n      } else {\n        query += `SET TIME ZONE INTERVAL '${this.sequelize.options.timezone}' HOUR TO MINUTE;`;\n      }\n    }\n\n    if (query) {\n      await connection.query(query);\n    }\n\n    if (Object.keys(this.nameOidMap).length === 0 && this.enumOids.oids.length === 0 && this.enumOids.arrayOids.length === 0) {\n      await this._refreshDynamicOIDs(connection);\n    }\n\n    return connection;\n  }\n\n  async disconnect(connection) {\n    if (connection._ending) {\n      debug(\"connection tried to disconnect but was already at ENDING state\");\n      return;\n    }\n\n    return await promisify(callback => connection.end(callback))();\n  }\n\n  validate(connection) {\n    return !connection._invalid && !connection._ending;\n  }\n\n  async _refreshDynamicOIDs(connection) {\n    const databaseVersion = this.sequelize.options.databaseVersion;\n    const supportedVersion = \"8.3.0\";\n\n    if ((databaseVersion && semver.gte(databaseVersion, supportedVersion)) === false) {\n      return;\n    }\n\n    const results = await (connection || this.sequelize).query(\"WITH ranges AS (  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,         pg_type.typarray AS rngtyparray, pg_range.rngsubtype    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid)SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype WHERE (pg_type.typtype IN('b', 'e'));\");\n    let result = Array.isArray(results) ? results.pop() : results;\n\n    if (Array.isArray(result)) {\n      if (result[0].command === \"SET\") {\n        result = result.pop();\n      }\n    }\n\n    const newNameOidMap = {};\n    const newEnumOids = {\n      oids: [],\n      arrayOids: []\n    };\n\n    for (const row of result.rows) {\n      if (row.typtype === \"e\") {\n        newEnumOids.oids.push(row.oid);\n        if (row.typarray) newEnumOids.arrayOids.push(row.typarray);\n        continue;\n      }\n\n      newNameOidMap[row.typname] = {\n        oid: row.oid\n      };\n      if (row.typarray) newNameOidMap[row.typname].arrayOid = row.typarray;\n\n      if (row.rngtypid) {\n        newNameOidMap[row.typname].rangeOid = row.rngtypid;\n        if (row.rngtyparray) newNameOidMap[row.typname].arrayRangeOid = row.rngtyparray;\n      }\n    }\n\n    this.nameOidMap = newNameOidMap;\n    this.enumOids = newEnumOids;\n    this.refreshTypeParser(dataTypes.postgres);\n  }\n\n  _clearDynamicOIDs() {\n    this.nameOidMap = {};\n    this.enumOids = {\n      oids: [],\n      arrayOids: []\n    };\n  }\n\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"mappings":"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","names":["_","require","AbstractConnectionManager","logger","debug","debugContext","sequelizeErrors","semver","dataTypes","momentTz","promisify","constructor","dialect","sequelize","config","port","pgLib","_loadDialectModule","lib","native","_clearDynamicOIDs","_clearTypeParser","refreshTypeParser","postgres","_refreshTypeParser","dataType","arrayParserBuilder","parser2","value","types","arrayParser","create","parse","rangeParserBuilder","parser","key","toLowerCase","name","nameOidMap","entry","rangeOid","rangeParser","getTypeParser","oid","arrayRangeParser","oidParserMap","set","arrayRangeOid","enumOids","oids","forEach","arrayOids","arrayOid","Map","get","args","user","username","connectionConfig","pick","ConnectionManager","prototype","bind","dialectOptions","merge","connection","Promise","resolve","reject","responded","connection2","Client","parameterHandler","message","parameterName","options","databaseVersion","version","coerce","parameterValue","valid","defaultVersion","endHandler","ConnectionTimedOutError","Error","once","on","connect","err","removeListener","code","ConnectionRefusedError","HostNotFoundError","HostNotReachableError","InvalidConnectionError","ConnectionError","error","_invalid","pool","destroy","query","standardConformingStrings","clientMinMessages","console","warn","keepDefaultTimezone","isZone","tz","zone","timezone","Object","keys","length","_refreshDynamicOIDs","_ending","callback","end","validate","supportedVersion","gte","results","result","Array","isArray","pop","command","newNameOidMap","newEnumOids","row","rows","typtype","push","typarray","typname","rngtypid","rngtyparray","module","exports","default"],"sources":["/Users/aurele/node_modules/sequelize/src/dialects/postgres/connection-manager.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst { logger } = require('../../utils/logger');\nconst debug = logger.debugContext('connection:pg');\nconst sequelizeErrors = require('../../errors');\nconst semver = require('semver');\nconst dataTypes = require('../../data-types');\nconst momentTz = require('moment-timezone');\nconst { promisify } = require('util');\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 5432;\n    super(dialect, sequelize);\n\n    const pgLib = this._loadDialectModule('pg');\n    this.lib = this.sequelize.config.native ? pgLib.native : pgLib;\n\n    this._clearDynamicOIDs();\n    this._clearTypeParser();\n    this.refreshTypeParser(dataTypes.postgres);\n  }\n\n  // Expose this as a method so that the parsing may be updated when the user has added additional, custom types\n  _refreshTypeParser(dataType) {\n    const arrayParserBuilder = parser => {\n      return value => this.lib.types.arrayParser.create(value, parser).parse();\n    };\n    const rangeParserBuilder = parser => {\n      return value => dataType.parse(value, { parser });\n    };\n\n    // Set range parsers\n    if (dataType.key.toLowerCase() === 'range') {\n      for (const name in this.nameOidMap) {\n        const entry = this.nameOidMap[name];\n        if (! entry.rangeOid) continue;\n\n        const rangeParser = rangeParserBuilder(this.getTypeParser(entry.oid));\n        const arrayRangeParser = arrayParserBuilder(rangeParser);\n\n        this.oidParserMap.set(entry.rangeOid, rangeParser);\n        if (! entry.arrayRangeOid) continue;\n        this.oidParserMap.set(entry.arrayRangeOid, arrayRangeParser);\n      }\n      return;\n    }\n\n    // Create parsers for normal or enum data types\n    const parser = value => dataType.parse(value);\n    const arrayParser = arrayParserBuilder(parser);\n\n    // Set enum parsers\n    if (dataType.key.toLowerCase() === 'enum') {\n      this.enumOids.oids.forEach(oid => {\n        this.oidParserMap.set(oid, parser);\n      });\n      this.enumOids.arrayOids.forEach(arrayOid => {\n        this.oidParserMap.set(arrayOid, arrayParser);\n      });\n      return;\n    }\n\n    // Set parsers for normal data types\n    dataType.types.postgres.forEach(name => {\n      if (! this.nameOidMap[name]) return;\n      this.oidParserMap.set(this.nameOidMap[name].oid, parser);\n\n      if (! this.nameOidMap[name].arrayOid) return;\n      this.oidParserMap.set(this.nameOidMap[name].arrayOid, arrayParser);\n    });\n  }\n\n  _clearTypeParser() {\n    this.oidParserMap = new Map();\n  }\n\n  getTypeParser(oid, ...args) {\n    if (this.oidParserMap.get(oid)) return this.oidParserMap.get(oid);\n\n    return this.lib.types.getTypeParser(oid, ...args);\n  }\n\n  async connect(config) {\n    config.user = config.username;\n    const connectionConfig = _.pick(config, [\n      'user', 'password', 'host', 'database', 'port'\n    ]);\n\n    connectionConfig.types = {\n      getTypeParser: ConnectionManager.prototype.getTypeParser.bind(this)\n    };\n\n    if (config.dialectOptions) {\n      _.merge(connectionConfig,\n        _.pick(config.dialectOptions, [\n        // see [http://www.postgresql.org/docs/9.3/static/runtime-config-logging.html#GUC-APPLICATION-NAME]\n          'application_name',\n          // choose the SSL mode with the PGSSLMODE environment variable\n          // object format: [https://github.com/brianc/node-postgres/blob/ee19e74ffa6309c9c5e8e01746261a8f651661f8/lib/connection.js#L79]\n          // see also [http://www.postgresql.org/docs/9.3/static/libpq-ssl.html]\n          'ssl',\n          // In addition to the values accepted by the corresponding server,\n          // you can use \"auto\" to determine the right encoding from the\n          // current locale in the client (LC_CTYPE environment variable on Unix systems)\n          'client_encoding',\n          // !! DO NOT SET THIS TO TRUE !!\n          // (unless you know what you're doing)\n          // see [http://www.postgresql.org/message-id/flat/bc9549a50706040852u27633f41ib1e6b09f8339d845@mail.gmail.com#bc9549a50706040852u27633f41ib1e6b09f8339d845@mail.gmail.com]\n          'binary',\n          // This should help with backends incorrectly considering idle clients to be dead and prematurely disconnecting them.\n          // this feature has been added in pg module v6.0.0, check pg/CHANGELOG.md\n          'keepAlive',\n          // Times out queries after a set time in milliseconds in the database end. Added in pg v7.3\n          'statement_timeout',\n          // Times out queries after a set time in milliseconds in client end, query would be still running in database end.\n          'query_timeout',\n          // Terminate any session with an open transaction that has been idle for longer than the specified duration in milliseconds. Added in pg v7.17.0 only supported in postgres >= 10\n          'idle_in_transaction_session_timeout',\n          // Maximum wait time for lock requests in milliseconds. Added in pg v8.8.0.\n          'lock_timeout',\n          // Postgres allows additional session variables to be configured in the connection string in the `options` param.\n          // see [https://www.postgresql.org/docs/14/libpq-connect.html#LIBPQ-CONNECT-OPTIONS]\n          'options'\n        ]));\n    }\n\n    const connection = await new Promise((resolve, reject) => {\n      let responded = false;\n\n      const connection = new this.lib.Client(connectionConfig);\n\n      const parameterHandler = message => {\n        switch (message.parameterName) {\n          case 'server_version':\n            if (this.sequelize.options.databaseVersion === 0) {\n              const version = semver.coerce(message.parameterValue).version;\n              this.sequelize.options.databaseVersion = semver.valid(version)\n                ? version\n                : this.dialect.defaultVersion;\n            }\n            break;\n          case 'standard_conforming_strings':\n            connection['standard_conforming_strings'] = message.parameterValue;\n            break;\n        }\n      };\n\n      const endHandler = () => {\n        debug('connection timeout');\n        if (!responded) {\n          reject(new sequelizeErrors.ConnectionTimedOutError(new Error('Connection timed out')));\n        }\n      };\n\n      // If we didn't ever hear from the client.connect() callback the connection timeout\n      // node-postgres does not treat this as an error since no active query was ever emitted\n      connection.once('end', endHandler);\n\n      if (!this.sequelize.config.native) {\n        // Receive various server parameters for further configuration\n        connection.connection.on('parameterStatus', parameterHandler);\n      }\n\n      connection.connect(err => {\n        responded = true;\n\n        if (!this.sequelize.config.native) {\n          // remove parameter handler\n          connection.connection.removeListener('parameterStatus', parameterHandler);\n        }\n\n        if (err) {\n          if (err.code) {\n            switch (err.code) {\n              case 'ECONNREFUSED':\n                reject(new sequelizeErrors.ConnectionRefusedError(err));\n                break;\n              case 'ENOTFOUND':\n                reject(new sequelizeErrors.HostNotFoundError(err));\n                break;\n              case 'EHOSTUNREACH':\n                reject(new sequelizeErrors.HostNotReachableError(err));\n                break;\n              case 'EINVAL':\n                reject(new sequelizeErrors.InvalidConnectionError(err));\n                break;\n              default:\n                reject(new sequelizeErrors.ConnectionError(err));\n                break;\n            }\n          } else {\n            reject(new sequelizeErrors.ConnectionError(err));\n          }\n        } else {\n          debug('connection acquired');\n          connection.removeListener('end', endHandler);\n          resolve(connection);\n        }\n      });\n    });\n\n    // Don't let a Postgres restart (or error) to take down the whole app\n    connection.once('error', error => {\n      connection._invalid = true;\n      debug(`connection error ${error.code || error.message}`);\n      this.pool.destroy(connection);\n    });\n\n    let query = '';\n\n    if (this.sequelize.options.standardConformingStrings !== false && connection['standard_conforming_strings'] !== 'on') {\n      // Disable escape characters in strings\n      // see https://github.com/sequelize/sequelize/issues/3545 (security issue)\n      // see https://www.postgresql.org/docs/current/static/runtime-config-compatible.html#GUC-STANDARD-CONFORMING-STRINGS\n      query += 'SET standard_conforming_strings=on;';\n    }\n\n    if (this.sequelize.options.clientMinMessages !== undefined) {\n      console.warn('Usage of \"options.clientMinMessages\" is deprecated and will be removed in v7.');\n      console.warn('Please use the sequelize option \"dialectOptions.clientMinMessages\" instead.');\n    }\n\n    // Redshift dosen't support client_min_messages, use 'ignore' to skip this settings.\n    // If no option, the default value in sequelize is 'warning'\n    if ( !( config.dialectOptions && config.dialectOptions.clientMinMessages && config.dialectOptions.clientMinMessages.toLowerCase() === 'ignore' ||\n            this.sequelize.options.clientMinMessages === false ) ) {\n      const clientMinMessages = config.dialectOptions && config.dialectOptions.clientMinMessages || this.sequelize.options.clientMinMessages || 'warning';\n      query += `SET client_min_messages TO ${clientMinMessages};`;\n\n    }\n\n    if (!this.sequelize.config.keepDefaultTimezone) {\n      const isZone = !!momentTz.tz.zone(this.sequelize.options.timezone);\n      if (isZone) {\n        query += `SET TIME ZONE '${this.sequelize.options.timezone}';`;\n      } else {\n        query += `SET TIME ZONE INTERVAL '${this.sequelize.options.timezone}' HOUR TO MINUTE;`;\n      }\n    }\n\n    if (query) {\n      await connection.query(query);\n    }\n    if (Object.keys(this.nameOidMap).length === 0 &&\n      this.enumOids.oids.length === 0 &&\n      this.enumOids.arrayOids.length === 0) {\n      await this._refreshDynamicOIDs(connection);\n    }\n\n    return connection;\n  }\n\n  async disconnect(connection) {\n    if (connection._ending) {\n      debug('connection tried to disconnect but was already at ENDING state');\n      return;\n    }\n\n    return await promisify(callback => connection.end(callback))();\n  }\n\n  validate(connection) {\n    return !connection._invalid && !connection._ending;\n  }\n\n  async _refreshDynamicOIDs(connection) {\n    const databaseVersion = this.sequelize.options.databaseVersion;\n    const supportedVersion = '8.3.0';\n\n    // Check for supported version\n    if ( (databaseVersion && semver.gte(databaseVersion, supportedVersion)) === false) {\n      return;\n    }\n\n    const results = await (connection || this.sequelize).query(\n      'WITH ranges AS (' +\n      '  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,' +\n      '         pg_type.typarray AS rngtyparray, pg_range.rngsubtype' +\n      '    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid' +\n      ')' +\n      'SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,' +\n      '       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray' +\n      '  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype' +\n      ' WHERE (pg_type.typtype IN(\\'b\\', \\'e\\'));'\n    );\n\n    let result = Array.isArray(results) ? results.pop() : results;\n\n    // When searchPath is prepended then two statements are executed and the result is\n    // an array of those two statements. First one is the SET search_path and second is\n    // the SELECT query result.\n    if (Array.isArray(result)) {\n      if (result[0].command === 'SET') {\n        result = result.pop();\n      }\n    }\n\n    const newNameOidMap = {};\n    const newEnumOids = { oids: [], arrayOids: [] };\n\n    for (const row of result.rows) {\n      // Mapping enums, handled separatedly\n      if (row.typtype === 'e') {\n        newEnumOids.oids.push(row.oid);\n        if (row.typarray) newEnumOids.arrayOids.push(row.typarray);\n        continue;\n      }\n\n      // Mapping base types and their arrays\n      newNameOidMap[row.typname] = { oid: row.oid };\n      if (row.typarray) newNameOidMap[row.typname].arrayOid = row.typarray;\n\n      // Mapping ranges(of base types) and their arrays\n      if (row.rngtypid) {\n        newNameOidMap[row.typname].rangeOid = row.rngtypid;\n        if (row.rngtyparray) newNameOidMap[row.typname].arrayRangeOid = row.rngtyparray;\n      }\n    }\n\n    // Replace all OID mappings. Avoids temporary empty OID mappings.\n    this.nameOidMap = newNameOidMap;\n    this.enumOids = newEnumOids;\n\n    this.refreshTypeParser(dataTypes.postgres);\n  }\n\n  _clearDynamicOIDs() {\n    this.nameOidMap = {};\n    this.enumOids = { oids: [], arrayOids: [] };\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"]},"metadata":{},"sourceType":"script"}