{"ast":null,"code":"var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\n\nvar __markAsModule = target => __defProp(target, \"__esModule\", {\n  value: true\n});\n\nvar __export = (target, all) => {\n  __markAsModule(target);\n\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2)) if (!__hasOwnProp.call(target, key) && key !== \"default\") __defProp(target, key, {\n      get: () => module2[key],\n      enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable\n    });\n  }\n\n  return target;\n};\n\nvar __toModule = module2 => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? {\n    get: () => module2.default,\n    enumerable: true\n  } : {\n    value: module2,\n    enumerable: true\n  })), module2);\n};\n\n__export(exports, {\n  injectReplacements: () => injectReplacements\n});\n\nvar import_isPlainObject = __toModule(require(\"lodash/isPlainObject\"));\n\nvar import_sql_string = __toModule(require(\"../sql-string\"));\n\nfunction injectReplacements(sqlString, dialect, replacements) {\n  var _a, _b, _c, _d;\n\n  if (replacements == null) {\n    return sqlString;\n  }\n\n  if (!Array.isArray(replacements) && !(0, import_isPlainObject.default)(replacements)) {\n    throw new TypeError(`\"replacements\" must be an array or a plain object, but received ${JSON.stringify(replacements)} instead.`);\n  }\n\n  const isNamedReplacements = (0, import_isPlainObject.default)(replacements);\n  const isPositionalReplacements = Array.isArray(replacements);\n  let lastConsumedPositionalReplacementIndex = -1;\n  let output = \"\";\n  let currentDollarStringTagName = null;\n  let isString = false;\n  let isColumn = false;\n  let previousSliceEnd = 0;\n  let isSingleLineComment = false;\n  let isCommentBlock = false;\n  let stringIsBackslashEscapable = false;\n\n  for (let i = 0; i < sqlString.length; i++) {\n    const char = sqlString[i];\n\n    if (isColumn) {\n      if (char === dialect.TICK_CHAR_RIGHT) {\n        isColumn = false;\n      }\n\n      continue;\n    }\n\n    if (isString) {\n      if (char === \"'\" && (!stringIsBackslashEscapable || !isBackslashEscaped(sqlString, i - 1))) {\n        isString = false;\n        stringIsBackslashEscapable = false;\n      }\n\n      continue;\n    }\n\n    if (currentDollarStringTagName !== null) {\n      if (char !== \"$\") {\n        continue;\n      }\n\n      const remainingString = sqlString.slice(i, sqlString.length);\n      const dollarStringStartMatch = remainingString.match(/^\\$(?<name>[a-z_][0-9a-z_])?(\\$)/i);\n      const tagName = ((_a = dollarStringStartMatch == null ? void 0 : dollarStringStartMatch.groups) == null ? void 0 : _a.name) || \"\";\n\n      if (currentDollarStringTagName === tagName) {\n        currentDollarStringTagName = null;\n      }\n\n      continue;\n    }\n\n    if (isSingleLineComment) {\n      if (char === \"\\n\") {\n        isSingleLineComment = false;\n      }\n\n      continue;\n    }\n\n    if (isCommentBlock) {\n      if (char === \"*\" && sqlString[i + 1] === \"/\") {\n        isCommentBlock = false;\n      }\n\n      continue;\n    }\n\n    if (char === dialect.TICK_CHAR_LEFT) {\n      isColumn = true;\n      continue;\n    }\n\n    if (char === \"'\") {\n      isString = true;\n      stringIsBackslashEscapable = dialect.canBackslashEscape() || dialect.supports.escapeStringConstants && (sqlString[i - 1] === \"E\" || sqlString[i - 1] === \"e\") && canPrecedeNewToken(sqlString[i - 2]);\n      continue;\n    }\n\n    if (char === \"-\" && sqlString.slice(i, i + 3) === \"-- \") {\n      isSingleLineComment = true;\n      continue;\n    }\n\n    if (char === \"/\" && sqlString.slice(i, i + 2) === \"/*\") {\n      isCommentBlock = true;\n      continue;\n    }\n\n    if (char === \"$\") {\n      const previousChar = sqlString[i - 1];\n\n      if (/[0-9a-z_]/i.test(previousChar)) {\n        continue;\n      }\n\n      const remainingString = sqlString.slice(i, sqlString.length);\n      const dollarStringStartMatch = remainingString.match(/^\\$(?<name>[a-z_][0-9a-z_]*)?\\$/i);\n\n      if (dollarStringStartMatch) {\n        currentDollarStringTagName = (_c = (_b = dollarStringStartMatch.groups) == null ? void 0 : _b.name) != null ? _c : \"\";\n        continue;\n      }\n\n      continue;\n    }\n\n    if (isNamedReplacements && char === \":\") {\n      const previousChar = sqlString[i - 1];\n\n      if (!canPrecedeNewToken(previousChar) && previousChar !== \"[\") {\n        continue;\n      }\n\n      const remainingString = sqlString.slice(i, sqlString.length);\n      const match = remainingString.match(/^:(?<name>[a-z_][0-9a-z_]*)(?:\\)|,|$|\\s|::|;|])/i);\n      const replacementName = (_d = match == null ? void 0 : match.groups) == null ? void 0 : _d.name;\n\n      if (!replacementName) {\n        continue;\n      }\n\n      const replacementValue = replacements[replacementName];\n\n      if (!Object.prototype.hasOwnProperty.call(replacements, replacementName) || replacementValue === void 0) {\n        throw new Error(`Named replacement \":${replacementName}\" has no entry in the replacement map.`);\n      }\n\n      const escapedReplacement = (0, import_sql_string.escape)(replacementValue, void 0, dialect.name, true);\n      output += sqlString.slice(previousSliceEnd, i);\n      previousSliceEnd = i + replacementName.length + 1;\n      output += escapedReplacement;\n      continue;\n    }\n\n    if (isPositionalReplacements && char === \"?\") {\n      const previousChar = sqlString[i - 1];\n\n      if (!canPrecedeNewToken(previousChar) && previousChar !== \"[\") {\n        continue;\n      }\n\n      const nextChar = sqlString[i + 1];\n\n      if (nextChar === \"|\" || nextChar === \"&\") {\n        continue;\n      }\n\n      const replacementIndex = ++lastConsumedPositionalReplacementIndex;\n      const replacementValue = replacements[lastConsumedPositionalReplacementIndex];\n\n      if (replacementValue === void 0) {\n        throw new Error(`Positional replacement (?) ${replacementIndex} has no entry in the replacement map (replacements[${replacementIndex}] is undefined).`);\n      }\n\n      const escapedReplacement = (0, import_sql_string.escape)(replacementValue, void 0, dialect.name, true);\n      output += sqlString.slice(previousSliceEnd, i);\n      previousSliceEnd = i + 1;\n      output += escapedReplacement;\n    }\n  }\n\n  if (isString) {\n    throw new Error(`The following SQL query includes an unterminated string literal:\n${sqlString}`);\n  }\n\n  output += sqlString.slice(previousSliceEnd, sqlString.length);\n  return output;\n}\n\nfunction canPrecedeNewToken(char) {\n  return char === void 0 || /[\\s(>,=]/.test(char);\n}\n\nfunction isBackslashEscaped(string, pos) {\n  let escaped = false;\n\n  for (let i = pos; i >= 0; i--) {\n    const char = string[i];\n\n    if (char !== \"\\\\\") {\n      break;\n    }\n\n    escaped = !escaped;\n  }\n\n  return escaped;\n}","map":{"version":3,"mappings":"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","names":["__export","injectReplacements","__toModule","sqlString","dialect","replacements","Array","isArray","TypeError","JSON","stringify","isNamedReplacements","isPositionalReplacements","lastConsumedPositionalReplacementIndex","output","currentDollarStringTagName","isString","isColumn","previousSliceEnd","isSingleLineComment","isCommentBlock","stringIsBackslashEscapable","i","length","char","TICK_CHAR_RIGHT","isBackslashEscaped","remainingString","slice","dollarStringStartMatch","match","tagName","groups","name","TICK_CHAR_LEFT","canBackslashEscape","supports","escapeStringConstants","canPrecedeNewToken","previousChar","test","replacementName","replacementValue","Object","prototype","hasOwnProperty","call","Error","escapedReplacement","nextChar","replacementIndex","string","pos","escaped"],"sources":["/Users/aurele/node_modules/sequelize/src/utils/sql.ts"],"sourcesContent":["import isPlainObject from 'lodash/isPlainObject';\nimport type { AbstractDialect } from '../dialects/abstract/index.js';\nimport { escape as escapeSqlValue } from '../sql-string';\n\ntype BindOrReplacements = { [key: string]: unknown } | unknown[];\n\n/**\n * Inlines replacements in places where they would be valid SQL values.\n *\n * @param sqlString The SQL that contains the replacements\n * @param dialect The dialect of the SQL\n * @param replacements if provided, this method will replace ':named' replacements & positional replacements (?)\n *\n * @returns The SQL with replacements rewritten in their dialect-specific syntax.\n */\nexport function injectReplacements(\n  sqlString: string,\n  dialect: AbstractDialect,\n  replacements: BindOrReplacements\n): string {\n  if (replacements == null) {\n    return sqlString;\n  }\n\n  if (!Array.isArray(replacements) && !isPlainObject(replacements)) {\n    throw new TypeError(`\"replacements\" must be an array or a plain object, but received ${JSON.stringify(replacements)} instead.`);\n  }\n\n  const isNamedReplacements = isPlainObject(replacements);\n  const isPositionalReplacements = Array.isArray(replacements);\n  let lastConsumedPositionalReplacementIndex = -1;\n\n  let output = '';\n\n  let currentDollarStringTagName = null;\n  let isString = false;\n  let isColumn = false;\n  let previousSliceEnd = 0;\n  let isSingleLineComment = false;\n  let isCommentBlock = false;\n  let stringIsBackslashEscapable = false;\n\n  for (let i = 0; i < sqlString.length; i++) {\n    const char = sqlString[i];\n\n    if (isColumn) {\n      if (char === dialect.TICK_CHAR_RIGHT) {\n        isColumn = false;\n      }\n\n      continue;\n    }\n\n    if (isString) {\n      if (\n        char === '\\'' &&\n        (!stringIsBackslashEscapable || !isBackslashEscaped(sqlString, i - 1))\n      ) {\n        isString = false;\n        stringIsBackslashEscapable = false;\n      }\n\n      continue;\n    }\n\n    if (currentDollarStringTagName !== null) {\n      if (char !== '$') {\n        continue;\n      }\n\n      const remainingString = sqlString.slice(i, sqlString.length);\n\n      const dollarStringStartMatch = remainingString.match(/^\\$(?<name>[a-z_][0-9a-z_])?(\\$)/i);\n      const tagName = dollarStringStartMatch?.groups?.name || '';\n      if (currentDollarStringTagName === tagName) {\n        currentDollarStringTagName = null;\n      }\n\n      continue;\n    }\n\n    if (isSingleLineComment) {\n      if (char === '\\n') {\n        isSingleLineComment = false;\n      }\n\n      continue;\n    }\n\n    if (isCommentBlock) {\n      if (char === '*' && sqlString[i + 1] === '/') {\n        isCommentBlock = false;\n      }\n\n      continue;\n    }\n\n    if (char === dialect.TICK_CHAR_LEFT) {\n      isColumn = true;\n      continue;\n    }\n\n    if (char === '\\'') {\n      isString = true;\n\n      // The following query is supported in almost all dialects,\n      //  SELECT E'test';\n      // but postgres interprets it as an E-prefixed string, while other dialects interpret it as\n      //  SELECT E 'test';\n      // which selects the type E and aliases it to 'test'.\n\n      stringIsBackslashEscapable =\n        // all ''-style strings in this dialect can be backslash escaped\n        dialect.canBackslashEscape() ||\n        // checking if this is a postgres-style E-prefixed string, which also supports backslash escaping\n        dialect.supports.escapeStringConstants &&\n          // is this a E-prefixed string, such as `E'abc'`, `e'abc'` ?\n          (sqlString[i - 1] === 'E' || sqlString[i - 1] === 'e') &&\n          // reject things such as `AE'abc'` (the prefix must be exactly E)\n          canPrecedeNewToken(sqlString[i - 2]);\n\n      continue;\n    }\n\n    if (char === '-' && sqlString.slice(i, i + 3) === '-- ') {\n      isSingleLineComment = true;\n      continue;\n    }\n\n    if (char === '/' && sqlString.slice(i, i + 2) === '/*') {\n      isCommentBlock = true;\n      continue;\n    }\n\n    // either the start of a $bind parameter, or the start of a $tag$string$tag$\n    if (char === '$') {\n      const previousChar = sqlString[i - 1];\n\n      // we are part of an identifier\n      if (/[0-9a-z_]/i.test(previousChar)) {\n        continue;\n      }\n\n      const remainingString = sqlString.slice(i, sqlString.length);\n\n      const dollarStringStartMatch = remainingString.match(/^\\$(?<name>[a-z_][0-9a-z_]*)?\\$/i);\n      if (dollarStringStartMatch) {\n        currentDollarStringTagName = dollarStringStartMatch.groups?.name ?? '';\n\n        continue;\n      }\n\n      continue;\n    }\n\n    if (isNamedReplacements && char === ':') {\n      const previousChar = sqlString[i - 1];\n      // we want to be conservative with what we consider to be a replacement to avoid risk of conflict with potential operators\n      // users need to add a space before the bind parameter (except after '(', ',', and '=', '[' (for arrays))\n      if (!canPrecedeNewToken(previousChar) && previousChar !== '[') {\n        continue;\n      }\n\n      const remainingString = sqlString.slice(i, sqlString.length);\n\n      const match = remainingString.match(/^:(?<name>[a-z_][0-9a-z_]*)(?:\\)|,|$|\\s|::|;|])/i);\n      const replacementName = match?.groups?.name;\n      if (!replacementName) {\n        continue;\n      }\n\n      // @ts-expect-error -- isPlainObject does not tell typescript that replacements is a plain object, not an array\n      const replacementValue = replacements[replacementName];\n      if (!Object.prototype.hasOwnProperty.call(replacements, replacementName) || replacementValue === undefined) {\n        throw new Error(`Named replacement \":${replacementName}\" has no entry in the replacement map.`);\n      }\n\n      const escapedReplacement = escapeSqlValue(replacementValue, undefined, dialect.name, true);\n\n      // add everything before the bind parameter name\n      output += sqlString.slice(previousSliceEnd, i);\n      // continue after the bind parameter name\n      previousSliceEnd = i + replacementName.length + 1;\n\n      output += escapedReplacement;\n\n      continue;\n    }\n\n    if (isPositionalReplacements && char === '?') {\n      const previousChar = sqlString[i - 1];\n\n      // we want to be conservative with what we consider to be a replacement to avoid risk of conflict with potential operators\n      // users need to add a space before the bind parameter (except after '(', ',', and '=', '[' (for arrays))\n      // -> [ is temporarily added to allow 'ARRAY[:name]' to be replaced\n      // https://github.com/sequelize/sequelize/issues/14410 will make this obsolete.\n      if (!canPrecedeNewToken(previousChar) && previousChar !== '[') {\n        continue;\n      }\n\n      // don't parse ?| and ?& operators as replacements\n      const nextChar = sqlString[i + 1];\n      if (nextChar === '|' || nextChar === '&') {\n        continue;\n      }\n\n      const replacementIndex = ++lastConsumedPositionalReplacementIndex;\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore -- ts < 4.4 loses the information that 'replacements' is an array when using 'isPositionalReplacements' instead of 'Array.isArray'\n      //  but performance matters here.\n      const replacementValue = replacements[lastConsumedPositionalReplacementIndex];\n\n      if (replacementValue === undefined) {\n        throw new Error(`Positional replacement (?) ${replacementIndex} has no entry in the replacement map (replacements[${replacementIndex}] is undefined).`);\n      }\n\n      const escapedReplacement = escapeSqlValue(replacementValue as any, undefined, dialect.name, true);\n\n      // add everything before the bind parameter name\n      output += sqlString.slice(previousSliceEnd, i);\n      // continue after the bind parameter name\n      previousSliceEnd = i + 1;\n\n      output += escapedReplacement;\n    }\n  }\n\n  if (isString) {\n    throw new Error(\n      `The following SQL query includes an unterminated string literal:\\n${sqlString}`\n    );\n  }\n\n  output += sqlString.slice(previousSliceEnd, sqlString.length);\n\n  return output;\n}\n\nfunction canPrecedeNewToken(char: string | undefined): boolean {\n  return char === undefined || /[\\s(>,=]/.test(char);\n}\n\nfunction isBackslashEscaped(string: string, pos: number): boolean {\n  let escaped = false;\n  for (let i = pos; i >= 0; i--) {\n    const char = string[i];\n    if (char !== '\\\\') {\n      break;\n    }\n\n    escaped = !escaped;\n  }\n\n  return escaped;\n}\n"]},"metadata":{},"sourceType":"script"}