{"ast":null,"code":"\"use strict\";\n\nconst AbstractConnectionManager = require(\"../abstract/connection-manager\");\n\nconst sequelizeErrors = require(\"../../errors\");\n\nconst {\n  logger\n} = require(\"../../utils/logger\");\n\nconst DataTypes = require(\"../../data-types\").db2;\n\nconst debug = logger.debugContext(\"connection:db2\");\n\nconst parserStore = require(\"../parserStore\")(\"db2\");\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"ibm_db\");\n    this.refreshTypeParser(DataTypes);\n  }\n\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n\n    return next();\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  async connect(config) {\n    const connectionConfig = {\n      database: config.database,\n      hostname: config.host,\n      port: config.port,\n      uid: config.username,\n      pwd: config.password\n    };\n\n    if (config.ssl) {\n      connectionConfig[\"security\"] = config.ssl;\n    }\n\n    if (config.sslcertificate) {\n      connectionConfig[\"SSLServerCertificate\"] = config.sslcertificate;\n    }\n\n    if (config.dialectOptions) {\n      for (const key of Object.keys(config.dialectOptions)) {\n        connectionConfig[key] = config.dialectOptions[key];\n      }\n    }\n\n    try {\n      const connection = await new Promise((resolve, reject) => {\n        const connection2 = new this.lib.Database();\n        connection2.lib = this.lib;\n        connection2.open(connectionConfig, error => {\n          if (error) {\n            if (error.message && error.message.includes(\"SQL30081N\")) {\n              return reject(new sequelizeErrors.ConnectionRefusedError(error));\n            }\n\n            return reject(new sequelizeErrors.ConnectionError(error));\n          }\n\n          return resolve(connection2);\n        });\n      });\n      return connection;\n    } catch (err) {\n      throw new sequelizeErrors.ConnectionError(err);\n    }\n  }\n\n  disconnect(connection) {\n    if (connection.connected) {\n      connection.close(error => {\n        if (error) {\n          debug(error);\n        } else {\n          debug(\"connection closed\");\n        }\n      });\n    }\n\n    return Promise.resolve();\n  }\n\n  validate(connection) {\n    return connection && connection.connected;\n  }\n\n  _disconnect(connection) {\n    return this.dialect.connectionManager.disconnect(connection);\n  }\n\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"mappings":"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","names":["AbstractConnectionManager","require","sequelizeErrors","logger","DataTypes","db2","debug","debugContext","parserStore","constructor","dialect","sequelize","config","port","lib","_loadDialectModule","refreshTypeParser","field","next","get","type","options","_refreshTypeParser","dataType","refresh","_clearTypeParser","clear","connectionConfig","database","hostname","host","uid","username","pwd","password","ssl","sslcertificate","dialectOptions","key","Object","keys","connection","Promise","resolve","reject","connection2","Database","open","error","message","includes","ConnectionRefusedError","ConnectionError","err","disconnect","connected","close","validate","_disconnect","connectionManager","module","exports","ConnectionManager","default"],"sources":["/Users/aurele/node_modules/sequelize/src/dialects/db2/connection-manager.js"],"sourcesContent":["'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst sequelizeErrors = require('../../errors');\nconst { logger } = require('../../utils/logger');\nconst DataTypes = require('../../data-types').db2;\nconst debug = logger.debugContext('connection:db2');\nconst parserStore = require('../parserStore')('db2');\n\n/**\n * DB2 Connection Manager\n *\n * Get connections, validate and disconnect them.\n * AbstractConnectionManager pooling use it to handle DB2 specific connections\n * Use https://github.com/ibmdb/node-ibm_db to connect with DB2 server\n *\n * @private\n */\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule('ibm_db');\n    this.refreshTypeParser(DataTypes);\n  }\n\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  /**\n   * Connect with DB2 database based on config, Handle any errors in connection\n   * Set the pool handlers on connection.error\n   * Also set proper timezone once connection is connected.\n   *\n   * @param {object} config\n   * @returns {Promise<Connection>}\n   * @private\n   */\n  async connect(config) {\n    const connectionConfig = {\n      database: config.database,\n      hostname: config.host,\n      port: config.port,\n      uid: config.username,\n      pwd: config.password\n    };\n\n    if (config.ssl) {\n      connectionConfig['security'] = config.ssl;\n    }\n    if (config.sslcertificate) {\n      connectionConfig['SSLServerCertificate'] = config.sslcertificate;\n    }\n    if (config.dialectOptions) {\n      for (const key of Object.keys(config.dialectOptions)) {\n        connectionConfig[key] = config.dialectOptions[key];\n      }\n    }\n\n    try {\n      const connection = await new Promise((resolve, reject) => {\n        const connection = new this.lib.Database();\n        connection.lib = this.lib;\n        connection.open(connectionConfig, error => {\n          if (error) {\n            if (error.message && error.message.includes('SQL30081N')) {\n              return reject(new sequelizeErrors.ConnectionRefusedError(error));\n            }\n            return reject(new sequelizeErrors.ConnectionError(error));\n          }\n          return resolve(connection);\n        });\n      });\n      return connection;\n    } catch (err) {\n      throw new sequelizeErrors.ConnectionError(err);\n    }\n  }\n\n  disconnect(connection) {\n    // Don't disconnect a connection that is already disconnected\n    if (connection.connected) {\n      connection.close(error => {\n        if (error) { debug(error); }\n        else { debug('connection closed'); }\n      });\n    }\n    return Promise.resolve();\n  }\n\n  validate(connection) {\n    return connection && connection.connected;\n  }\n\n  /**\n   * Call dialect library to disconnect a connection\n   *\n   * @param {Connection} connection\n   * @private\n   * @returns {Promise}\n   */\n  _disconnect(connection) {\n    return this.dialect.connectionManager.disconnect(connection);\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"]},"metadata":{},"sourceType":"script"}