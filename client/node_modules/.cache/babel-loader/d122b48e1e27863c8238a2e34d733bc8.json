{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nconst AbstractConnectionManager = require(\"../abstract/connection-manager\");\n\nconst SequelizeErrors = require(\"../../errors\");\n\nconst {\n  logger\n} = require(\"../../utils/logger\");\n\nconst DataTypes = require(\"../../data-types\").snowflake;\n\nconst debug = logger.debugContext(\"connection:snowflake\");\n\nconst parserStore = require(\"../parserStore\")(\"snowflake\");\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"snowflake-sdk\");\n    this.refreshTypeParser(DataTypes);\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n\n    return next();\n  }\n\n  async connect(config) {\n    const connectionConfig = __spreadValues({\n      account: config.host,\n      username: config.username,\n      password: config.password,\n      database: config.database,\n      warehouse: config.warehouse,\n      role: config.role\n    }, config.dialectOptions);\n\n    try {\n      const connection = await new Promise((resolve, reject) => {\n        this.lib.createConnection(connectionConfig).connect((err, conn) => {\n          if (err) {\n            console.log(err);\n            reject(err);\n          } else {\n            resolve(conn);\n          }\n        });\n      });\n      debug(\"connection acquired\");\n\n      if (!this.sequelize.config.keepDefaultTimezone) {\n        const tzOffset = this.sequelize.options.timezone === \"+00:00\" ? \"Etc/UTC\" : this.sequelize.options.timezone;\n        const isNamedTzOffset = /\\//.test(tzOffset);\n\n        if (isNamedTzOffset) {\n          await new Promise((resolve, reject) => {\n            connection.execute({\n              sqlText: `ALTER SESSION SET timezone = '${tzOffset}'`,\n\n              complete(err) {\n                if (err) {\n                  console.log(err);\n                  reject(err);\n                } else {\n                  resolve();\n                }\n              }\n\n            });\n          });\n        } else {\n          throw Error(\"only support time zone name for snowflake!\");\n        }\n      }\n\n      return connection;\n    } catch (err) {\n      switch (err.code) {\n        case \"ECONNREFUSED\":\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n\n        case \"ER_ACCESS_DENIED_ERROR\":\n          throw new SequelizeErrors.AccessDeniedError(err);\n\n        case \"ENOTFOUND\":\n          throw new SequelizeErrors.HostNotFoundError(err);\n\n        case \"EHOSTUNREACH\":\n          throw new SequelizeErrors.HostNotReachableError(err);\n\n        case \"EINVAL\":\n          throw new SequelizeErrors.InvalidConnectionError(err);\n\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n\n  async disconnect(connection) {\n    if (!connection.isUp()) {\n      debug(\"connection tried to disconnect but was already at CLOSED state\");\n      return;\n    }\n\n    return new Promise((resolve, reject) => {\n      connection.destroy(err => {\n        if (err) {\n          console.error(`Unable to disconnect: ${err.message}`);\n          reject(err);\n        } else {\n          console.log(`Disconnected connection with id: ${connection.getId()}`);\n          resolve(connection.getId());\n        }\n      });\n    });\n  }\n\n  validate(connection) {\n    return connection.isUp();\n  }\n\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"mappings":"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","names":["AbstractConnectionManager","require","SequelizeErrors","logger","DataTypes","snowflake","debug","debugContext","parserStore","constructor","dialect","sequelize","config","port","lib","_loadDialectModule","refreshTypeParser","_refreshTypeParser","dataType","refresh","_clearTypeParser","clear","field","next","get","type","options","connectionConfig","__spreadValues","account","host","username","password","database","warehouse","role","dialectOptions","connection","Promise","resolve","reject","createConnection","connect","err","conn","console","log","keepDefaultTimezone","tzOffset","timezone","isNamedTzOffset","test","execute","sqlText","complete","Error","code","ConnectionRefusedError","AccessDeniedError","HostNotFoundError","HostNotReachableError","InvalidConnectionError","ConnectionError","isUp","destroy","error","message","getId","validate","module","exports","ConnectionManager","default"],"sources":["/Users/aurele/node_modules/sequelize/src/dialects/snowflake/connection-manager.js"],"sourcesContent":["'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst SequelizeErrors = require('../../errors');\nconst { logger } = require('../../utils/logger');\nconst DataTypes = require('../../data-types').snowflake;\nconst debug = logger.debugContext('connection:snowflake');\nconst parserStore = require('../parserStore')('snowflake');\n\n/**\n * Snowflake Connection Manager\n *\n * Get connections, validate and disconnect them.\n *\n * @private\n */\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule('snowflake-sdk');\n    this.refreshTypeParser(DataTypes);\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n\n  /**\n   * Connect with a snowflake database based on config, Handle any errors in connection\n   * Set the pool handlers on connection.error\n   * Also set proper timezone once connection is connected.\n   *\n   * @param {object} config\n   * @returns {Promise<Connection>}\n   * @private\n   */\n  async connect(config) {\n    const connectionConfig = {\n      account: config.host,\n      username: config.username,\n      password: config.password,\n      database: config.database,\n      warehouse: config.warehouse,\n      role: config.role,\n      /*\n      flags: '-FOUND_ROWS',\n      timezone: this.sequelize.options.timezone,\n      typeCast: ConnectionManager._typecast.bind(this),\n      bigNumberStrings: false,\n      supportBigNumbers: true,\n      */\n      ...config.dialectOptions\n    };\n\n    try {\n\n      const connection = await new Promise((resolve, reject) => {\n        this.lib.createConnection(connectionConfig).connect((err, conn) => {\n          if (err) {\n            console.log(err);\n            reject(err);\n          } else {\n            resolve(conn);\n          }\n        });\n      });\n\n      debug('connection acquired');\n\n      if (!this.sequelize.config.keepDefaultTimezone) {\n        // default value is '+00:00', put a quick workaround for it.\n        const tzOffset = this.sequelize.options.timezone === '+00:00' ? 'Etc/UTC' : this.sequelize.options.timezone;\n        const isNamedTzOffset = /\\//.test(tzOffset);\n        if ( isNamedTzOffset ) {\n          await new Promise((resolve, reject) => {\n            connection.execute({\n              sqlText: `ALTER SESSION SET timezone = '${tzOffset}'`,\n              complete(err) {\n                if (err) {\n                  console.log(err);\n                  reject(err);\n                } else {\n                  resolve();\n                }\n              }\n            });\n          });\n        } else {\n          throw Error('only support time zone name for snowflake!');\n        }\n      }\n\n      return connection;\n    } catch (err) {\n      switch (err.code) {\n        case 'ECONNREFUSED':\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n        case 'ER_ACCESS_DENIED_ERROR':\n          throw new SequelizeErrors.AccessDeniedError(err);\n        case 'ENOTFOUND':\n          throw new SequelizeErrors.HostNotFoundError(err);\n        case 'EHOSTUNREACH':\n          throw new SequelizeErrors.HostNotReachableError(err);\n        case 'EINVAL':\n          throw new SequelizeErrors.InvalidConnectionError(err);\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n\n  async disconnect(connection) {\n    // Don't disconnect connections with CLOSED state\n    if (!connection.isUp()) {\n      debug('connection tried to disconnect but was already at CLOSED state');\n      return;\n    }\n\n    return new Promise((resolve, reject) => {\n      connection.destroy(err => {\n        if (err) {\n          console.error(`Unable to disconnect: ${err.message}`);\n          reject(err);\n        } else {\n          console.log(`Disconnected connection with id: ${connection.getId()}`);\n          resolve(connection.getId());\n        }\n      });\n    });\n  }\n\n  validate(connection) {\n    return connection.isUp();\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"]},"metadata":{},"sourceType":"script"}