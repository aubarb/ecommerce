{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\n\nconst wkx = require(\"wkx\");\n\nmodule.exports = BaseTypes => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(void 0, \"http://www.postgresql.org/docs/9.4/static/datatype.html\");\n\n  function removeUnsupportedIntegerOptions(dataType) {\n    if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {\n      warn(`PostgresSQL does not support '${dataType.key}' with LENGTH, UNSIGNED or ZEROFILL. Plain '${dataType.key}' will be used instead.`);\n      dataType._length = void 0;\n      dataType.options.length = void 0;\n      dataType._unsigned = void 0;\n      dataType._zerofill = void 0;\n    }\n  }\n\n  BaseTypes.UUID.types.postgres = [\"uuid\"];\n  BaseTypes.CIDR.types.postgres = [\"cidr\"];\n  BaseTypes.INET.types.postgres = [\"inet\"];\n  BaseTypes.MACADDR.types.postgres = [\"macaddr\"];\n  BaseTypes.TSVECTOR.types.postgres = [\"tsvector\"];\n  BaseTypes.JSON.types.postgres = [\"json\"];\n  BaseTypes.JSONB.types.postgres = [\"jsonb\"];\n  BaseTypes.TIME.types.postgres = [\"time\"];\n\n  class DATEONLY extends BaseTypes.DATEONLY {\n    _stringify(value, options) {\n      if (value === Infinity) {\n        return \"Infinity\";\n      }\n\n      if (value === -Infinity) {\n        return \"-Infinity\";\n      }\n\n      return super._stringify(value, options);\n    }\n\n    _sanitize(value, options) {\n      if ((!options || options && !options.raw) && value !== Infinity && value !== -Infinity) {\n        if (typeof value === \"string\") {\n          const lower = value.toLowerCase();\n\n          if (lower === \"infinity\") {\n            return Infinity;\n          }\n\n          if (lower === \"-infinity\") {\n            return -Infinity;\n          }\n        }\n\n        return super._sanitize(value);\n      }\n\n      return value;\n    }\n\n    static parse(value) {\n      if (value === \"infinity\") {\n        return Infinity;\n      }\n\n      if (value === \"-infinity\") {\n        return -Infinity;\n      }\n\n      return value;\n    }\n\n  }\n\n  BaseTypes.DATEONLY.types.postgres = [\"date\"];\n\n  class DECIMAL extends BaseTypes.DECIMAL {\n    static parse(value) {\n      return value;\n    }\n\n  }\n\n  BaseTypes.DECIMAL.types.postgres = [\"numeric\"];\n\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (this._binary) {\n        return \"BYTEA\";\n      }\n\n      return super.toSql();\n    }\n\n  }\n\n  BaseTypes.STRING.types.postgres = [\"varchar\"];\n\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      if (this._length) {\n        warn(\"PostgreSQL does not support TEXT with options. Plain `TEXT` will be used instead.\");\n        this._length = void 0;\n      }\n\n      return \"TEXT\";\n    }\n\n  }\n\n  BaseTypes.TEXT.types.postgres = [\"text\"];\n\n  class CITEXT extends BaseTypes.CITEXT {\n    static parse(value) {\n      return value;\n    }\n\n  }\n\n  BaseTypes.CITEXT.types.postgres = [\"citext\"];\n\n  class CHAR extends BaseTypes.CHAR {\n    toSql() {\n      if (this._binary) {\n        return \"BYTEA\";\n      }\n\n      return super.toSql();\n    }\n\n  }\n\n  BaseTypes.CHAR.types.postgres = [\"char\", \"bpchar\"];\n\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return \"BOOLEAN\";\n    }\n\n    _sanitize(value) {\n      if (value !== null && value !== void 0) {\n        if (Buffer.isBuffer(value) && value.length === 1) {\n          value = value[0];\n        }\n\n        if (typeof value === \"string\") {\n          return [\"true\", \"t\"].includes(value) ? true : [\"false\", \"f\"].includes(value) ? false : value;\n        }\n\n        if (typeof value === \"number\") {\n          return value === 1 ? true : value === 0 ? false : value;\n        }\n      }\n\n      return value;\n    }\n\n  }\n\n  BOOLEAN.parse = BOOLEAN.prototype._sanitize;\n  BaseTypes.BOOLEAN.types.postgres = [\"bool\"];\n\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return \"TIMESTAMP WITH TIME ZONE\";\n    }\n\n    validate(value) {\n      if (value !== Infinity && value !== -Infinity) {\n        return super.validate(value);\n      }\n\n      return true;\n    }\n\n    _stringify(value, options) {\n      if (value === Infinity) {\n        return \"Infinity\";\n      }\n\n      if (value === -Infinity) {\n        return \"-Infinity\";\n      }\n\n      return super._stringify(value, options);\n    }\n\n    _sanitize(value, options) {\n      if ((!options || options && !options.raw) && !(value instanceof Date) && !!value && value !== Infinity && value !== -Infinity) {\n        if (typeof value === \"string\") {\n          const lower = value.toLowerCase();\n\n          if (lower === \"infinity\") {\n            return Infinity;\n          }\n\n          if (lower === \"-infinity\") {\n            return -Infinity;\n          }\n        }\n\n        return new Date(value);\n      }\n\n      return value;\n    }\n\n  }\n\n  BaseTypes.DATE.types.postgres = [\"timestamptz\"];\n\n  class TINYINT extends BaseTypes.TINYINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n\n  }\n\n  BaseTypes.TINYINT.types.postgres = [\"int2\"];\n\n  class SMALLINT extends BaseTypes.SMALLINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n\n  }\n\n  BaseTypes.SMALLINT.types.postgres = [\"int2\"];\n\n  class INTEGER extends BaseTypes.INTEGER {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n\n  }\n\n  INTEGER.parse = function parse(value) {\n    return parseInt(value, 10);\n  };\n\n  BaseTypes.INTEGER.types.postgres = [\"int4\"];\n\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n\n  }\n\n  BaseTypes.BIGINT.types.postgres = [\"int8\"];\n\n  class REAL extends BaseTypes.REAL {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n\n  }\n\n  BaseTypes.REAL.types.postgres = [\"float4\"];\n\n  class DOUBLE extends BaseTypes.DOUBLE {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n\n  }\n\n  BaseTypes.DOUBLE.types.postgres = [\"float8\"];\n\n  class FLOAT extends BaseTypes.FLOAT {\n    constructor(length, decimals) {\n      super(length, decimals);\n\n      if (this._decimals) {\n        warn(\"PostgreSQL does not support FLOAT with decimals. Plain `FLOAT` will be used instead.\");\n        this._length = void 0;\n        this.options.length = void 0;\n        this._decimals = void 0;\n      }\n\n      if (this._unsigned) {\n        warn(\"PostgreSQL does not support FLOAT unsigned. `UNSIGNED` was removed.\");\n        this._unsigned = void 0;\n      }\n\n      if (this._zerofill) {\n        warn(\"PostgreSQL does not support FLOAT zerofill. `ZEROFILL` was removed.\");\n        this._zerofill = void 0;\n      }\n    }\n\n  }\n\n  delete FLOAT.parse;\n\n  class BLOB extends BaseTypes.BLOB {\n    toSql() {\n      if (this._length) {\n        warn(\"PostgreSQL does not support BLOB (BYTEA) with options. Plain `BYTEA` will be used instead.\");\n        this._length = void 0;\n      }\n\n      return \"BYTEA\";\n    }\n\n    _hexify(hex) {\n      return `E'\\\\\\\\x${hex}'`;\n    }\n\n  }\n\n  BaseTypes.BLOB.types.postgres = [\"bytea\"];\n\n  class GEOMETRY extends BaseTypes.GEOMETRY {\n    toSql() {\n      let result = this.key;\n\n      if (this.type) {\n        result += `(${this.type}`;\n\n        if (this.srid) {\n          result += `,${this.srid}`;\n        }\n\n        result += \")\";\n      }\n\n      return result;\n    }\n\n    static parse(value) {\n      const b = Buffer.from(value, \"hex\");\n      return wkx.Geometry.parse(b).toGeoJSON({\n        shortCrs: true\n      });\n    }\n\n    _stringify(value, options) {\n      return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;\n    }\n\n    _bindParam(value, options) {\n      return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;\n    }\n\n  }\n\n  BaseTypes.GEOMETRY.types.postgres = [\"geometry\"];\n\n  class GEOGRAPHY extends BaseTypes.GEOGRAPHY {\n    toSql() {\n      let result = \"GEOGRAPHY\";\n\n      if (this.type) {\n        result += `(${this.type}`;\n\n        if (this.srid) {\n          result += `,${this.srid}`;\n        }\n\n        result += \")\";\n      }\n\n      return result;\n    }\n\n    static parse(value) {\n      const b = Buffer.from(value, \"hex\");\n      return wkx.Geometry.parse(b).toGeoJSON({\n        shortCrs: true\n      });\n    }\n\n    _stringify(value, options) {\n      return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;\n    }\n\n    bindParam(value, options) {\n      return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;\n    }\n\n  }\n\n  BaseTypes.GEOGRAPHY.types.postgres = [\"geography\"];\n  let hstore;\n\n  class HSTORE extends BaseTypes.HSTORE {\n    constructor() {\n      super();\n\n      if (!hstore) {\n        hstore = require(\"./hstore\");\n      }\n    }\n\n    _value(value) {\n      if (!hstore) {\n        hstore = require(\"./hstore\");\n      }\n\n      return hstore.stringify(value);\n    }\n\n    _stringify(value) {\n      return `'${this._value(value)}'`;\n    }\n\n    _bindParam(value, options) {\n      return options.bindParam(this._value(value));\n    }\n\n    static parse(value) {\n      if (!hstore) {\n        hstore = require(\"./hstore\");\n      }\n\n      return hstore.parse(value);\n    }\n\n  }\n\n  HSTORE.prototype.escape = false;\n  BaseTypes.HSTORE.types.postgres = [\"hstore\"];\n\n  class RANGE extends BaseTypes.RANGE {\n    _value(values, options) {\n      if (!Array.isArray(values)) {\n        return this.options.subtype.stringify(values, options);\n      }\n\n      const valueInclusivity = [true, false];\n      const valuesStringified = values.map((value, index) => {\n        if (_.isObject(value) && Object.prototype.hasOwnProperty.call(value, \"value\")) {\n          if (Object.prototype.hasOwnProperty.call(value, \"inclusive\")) {\n            valueInclusivity[index] = value.inclusive;\n          }\n\n          value = value.value;\n        }\n\n        if (value === null || value === -Infinity || value === Infinity) {\n          return value;\n        }\n\n        if (this.options.subtype.stringify) {\n          return this.options.subtype.stringify(value, options);\n        }\n\n        return options.escape(value);\n      });\n      valuesStringified.inclusive = valueInclusivity;\n      return range.stringify(valuesStringified);\n    }\n\n    _stringify(values, options) {\n      const value = this._value(values, options);\n\n      if (!Array.isArray(values)) {\n        return `'${value}'::${this.toCastType()}`;\n      }\n\n      return `'${value}'`;\n    }\n\n    _bindParam(values, options) {\n      const value = this._value(values, options);\n\n      if (!Array.isArray(values)) {\n        return `${options.bindParam(value)}::${this.toCastType()}`;\n      }\n\n      return options.bindParam(value);\n    }\n\n    toSql() {\n      return BaseTypes.RANGE.types.postgres.subtypes[this._subtype.toLowerCase()];\n    }\n\n    toCastType() {\n      return BaseTypes.RANGE.types.postgres.castTypes[this._subtype.toLowerCase()];\n    }\n\n    static parse(value) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        parser: val => val\n      };\n      return range.parse(value, options.parser);\n    }\n\n  }\n\n  const range = require(\"./range\");\n\n  RANGE.prototype.escape = false;\n  BaseTypes.RANGE.types.postgres = {\n    subtypes: {\n      integer: \"int4range\",\n      decimal: \"numrange\",\n      date: \"tstzrange\",\n      dateonly: \"daterange\",\n      bigint: \"int8range\"\n    },\n    castTypes: {\n      integer: \"int4\",\n      decimal: \"numeric\",\n      date: \"timestamptz\",\n      dateonly: \"date\",\n      bigint: \"int8\"\n    }\n  };\n  BaseTypes.ARRAY.prototype.escape = false;\n\n  BaseTypes.ARRAY.prototype._value = function _value(values, options) {\n    return values.map(value => {\n      if (options && options.bindParam && this.type && this.type._value) {\n        return this.type._value(value, options);\n      }\n\n      if (this.type && this.type.stringify) {\n        value = this.type.stringify(value, options);\n\n        if (this.type.escape === false) {\n          return value;\n        }\n      }\n\n      return options.escape(value);\n    }, this);\n  };\n\n  BaseTypes.ARRAY.prototype._stringify = function _stringify(values, options) {\n    let str = `ARRAY[${this._value(values, options).join(\",\")}]`;\n\n    if (this.type) {\n      const Utils = require(\"../../utils\");\n\n      let castKey = this.toSql();\n\n      if (this.type instanceof BaseTypes.ENUM) {\n        const table = options.field.Model.getTableName();\n        const useSchema = table.schema !== void 0;\n        const schemaWithDelimiter = useSchema ? `${Utils.addTicks(table.schema, '\"')}${table.delimiter}` : \"\";\n        castKey = `${Utils.addTicks(Utils.generateEnumName(useSchema ? table.tableName : table, options.field.field), '\"')}[]`;\n        str += `::${schemaWithDelimiter}${castKey}`;\n      } else {\n        str += `::${castKey}`;\n      }\n    }\n\n    return str;\n  };\n\n  BaseTypes.ARRAY.prototype._bindParam = function _bindParam(values, options) {\n    return options.bindParam(this._value(values, options));\n  };\n\n  class ENUM extends BaseTypes.ENUM {\n    static parse(value) {\n      return value;\n    }\n\n  }\n\n  BaseTypes.ENUM.types.postgres = [null];\n  return {\n    DECIMAL,\n    BLOB,\n    STRING,\n    CHAR,\n    TEXT,\n    CITEXT,\n    TINYINT,\n    SMALLINT,\n    INTEGER,\n    BIGINT,\n    BOOLEAN,\n    DATE,\n    DATEONLY,\n    REAL,\n    \"DOUBLE PRECISION\": DOUBLE,\n    FLOAT,\n    GEOMETRY,\n    GEOGRAPHY,\n    HSTORE,\n    RANGE,\n    ENUM\n  };\n};","map":{"version":3,"mappings":"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","names":["_","require","wkx","module","exports","BaseTypes","warn","ABSTRACT","bind","dataType","_length","options","length","_unsigned","_zerofill","key","UUID","types","postgres","CIDR","INET","MACADDR","TSVECTOR","JSON","JSONB","TIME","DATEONLY","_stringify","value","Infinity","_sanitize","raw","lower","toLowerCase","DECIMAL","STRING","toSql","_binary","TEXT","CITEXT","CHAR","BOOLEAN","Buffer","isBuffer","includes","parse","prototype","DATE","validate","Date","TINYINT","constructor","removeUnsupportedIntegerOptions","SMALLINT","INTEGER","parseInt","BIGINT","REAL","DOUBLE","FLOAT","decimals","_decimals","BLOB","_hexify","hex","GEOMETRY","result","type","srid","b","from","Geometry","toGeoJSON","shortCrs","escape","stringify","_bindParam","bindParam","GEOGRAPHY","hstore","HSTORE","_value","RANGE","values","Array","isArray","subtype","valueInclusivity","valuesStringified","map","index","isObject","Object","hasOwnProperty","call","inclusive","range","toCastType","subtypes","_subtype","castTypes","parser","val","integer","decimal","date","dateonly","bigint","ARRAY","str","join","Utils","castKey","ENUM","table","field","Model","getTableName","useSchema","schema","schemaWithDelimiter","addTicks","delimiter","generateEnumName","tableName"],"sources":["/Users/aurele/node_modules/sequelize/src/dialects/postgres/data-types.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst wkx = require('wkx');\n\nmodule.exports = BaseTypes => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(undefined, 'http://www.postgresql.org/docs/9.4/static/datatype.html');\n\n  /**\n   * Removes unsupported Postgres options, i.e., LENGTH, UNSIGNED and ZEROFILL, for the integer data types.\n   *\n   * @param {object} dataType The base integer data type.\n   * @private\n   */\n  function removeUnsupportedIntegerOptions(dataType) {\n    if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {\n      warn(`PostgresSQL does not support '${dataType.key}' with LENGTH, UNSIGNED or ZEROFILL. Plain '${dataType.key}' will be used instead.`);\n      dataType._length = undefined;\n      dataType.options.length = undefined;\n      dataType._unsigned = undefined;\n      dataType._zerofill = undefined;\n    }\n  }\n\n  /**\n   * types:\n   * {\n   *   oids: [oid],\n   *   array_oids: [oid]\n   * }\n   *\n   * @see oid here https://github.com/lib/pq/blob/master/oid/types.go\n   */\n\n  BaseTypes.UUID.types.postgres = ['uuid'];\n  BaseTypes.CIDR.types.postgres = ['cidr'];\n  BaseTypes.INET.types.postgres = ['inet'];\n  BaseTypes.MACADDR.types.postgres = ['macaddr'];\n  BaseTypes.TSVECTOR.types.postgres = ['tsvector'];\n  BaseTypes.JSON.types.postgres = ['json'];\n  BaseTypes.JSONB.types.postgres = ['jsonb'];\n  BaseTypes.TIME.types.postgres = ['time'];\n\n  class DATEONLY extends BaseTypes.DATEONLY {\n    _stringify(value, options) {\n      if (value === Infinity) {\n        return 'Infinity';\n      }\n      if (value === -Infinity) {\n        return '-Infinity';\n      }\n      return super._stringify(value, options);\n    }\n    _sanitize(value, options) {\n      if ((!options || options && !options.raw) && value !== Infinity && value !== -Infinity) {\n        if (typeof value === 'string') {\n          const lower = value.toLowerCase();\n          if (lower === 'infinity') {\n            return Infinity;\n          }\n          if (lower === '-infinity') {\n            return -Infinity;\n          }\n        }\n        return super._sanitize(value);\n      }\n      return value;\n    }\n    static parse(value) {\n      if (value === 'infinity') {\n        return Infinity;\n      }\n      if (value === '-infinity') {\n        return -Infinity;\n      }\n      return value;\n    }\n  }\n\n  BaseTypes.DATEONLY.types.postgres = ['date'];\n\n  class DECIMAL extends BaseTypes.DECIMAL {\n    static parse(value) {\n      return value;\n    }\n  }\n\n  // numeric\n  BaseTypes.DECIMAL.types.postgres = ['numeric'];\n\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (this._binary) {\n        return 'BYTEA';\n      }\n      return super.toSql();\n    }\n  }\n\n  BaseTypes.STRING.types.postgres = ['varchar'];\n\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      if (this._length) {\n        warn('PostgreSQL does not support TEXT with options. Plain `TEXT` will be used instead.');\n        this._length = undefined;\n      }\n      return 'TEXT';\n    }\n  }\n\n  BaseTypes.TEXT.types.postgres = ['text'];\n\n  class CITEXT extends BaseTypes.CITEXT {\n    static parse(value) {\n      return value;\n    }\n  }\n\n  BaseTypes.CITEXT.types.postgres = ['citext'];\n\n  class CHAR extends BaseTypes.CHAR {\n    toSql() {\n      if (this._binary) {\n        return 'BYTEA';\n      }\n      return super.toSql();\n    }\n  }\n\n  BaseTypes.CHAR.types.postgres = ['char', 'bpchar'];\n\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return 'BOOLEAN';\n    }\n    _sanitize(value) {\n      if (value !== null && value !== undefined) {\n        if (Buffer.isBuffer(value) && value.length === 1) {\n          // Bit fields are returned as buffers\n          value = value[0];\n        }\n        if (typeof value === 'string') {\n          // Only take action on valid boolean strings.\n          return ['true', 't'].includes(value) ? true : ['false', 'f'].includes(value) ? false : value;\n        }\n        if (typeof value === 'number') {\n          // Only take action on valid boolean integers.\n          return value === 1 ? true : value === 0 ? false : value;\n        }\n      }\n      return value;\n    }\n  }\n\n  BOOLEAN.parse = BOOLEAN.prototype._sanitize;\n\n  BaseTypes.BOOLEAN.types.postgres = ['bool'];\n\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return 'TIMESTAMP WITH TIME ZONE';\n    }\n    validate(value) {\n      if (value !== Infinity && value !== -Infinity) {\n        return super.validate(value);\n      }\n      return true;\n    }\n    _stringify(value, options) {\n      if (value === Infinity) {\n        return 'Infinity';\n      }\n      if (value === -Infinity) {\n        return '-Infinity';\n      }\n      return super._stringify(value, options);\n    }\n    _sanitize(value, options) {\n      if ((!options || options && !options.raw) && !(value instanceof Date) && !!value && value !== Infinity && value !== -Infinity) {\n        if (typeof value === 'string') {\n          const lower = value.toLowerCase();\n          if (lower === 'infinity') {\n            return Infinity;\n          }\n          if (lower === '-infinity') {\n            return -Infinity;\n          }\n        }\n        return new Date(value);\n      }\n      return value;\n    }\n  }\n\n  BaseTypes.DATE.types.postgres = ['timestamptz'];\n\n  class TINYINT extends BaseTypes.TINYINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  // int2\n  BaseTypes.TINYINT.types.postgres = ['int2'];\n\n  class SMALLINT extends BaseTypes.SMALLINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  // int2\n  BaseTypes.SMALLINT.types.postgres = ['int2'];\n\n  class INTEGER extends BaseTypes.INTEGER {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  INTEGER.parse = function parse(value) {\n    return parseInt(value, 10);\n  };\n\n  // int4\n  BaseTypes.INTEGER.types.postgres = ['int4'];\n\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  // int8\n  BaseTypes.BIGINT.types.postgres = ['int8'];\n\n  class REAL extends BaseTypes.REAL {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  // float4\n  BaseTypes.REAL.types.postgres = ['float4'];\n\n  class DOUBLE extends BaseTypes.DOUBLE {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  // float8\n  BaseTypes.DOUBLE.types.postgres = ['float8'];\n\n  class FLOAT extends BaseTypes.FLOAT {\n    constructor(length, decimals) {\n      super(length, decimals);\n      // POSTGRES does only support lengths as parameter.\n      // Values between 1-24 result in REAL\n      // Values between 25-53 result in DOUBLE PRECISION\n      // If decimals are provided remove these and print a warning\n      if (this._decimals) {\n        warn('PostgreSQL does not support FLOAT with decimals. Plain `FLOAT` will be used instead.');\n        this._length = undefined;\n        this.options.length = undefined;\n        this._decimals = undefined;\n      }\n      if (this._unsigned) {\n        warn('PostgreSQL does not support FLOAT unsigned. `UNSIGNED` was removed.');\n        this._unsigned = undefined;\n      }\n      if (this._zerofill) {\n        warn('PostgreSQL does not support FLOAT zerofill. `ZEROFILL` was removed.');\n        this._zerofill = undefined;\n      }\n    }\n  }\n  delete FLOAT.parse; // Float has no separate type in PG\n\n  class BLOB extends BaseTypes.BLOB {\n    toSql() {\n      if (this._length) {\n        warn('PostgreSQL does not support BLOB (BYTEA) with options. Plain `BYTEA` will be used instead.');\n        this._length = undefined;\n      }\n      return 'BYTEA';\n    }\n    _hexify(hex) {\n      // bytea hex format http://www.postgresql.org/docs/current/static/datatype-binary.html\n      return `E'\\\\\\\\x${hex}'`;\n    }\n  }\n\n  BaseTypes.BLOB.types.postgres = ['bytea'];\n\n  class GEOMETRY extends BaseTypes.GEOMETRY {\n    toSql() {\n      let result = this.key;\n      if (this.type) {\n        result += `(${this.type}`;\n        if (this.srid) {\n          result += `,${this.srid}`;\n        }\n        result += ')';\n      }\n      return result;\n    }\n    static parse(value) {\n      const b = Buffer.from(value, 'hex');\n      return wkx.Geometry.parse(b).toGeoJSON({ shortCrs: true });\n    }\n    _stringify(value, options) {\n      return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;\n    }\n    _bindParam(value, options) {\n      return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;\n    }\n  }\n\n  BaseTypes.GEOMETRY.types.postgres = ['geometry'];\n\n\n  class GEOGRAPHY extends BaseTypes.GEOGRAPHY {\n    toSql() {\n      let result = 'GEOGRAPHY';\n      if (this.type) {\n        result += `(${this.type}`;\n        if (this.srid) {\n          result += `,${this.srid}`;\n        }\n        result += ')';\n      }\n      return result;\n    }\n    static parse(value) {\n      const b = Buffer.from(value, 'hex');\n      return wkx.Geometry.parse(b).toGeoJSON({ shortCrs: true });\n    }\n    _stringify(value, options) {\n      return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;\n    }\n    bindParam(value, options) {\n      return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;\n    }\n  }\n\n  BaseTypes.GEOGRAPHY.types.postgres = ['geography'];\n\n  let hstore;\n\n  class HSTORE extends BaseTypes.HSTORE {\n    constructor() {\n      super();\n      if (!hstore) {\n        // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated\n        hstore = require('./hstore');\n      }\n    }\n    _value(value) {\n      if (!hstore) {\n        // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated\n        hstore = require('./hstore');\n      }\n      return hstore.stringify(value);\n    }\n    _stringify(value) {\n      return `'${this._value(value)}'`;\n    }\n    _bindParam(value, options) {\n      return options.bindParam(this._value(value));\n    }\n    static parse(value) {\n      if (!hstore) {\n        // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated\n        hstore = require('./hstore');\n      }\n      return hstore.parse(value);\n    }\n  }\n\n  HSTORE.prototype.escape = false;\n\n  BaseTypes.HSTORE.types.postgres = ['hstore'];\n\n  class RANGE extends BaseTypes.RANGE {\n    _value(values, options) {\n      if (!Array.isArray(values)) {\n        return this.options.subtype.stringify(values, options);\n      }\n      const valueInclusivity = [true, false];\n      const valuesStringified = values.map((value, index) => {\n        if (_.isObject(value) && Object.prototype.hasOwnProperty.call(value, 'value')) {\n          if (Object.prototype.hasOwnProperty.call(value, 'inclusive')) {\n            valueInclusivity[index] = value.inclusive;\n          }\n          value = value.value;\n        }\n        if (value === null || value === -Infinity || value === Infinity) {\n          // Pass through \"unbounded\" bounds unchanged\n          return value;\n        }\n        if (this.options.subtype.stringify) {\n          return this.options.subtype.stringify(value, options);\n        }\n        return options.escape(value);\n      });\n      // Array.map does not preserve extra array properties\n      valuesStringified.inclusive = valueInclusivity;\n      return range.stringify(valuesStringified);\n    }\n    _stringify(values, options) {\n      const value = this._value(values, options);\n      if (!Array.isArray(values)) {\n        return `'${value}'::${this.toCastType()}`;\n      }\n      return `'${value}'`;\n    }\n    _bindParam(values, options) {\n      const value = this._value(values, options);\n      if (!Array.isArray(values)) {\n        return `${options.bindParam(value)}::${this.toCastType()}`;\n      }\n      return options.bindParam(value);\n    }\n    toSql() {\n      return BaseTypes.RANGE.types.postgres.subtypes[this._subtype.toLowerCase()];\n    }\n    toCastType() {\n      return BaseTypes.RANGE.types.postgres.castTypes[this._subtype.toLowerCase()];\n    }\n    static parse(value, options = { parser: val => val }) {\n      return range.parse(value, options.parser);\n    }\n  }\n  const range = require('./range');\n\n  RANGE.prototype.escape = false;\n\n  BaseTypes.RANGE.types.postgres = {\n    subtypes: {\n      integer: 'int4range',\n      decimal: 'numrange',\n      date: 'tstzrange',\n      dateonly: 'daterange',\n      bigint: 'int8range'\n    },\n    castTypes: {\n      integer: 'int4',\n      decimal: 'numeric',\n      date: 'timestamptz',\n      dateonly: 'date',\n      bigint: 'int8'\n    }\n  };\n\n  // TODO: Why are base types being manipulated??\n  BaseTypes.ARRAY.prototype.escape = false;\n  BaseTypes.ARRAY.prototype._value = function _value(values, options) {\n    return values.map(value => {\n      if (options && options.bindParam && this.type && this.type._value) {\n        return this.type._value(value, options);\n      }\n      if (this.type && this.type.stringify) {\n        value = this.type.stringify(value, options);\n\n        if (this.type.escape === false) {\n          return value;\n        }\n      }\n      return options.escape(value);\n    }, this);\n  };\n  BaseTypes.ARRAY.prototype._stringify = function _stringify(values, options) {\n    let str = `ARRAY[${this._value(values, options).join(',')}]`;\n\n    if (this.type) {\n      const Utils = require('../../utils');\n      let castKey = this.toSql();\n\n      if (this.type instanceof BaseTypes.ENUM) {\n        const table = options.field.Model.getTableName();\n        const useSchema = table.schema !== undefined;\n        const schemaWithDelimiter = useSchema ? `${Utils.addTicks(table.schema, '\"')}${table.delimiter}` : '';\n\n        castKey = `${Utils.addTicks(\n          Utils.generateEnumName(useSchema ? table.tableName : table, options.field.field),\n          '\"'\n        ) }[]`;\n\n        str += `::${schemaWithDelimiter}${castKey}`;\n      } else {\n        str += `::${castKey}`;\n      }\n    }\n\n    return str;\n  };\n  BaseTypes.ARRAY.prototype._bindParam = function _bindParam(values, options) {\n    return options.bindParam(this._value(values, options));\n  };\n\n  class ENUM extends BaseTypes.ENUM {\n    static parse(value) {\n      return value;\n    }\n  }\n\n  BaseTypes.ENUM.types.postgres = [null];\n\n  return {\n    DECIMAL,\n    BLOB,\n    STRING,\n    CHAR,\n    TEXT,\n    CITEXT,\n    TINYINT,\n    SMALLINT,\n    INTEGER,\n    BIGINT,\n    BOOLEAN,\n    DATE,\n    DATEONLY,\n    REAL,\n    'DOUBLE PRECISION': DOUBLE,\n    FLOAT,\n    GEOMETRY,\n    GEOGRAPHY,\n    HSTORE,\n    RANGE,\n    ENUM\n  };\n};\n"]},"metadata":{},"sourceType":"script"}