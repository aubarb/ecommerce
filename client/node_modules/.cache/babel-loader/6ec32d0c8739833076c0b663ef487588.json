{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nconst Utils = require(\"../../utils\");\n\nconst util = require(\"util\");\n\nconst DataTypes = require(\"../../data-types\");\n\nconst AbstractQueryGenerator = require(\"../abstract/query-generator\");\n\nconst semver = require(\"semver\");\n\nconst _ = require(\"lodash\");\n\nconst POSTGRES_RESERVED_WORDS = \"all,analyse,analyze,and,any,array,as,asc,asymmetric,authorization,binary,both,case,cast,check,collate,collation,column,concurrently,constraint,create,cross,current_catalog,current_date,current_role,current_schema,current_time,current_timestamp,current_user,default,deferrable,desc,distinct,do,else,end,except,false,fetch,for,foreign,freeze,from,full,grant,group,having,ilike,in,initially,inner,intersect,into,is,isnull,join,lateral,leading,left,like,limit,localtime,localtimestamp,natural,not,notnull,null,offset,on,only,or,order,outer,overlaps,placing,primary,references,returning,right,select,session_user,similar,some,symmetric,table,tablesample,then,to,trailing,true,union,unique,user,using,variadic,verbose,when,where,window,with\".split(\",\");\n\nclass PostgresQueryGenerator extends AbstractQueryGenerator {\n  setSearchPath(searchPath) {\n    return `SET search_path to ${searchPath};`;\n  }\n\n  createDatabaseQuery(databaseName, options) {\n    options = __spreadValues({\n      encoding: null,\n      collate: null\n    }, options);\n    const values = {\n      database: this.quoteTable(databaseName),\n      encoding: options.encoding ? ` ENCODING = ${this.escape(options.encoding)}` : \"\",\n      collation: options.collate ? ` LC_COLLATE = ${this.escape(options.collate)}` : \"\",\n      ctype: options.ctype ? ` LC_CTYPE = ${this.escape(options.ctype)}` : \"\",\n      template: options.template ? ` TEMPLATE = ${this.escape(options.template)}` : \"\"\n    };\n    return `CREATE DATABASE ${values.database}${values.encoding}${values.collation}${values.ctype}${values.template};`;\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteTable(databaseName)};`;\n  }\n\n  createSchema(schema) {\n    const databaseVersion = _.get(this, \"sequelize.options.databaseVersion\", 0);\n\n    if (databaseVersion && semver.gte(databaseVersion, \"9.2.0\")) {\n      return `CREATE SCHEMA IF NOT EXISTS ${schema};`;\n    }\n\n    return `CREATE SCHEMA ${schema};`;\n  }\n\n  dropSchema(schema) {\n    return `DROP SCHEMA IF EXISTS ${schema} CASCADE;`;\n  }\n\n  showSchemasQuery() {\n    return \"SELECT schema_name FROM information_schema.schemata WHERE schema_name <> 'information_schema' AND schema_name != 'public' AND schema_name !~ E'^pg_';\";\n  }\n\n  versionQuery() {\n    return \"SHOW SERVER_VERSION\";\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = __spreadValues({}, options);\n\n    const databaseVersion = _.get(this, \"sequelize.options.databaseVersion\", 0);\n\n    const attrStr = [];\n    let comments = \"\";\n    let columnComments = \"\";\n    const quotedTable = this.quoteTable(tableName);\n\n    if (options.comment && typeof options.comment === \"string\") {\n      comments += `; COMMENT ON TABLE ${quotedTable} IS ${this.escape(options.comment)}`;\n    }\n\n    for (const attr in attributes) {\n      const quotedAttr = this.quoteIdentifier(attr);\n      const i = attributes[attr].indexOf(\"COMMENT \");\n\n      if (i !== -1) {\n        const escapedCommentText = this.escape(attributes[attr].substring(i + 8));\n        columnComments += `; COMMENT ON COLUMN ${quotedTable}.${quotedAttr} IS ${escapedCommentText}`;\n        attributes[attr] = attributes[attr].substring(0, i);\n      }\n\n      const dataType = this.dataTypeMapping(tableName, attr, attributes[attr]);\n      attrStr.push(`${quotedAttr} ${dataType}`);\n    }\n\n    let attributesClause = attrStr.join(\", \");\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, columns => {\n        if (columns.customIndex) {\n          attributesClause += `, UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(\", \")})`;\n        }\n      });\n    }\n\n    const pks = _.reduce(attributes, (acc, attribute, key) => {\n      if (attribute.includes(\"PRIMARY KEY\")) {\n        acc.push(this.quoteIdentifier(key));\n      }\n\n      return acc;\n    }, []).join(\",\");\n\n    if (pks.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pks})`;\n    }\n\n    return `CREATE TABLE ${databaseVersion === 0 || semver.gte(databaseVersion, \"9.1.0\") ? \"IF NOT EXISTS \" : \"\"}${quotedTable} (${attributesClause})${comments}${columnComments};`;\n  }\n\n  dropTableQuery(tableName, options) {\n    options = options || {};\n    return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)}${options.cascade ? \" CASCADE\" : \"\"};`;\n  }\n\n  showTablesQuery() {\n    const schema = this.options.schema || \"public\";\n    return `SELECT table_name FROM information_schema.tables WHERE table_schema = ${this.escape(schema)} AND table_type LIKE '%TABLE' AND table_name != 'spatial_ref_sys';`;\n  }\n\n  tableExistsQuery(tableName) {\n    const table = tableName.tableName || tableName;\n    const schema = tableName.schema || \"public\";\n    return `SELECT table_name FROM information_schema.tables WHERE table_schema = ${this.escape(schema)} AND table_name = ${this.escape(table)}`;\n  }\n\n  describeTableQuery(tableName, schema) {\n    schema = schema || this.options.schema || \"public\";\n    return `SELECT pk.constraint_type as \"Constraint\",c.column_name as \"Field\", c.column_default as \"Default\",c.is_nullable as \"Null\", (CASE WHEN c.udt_name = 'hstore' THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN '(' || c.character_maximum_length || ')' ELSE '' END) as \"Type\", (SELECT array_agg(e.enumlabel) FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid WHERE t.typname=c.udt_name) AS \"special\", (SELECT pgd.description FROM pg_catalog.pg_statio_all_tables AS st INNER JOIN pg_catalog.pg_description pgd on (pgd.objoid=st.relid) WHERE c.ordinal_position=pgd.objsubid AND c.table_name=st.relname) AS \"Comment\" FROM information_schema.columns c LEFT JOIN (SELECT tc.table_schema, tc.table_name, cu.column_name, tc.constraint_type FROM information_schema.TABLE_CONSTRAINTS tc JOIN information_schema.KEY_COLUMN_USAGE  cu ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name and tc.constraint_name=cu.constraint_name and tc.constraint_type='PRIMARY KEY') pk ON pk.table_schema=c.table_schema AND pk.table_name=c.table_name AND pk.column_name=c.column_name WHERE c.table_name = ${this.escape(tableName)} AND c.table_schema = ${this.escape(schema)}`;\n  }\n\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== \"string\") {\n      return false;\n    }\n\n    const jsonFunctionRegex = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const jsonOperatorRegex = /^\\s*(->>?|#>>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf(\"(\");\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = jsonOperatorRegex.exec(string);\n\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n\n        if (capturedToken === \"(\") {\n          openingBrackets++;\n        } else if (capturedToken === \")\") {\n          closingBrackets++;\n        } else if (capturedToken === \";\") {\n          hasInvalidToken = true;\n          break;\n        }\n\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    return hasJsonFunction;\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition => `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);\n        return conditions.join(\" AND \");\n      }\n\n      if (smth.path) {\n        let str;\n\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          const paths = _.toPath(smth.path);\n\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (smth.value) {\n          str += util.format(\" = %s\", this.escape(smth.value));\n        }\n\n        return str;\n      }\n    }\n\n    return super.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  }\n\n  addColumnQuery(table, key, attribute) {\n    const dbDataType = this.attributeToSQL(attribute, {\n      context: \"addColumn\",\n      table,\n      key\n    });\n    const dataType = attribute.type || attribute;\n    const definition = this.dataTypeMapping(table, key, dbDataType);\n    const quotedKey = this.quoteIdentifier(key);\n    const quotedTable = this.quoteTable(this.extractTableDetails(table));\n    let query = `ALTER TABLE ${quotedTable} ADD COLUMN ${quotedKey} ${definition};`;\n\n    if (dataType instanceof DataTypes.ENUM) {\n      query = this.pgEnum(table, key, dataType) + query;\n    } else if (dataType.type && dataType.type instanceof DataTypes.ENUM) {\n      query = this.pgEnum(table, key, dataType.type) + query;\n    }\n\n    return query;\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    const quotedTableName = this.quoteTable(this.extractTableDetails(tableName));\n    const quotedAttributeName = this.quoteIdentifier(attributeName);\n    return `ALTER TABLE ${quotedTableName} DROP COLUMN ${quotedAttributeName};`;\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const query = subQuery => `ALTER TABLE ${this.quoteTable(tableName)} ALTER COLUMN ${subQuery};`;\n\n    const sql = [];\n\n    for (const attributeName in attributes) {\n      let definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);\n      let attrSql = \"\";\n\n      if (definition.includes(\"NOT NULL\")) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} SET NOT NULL`);\n        definition = definition.replace(\"NOT NULL\", \"\").trim();\n      } else if (!definition.includes(\"REFERENCES\")) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP NOT NULL`);\n      }\n\n      if (definition.includes(\"DEFAULT\")) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} SET DEFAULT ${definition.match(/DEFAULT ([^;]+)/)[1]}`);\n        definition = definition.replace(/(DEFAULT[^;]+)/, \"\").trim();\n      } else if (!definition.includes(\"REFERENCES\")) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP DEFAULT`);\n      }\n\n      if (attributes[attributeName].startsWith(\"ENUM(\")) {\n        attrSql += this.pgEnum(tableName, attributeName, attributes[attributeName]);\n        definition = definition.replace(/^ENUM\\(.+\\)/, this.pgEnumName(tableName, attributeName, {\n          schema: false\n        }));\n        definition += ` USING (${this.quoteIdentifier(attributeName)}::${this.pgEnumName(tableName, attributeName)})`;\n      }\n\n      if (definition.match(/UNIQUE;*$/)) {\n        definition = definition.replace(/UNIQUE;*$/, \"\");\n        attrSql += query(`ADD UNIQUE (${this.quoteIdentifier(attributeName)})`).replace(\"ALTER COLUMN\", \"\");\n      }\n\n      if (definition.includes(\"REFERENCES\")) {\n        definition = definition.replace(/.+?(?=REFERENCES)/, \"\");\n        attrSql += query(`ADD FOREIGN KEY (${this.quoteIdentifier(attributeName)}) ${definition}`).replace(\"ALTER COLUMN\", \"\");\n      } else {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} TYPE ${definition}`);\n      }\n\n      sql.push(attrSql);\n    }\n\n    return sql.join(\"\");\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n\n    for (const attributeName in attributes) {\n      attrString.push(`${this.quoteIdentifier(attrBefore)} TO ${this.quoteIdentifier(attributeName)}`);\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${attrString.join(\", \")};`;\n  }\n\n  fn(fnName, tableName, parameters, body, returns, language) {\n    fnName = fnName || \"testfunc\";\n    language = language || \"plpgsql\";\n    returns = returns ? `RETURNS ${returns}` : \"\";\n    parameters = parameters || \"\";\n    return `CREATE OR REPLACE FUNCTION pg_temp.${fnName}(${parameters}) ${returns} AS $func$ BEGIN ${body} END; $func$ LANGUAGE ${language}; SELECT * FROM pg_temp.${fnName}();`;\n  }\n\n  truncateTableQuery(tableName) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return [`TRUNCATE ${this.quoteTable(tableName)}`, options.restartIdentity ? \" RESTART IDENTITY\" : \"\", options.cascade ? \" CASCADE\" : \"\"].join(\"\");\n  }\n\n  deleteQuery(tableName, where) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let model = arguments.length > 3 ? arguments[3] : undefined;\n    const table = this.quoteTable(tableName);\n    let whereClause = this.getWhereConditions(where, null, model, options);\n    const limit = options.limit ? ` LIMIT ${this.escape(options.limit)}` : \"\";\n    let primaryKeys = \"\";\n    let primaryKeysSelection = \"\";\n\n    if (whereClause) {\n      whereClause = ` WHERE ${whereClause}`;\n    }\n\n    if (options.limit) {\n      if (!model) {\n        throw new Error(\"Cannot LIMIT delete without a model.\");\n      }\n\n      const pks = Object.values(model.primaryKeys).map(pk => this.quoteIdentifier(pk.field)).join(\",\");\n      primaryKeys = model.primaryKeyAttributes.length > 1 ? `(${pks})` : pks;\n      primaryKeysSelection = pks;\n      return `DELETE FROM ${table} WHERE ${primaryKeys} IN (SELECT ${primaryKeysSelection} FROM ${table}${whereClause}${limit})`;\n    }\n\n    return `DELETE FROM ${table}${whereClause}`;\n  }\n\n  showIndexesQuery(tableName) {\n    let schemaJoin = \"\";\n    let schemaWhere = \"\";\n\n    if (typeof tableName !== \"string\") {\n      schemaJoin = \", pg_namespace s\";\n      schemaWhere = ` AND s.oid = t.relnamespace AND s.nspname = '${tableName.schema}'`;\n      tableName = tableName.tableName;\n    }\n\n    return `SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a${schemaJoin} WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = '${tableName}'${schemaWhere} GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;`;\n  }\n\n  showConstraintsQuery(tableName) {\n    return ['SELECT constraint_catalog AS \"constraintCatalog\",', 'constraint_schema AS \"constraintSchema\",', 'constraint_name AS \"constraintName\",', 'table_catalog AS \"tableCatalog\",', 'table_schema AS \"tableSchema\",', 'table_name AS \"tableName\",', 'constraint_type AS \"constraintType\",', 'is_deferrable AS \"isDeferrable\",', 'initially_deferred AS \"initiallyDeferred\"', \"from INFORMATION_SCHEMA.table_constraints\", `WHERE table_name='${tableName}';`].join(\" \");\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes, options) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n\n    return [\"DROP INDEX\", options && options.concurrently && \"CONCURRENTLY\", `IF EXISTS ${this.quoteIdentifiers(indexName)}`].filter(Boolean).join(\" \");\n  }\n\n  addLimitAndOffset(options) {\n    let fragment = \"\";\n\n    if (options.limit != null) {\n      fragment += \" LIMIT \" + this.escape(options.limit);\n    }\n\n    if (options.offset != null) {\n      fragment += \" OFFSET \" + this.escape(options.offset);\n    }\n\n    return fragment;\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    let type;\n\n    if (attribute.type instanceof DataTypes.ENUM || attribute.type instanceof DataTypes.ARRAY && attribute.type.type instanceof DataTypes.ENUM) {\n      const enumType = attribute.type.type || attribute.type;\n      let values = attribute.values;\n\n      if (enumType.values && !attribute.values) {\n        values = enumType.values;\n      }\n\n      if (Array.isArray(values) && values.length > 0) {\n        type = `ENUM(${values.map(value => this.escape(value)).join(\", \")})`;\n\n        if (attribute.type instanceof DataTypes.ARRAY) {\n          type += \"[]\";\n        }\n      } else {\n        throw new Error(\"Values for ENUM haven't been defined.\");\n      }\n    }\n\n    if (!type) {\n      type = attribute.type;\n    }\n\n    let sql = type.toString();\n\n    if (Object.prototype.hasOwnProperty.call(attribute, \"allowNull\") && !attribute.allowNull) {\n      sql += \" NOT NULL\";\n    }\n\n    if (attribute.autoIncrement) {\n      if (attribute.autoIncrementIdentity) {\n        sql += \" GENERATED BY DEFAULT AS IDENTITY\";\n      } else {\n        sql += \" SERIAL\";\n      }\n    }\n\n    if (Utils.defaultValueSchemable(attribute.defaultValue)) {\n      sql += ` DEFAULT ${this.escape(attribute.defaultValue, attribute)}`;\n    }\n\n    if (attribute.unique === true) {\n      sql += \" UNIQUE\";\n    }\n\n    if (attribute.primaryKey) {\n      sql += \" PRIMARY KEY\";\n    }\n\n    if (attribute.references) {\n      let referencesTable = this.quoteTable(attribute.references.model);\n      let schema;\n\n      if (options.schema) {\n        schema = options.schema;\n      } else if ((!attribute.references.model || typeof attribute.references.model == \"string\") && options.table && options.table.schema) {\n        schema = options.table.schema;\n      }\n\n      if (schema) {\n        referencesTable = this.quoteTable(this.addSchema({\n          tableName: referencesTable,\n          _schema: schema\n        }));\n      }\n\n      let referencesKey;\n\n      if (!options.withoutForeignKeyConstraints) {\n        if (attribute.references.key) {\n          referencesKey = this.quoteIdentifiers(attribute.references.key);\n        } else {\n          referencesKey = this.quoteIdentifier(\"id\");\n        }\n\n        sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n\n        if (attribute.onDelete) {\n          sql += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n        }\n\n        if (attribute.onUpdate) {\n          sql += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n        }\n\n        if (attribute.references.deferrable) {\n          sql += ` ${attribute.references.deferrable.toString(this)}`;\n        }\n      }\n    }\n\n    if (attribute.comment && typeof attribute.comment === \"string\") {\n      if (options && [\"addColumn\", \"changeColumn\"].includes(options.context)) {\n        const quotedAttr = this.quoteIdentifier(options.key);\n        const escapedCommentText = this.escape(attribute.comment);\n        sql += `; COMMENT ON COLUMN ${this.quoteTable(options.table)}.${quotedAttr} IS ${escapedCommentText}`;\n      } else {\n        sql += ` COMMENT ${attribute.comment}`;\n      }\n    }\n\n    return sql;\n  }\n\n  deferConstraintsQuery(options) {\n    return options.deferrable.toString(this);\n  }\n\n  setConstraintQuery(columns, type) {\n    let columnFragment = \"ALL\";\n\n    if (columns) {\n      columnFragment = columns.map(column => this.quoteIdentifier(column)).join(\", \");\n    }\n\n    return `SET CONSTRAINTS ${columnFragment} ${type}`;\n  }\n\n  setDeferredQuery(columns) {\n    return this.setConstraintQuery(columns, \"DEFERRED\");\n  }\n\n  setImmediateQuery(columns) {\n    return this.setConstraintQuery(columns, \"IMMEDIATE\");\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, __spreadValues({\n        key\n      }, options));\n    }\n\n    return result;\n  }\n\n  createTrigger(tableName, triggerName, eventType, fireOnSpec, functionName, functionParams, optionsArray) {\n    const decodedEventType = this.decodeTriggerEventType(eventType);\n    const eventSpec = this.expandTriggerEventSpec(fireOnSpec);\n    const expandedOptions = this.expandOptions(optionsArray);\n\n    const paramList = this._expandFunctionParamList(functionParams);\n\n    return `CREATE ${this.triggerEventTypeIsConstraint(eventType)}TRIGGER ${this.quoteIdentifier(triggerName)} ${decodedEventType} ${eventSpec} ON ${this.quoteTable(tableName)}${expandedOptions ? ` ${expandedOptions}` : \"\"} EXECUTE PROCEDURE ${functionName}(${paramList});`;\n  }\n\n  dropTrigger(tableName, triggerName) {\n    return `DROP TRIGGER ${this.quoteIdentifier(triggerName)} ON ${this.quoteTable(tableName)} RESTRICT;`;\n  }\n\n  renameTrigger(tableName, oldTriggerName, newTriggerName) {\n    return `ALTER TRIGGER ${this.quoteIdentifier(oldTriggerName)} ON ${this.quoteTable(tableName)} RENAME TO ${this.quoteIdentifier(newTriggerName)};`;\n  }\n\n  createFunction(functionName, params, returnType, language, body, optionsArray, options) {\n    if (!functionName || !returnType || !language || !body) throw new Error(\"createFunction missing some parameters. Did you pass functionName, returnType, language and body?\");\n\n    const paramList = this._expandFunctionParamList(params);\n\n    const variableList = options && options.variables ? this._expandFunctionVariableList(options.variables) : \"\";\n    const expandedOptionsArray = this.expandOptions(optionsArray);\n    const statement = options && options.force ? \"CREATE OR REPLACE FUNCTION\" : \"CREATE FUNCTION\";\n    return `${statement} ${functionName}(${paramList}) RETURNS ${returnType} AS $func$ ${variableList} BEGIN ${body} END; $func$ language '${language}'${expandedOptionsArray};`;\n  }\n\n  dropFunction(functionName, params) {\n    if (!functionName) throw new Error(\"requires functionName\");\n\n    const paramList = this._expandFunctionParamList(params);\n\n    return `DROP FUNCTION ${functionName}(${paramList}) RESTRICT;`;\n  }\n\n  renameFunction(oldFunctionName, params, newFunctionName) {\n    const paramList = this._expandFunctionParamList(params);\n\n    return `ALTER FUNCTION ${oldFunctionName}(${paramList}) RENAME TO ${newFunctionName};`;\n  }\n\n  pgEscapeAndQuote(val) {\n    return this.quoteIdentifier(Utils.removeTicks(this.escape(val), \"'\"));\n  }\n\n  _expandFunctionParamList(params) {\n    if (params === void 0 || !Array.isArray(params)) {\n      throw new Error(\"_expandFunctionParamList: function parameters array required, including an empty one for no arguments\");\n    }\n\n    const paramList = [];\n    params.forEach(curParam => {\n      const paramDef = [];\n\n      if (curParam.type) {\n        if (curParam.direction) {\n          paramDef.push(curParam.direction);\n        }\n\n        if (curParam.name) {\n          paramDef.push(curParam.name);\n        }\n\n        paramDef.push(curParam.type);\n      } else {\n        throw new Error(\"function or trigger used with a parameter without any type\");\n      }\n\n      const joined = paramDef.join(\" \");\n      if (joined) paramList.push(joined);\n    });\n    return paramList.join(\", \");\n  }\n\n  _expandFunctionVariableList(variables) {\n    if (!Array.isArray(variables)) {\n      throw new Error(\"_expandFunctionVariableList: function variables must be an array\");\n    }\n\n    const variableDefinitions = [];\n    variables.forEach(variable => {\n      if (!variable.name || !variable.type) {\n        throw new Error(\"function variable must have a name and type\");\n      }\n\n      let variableDefinition = `DECLARE ${variable.name} ${variable.type}`;\n\n      if (variable.default) {\n        variableDefinition += ` := ${variable.default}`;\n      }\n\n      variableDefinition += \";\";\n      variableDefinitions.push(variableDefinition);\n    });\n    return variableDefinitions.join(\" \");\n  }\n\n  expandOptions(options) {\n    return options === void 0 || _.isEmpty(options) ? \"\" : options.join(\" \");\n  }\n\n  decodeTriggerEventType(eventSpecifier) {\n    const EVENT_DECODER = {\n      \"after\": \"AFTER\",\n      \"before\": \"BEFORE\",\n      \"instead_of\": \"INSTEAD OF\",\n      \"after_constraint\": \"AFTER\"\n    };\n\n    if (!EVENT_DECODER[eventSpecifier]) {\n      throw new Error(`Invalid trigger event specified: ${eventSpecifier}`);\n    }\n\n    return EVENT_DECODER[eventSpecifier];\n  }\n\n  triggerEventTypeIsConstraint(eventSpecifier) {\n    return eventSpecifier === \"after_constraint\" ? \"CONSTRAINT \" : \"\";\n  }\n\n  expandTriggerEventSpec(fireOnSpec) {\n    if (_.isEmpty(fireOnSpec)) {\n      throw new Error(\"no table change events specified to trigger on\");\n    }\n\n    return _.map(fireOnSpec, (fireValue, fireKey) => {\n      const EVENT_MAP = {\n        \"insert\": \"INSERT\",\n        \"update\": \"UPDATE\",\n        \"delete\": \"DELETE\",\n        \"truncate\": \"TRUNCATE\"\n      };\n\n      if (!EVENT_MAP[fireValue]) {\n        throw new Error(`parseTriggerEventSpec: undefined trigger event ${fireKey}`);\n      }\n\n      let eventSpec = EVENT_MAP[fireValue];\n\n      if (eventSpec === \"UPDATE\") {\n        if (Array.isArray(fireValue) && fireValue.length > 0) {\n          eventSpec += ` OF ${fireValue.join(\", \")}`;\n        }\n      }\n\n      return eventSpec;\n    }).join(\" OR \");\n  }\n\n  pgEnumName(tableName, attr, options) {\n    options = options || {};\n    const tableDetails = this.extractTableDetails(tableName, options);\n    let enumName = Utils.addTicks(Utils.generateEnumName(tableDetails.tableName, attr), '\"');\n\n    if (options.schema !== false && tableDetails.schema) {\n      enumName = this.quoteIdentifier(tableDetails.schema) + tableDetails.delimiter + enumName;\n    }\n\n    return enumName;\n  }\n\n  pgListEnums(tableName, attrName, options) {\n    let enumName = \"\";\n    const tableDetails = this.extractTableDetails(tableName, options);\n\n    if (tableDetails.tableName && attrName) {\n      enumName = ` AND t.typname=${this.pgEnumName(tableDetails.tableName, attrName, {\n        schema: false\n      }).replace(/\"/g, \"'\")}`;\n    }\n\n    return `SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = '${tableDetails.schema}'${enumName} GROUP BY 1`;\n  }\n\n  pgEnum(tableName, attr, dataType, options) {\n    const enumName = this.pgEnumName(tableName, attr, options);\n    let values;\n\n    if (dataType.values) {\n      values = `ENUM(${dataType.values.map(value => this.escape(value)).join(\", \")})`;\n    } else {\n      values = dataType.toString().match(/^ENUM\\(.+\\)/)[0];\n    }\n\n    let sql = `CREATE TYPE ${enumName} AS ${values};`;\n\n    if (!!options && options.force === true) {\n      sql = this.pgEnumDrop(tableName, attr) + sql;\n    }\n\n    return sql;\n  }\n\n  pgEnumAdd(tableName, attr, value, options) {\n    const enumName = this.pgEnumName(tableName, attr);\n    let sql = `ALTER TYPE ${enumName} ADD VALUE `;\n\n    if (semver.gte(this.sequelize.options.databaseVersion, \"9.3.0\")) {\n      sql += \"IF NOT EXISTS \";\n    }\n\n    sql += this.escape(value);\n\n    if (options.before) {\n      sql += ` BEFORE ${this.escape(options.before)}`;\n    } else if (options.after) {\n      sql += ` AFTER ${this.escape(options.after)}`;\n    }\n\n    return sql;\n  }\n\n  pgEnumDrop(tableName, attr, enumName) {\n    enumName = enumName || this.pgEnumName(tableName, attr);\n    return `DROP TYPE IF EXISTS ${enumName}; `;\n  }\n\n  fromArray(text) {\n    text = text.replace(/^{/, \"\").replace(/}$/, \"\");\n    let matches = text.match(/(\"(?:\\\\.|[^\"\\\\\\\\])*\"|[^,]*)(?:\\s*,\\s*|\\s*$)/ig);\n\n    if (matches.length < 1) {\n      return [];\n    }\n\n    matches = matches.map(m => m.replace(/\",$/, \"\").replace(/,$/, \"\").replace(/(^\"|\"$)/g, \"\"));\n    return matches.slice(0, -1);\n  }\n\n  dataTypeMapping(tableName, attr, dataType) {\n    if (dataType.includes(\"PRIMARY KEY\")) {\n      dataType = dataType.replace(\"PRIMARY KEY\", \"\");\n    }\n\n    if (dataType.includes(\"SERIAL\")) {\n      if (dataType.includes(\"BIGINT\")) {\n        dataType = dataType.replace(\"SERIAL\", \"BIGSERIAL\");\n        dataType = dataType.replace(\"BIGINT\", \"\");\n      } else if (dataType.includes(\"SMALLINT\")) {\n        dataType = dataType.replace(\"SERIAL\", \"SMALLSERIAL\");\n        dataType = dataType.replace(\"SMALLINT\", \"\");\n      } else {\n        dataType = dataType.replace(\"INTEGER\", \"\");\n      }\n\n      dataType = dataType.replace(\"NOT NULL\", \"\");\n    }\n\n    if (dataType.startsWith(\"ENUM(\")) {\n      dataType = dataType.replace(/^ENUM\\(.+\\)/, this.pgEnumName(tableName, attr));\n    }\n\n    return dataType;\n  }\n\n  getForeignKeysQuery(tableName) {\n    return `SELECT conname as constraint_name, pg_catalog.pg_get_constraintdef(r.oid, true) as condef FROM pg_catalog.pg_constraint r WHERE r.conrelid = (SELECT oid FROM pg_class WHERE relname = '${tableName}' LIMIT 1) AND r.contype = 'f' ORDER BY 1;`;\n  }\n\n  _getForeignKeyReferencesQueryPrefix() {\n    return \"SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name \";\n  }\n\n  getForeignKeyReferencesQuery(tableName, catalogName, schemaName) {\n    return `${this._getForeignKeyReferencesQueryPrefix()}WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = '${tableName}'${catalogName ? ` AND tc.table_catalog = '${catalogName}'` : \"\"}${schemaName ? ` AND tc.table_schema = '${schemaName}'` : \"\"}`;\n  }\n\n  getForeignKeyReferenceQuery(table, columnName) {\n    const tableName = table.tableName || table;\n    const schema = table.schema;\n    return `${this._getForeignKeyReferencesQueryPrefix()}WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name='${tableName}' AND  kcu.column_name = '${columnName}'${schema ? ` AND tc.table_schema = '${schema}'` : \"\"}`;\n  }\n\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${this.quoteIdentifier(foreignKey)};`;\n  }\n\n  quoteIdentifier(identifier, force) {\n    const optForceQuote = force || false;\n    const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;\n    const rawIdentifier = Utils.removeTicks(identifier, '\"');\n\n    if (optForceQuote === true || optQuoteIdentifiers !== false || identifier.includes(\".\") || identifier.includes(\"->\") || POSTGRES_RESERVED_WORDS.includes(rawIdentifier.toLowerCase())) {\n      return Utils.addTicks(rawIdentifier, '\"');\n    }\n\n    return rawIdentifier;\n  }\n\n}\n\nmodule.exports = PostgresQueryGenerator;","map":{"version":3,"mappings":"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","names":["Utils","require","util","DataTypes","AbstractQueryGenerator","semver","_","POSTGRES_RESERVED_WORDS","split","setSearchPath","searchPath","createDatabaseQuery","databaseName","options","__spreadValues","encoding","collate","values","database","quoteTable","escape","collation","ctype","template","dropDatabaseQuery","createSchema","schema","databaseVersion","get","gte","dropSchema","showSchemasQuery","versionQuery","createTableQuery","tableName","attributes","attrStr","comments","columnComments","quotedTable","comment","attr","quotedAttr","quoteIdentifier","i","indexOf","escapedCommentText","substring","dataType","dataTypeMapping","push","attributesClause","join","uniqueKeys","each","columns","customIndex","fields","map","field","pks","reduce","acc","attribute","key","includes","length","dropTableQuery","cascade","showTablesQuery","tableExistsQuery","table","describeTableQuery","_checkValidJsonStatement","stmt","jsonFunctionRegex","jsonOperatorRegex","tokenCaptureRegex","currentIndex","openingBrackets","closingBrackets","hasJsonFunction","hasInvalidToken","string","substr","functionMatches","exec","operatorMatches","tokenMatches","capturedToken","Error","handleSequelizeMethod","smth","factory","prepend","Json","conditions","parseConditionObject","condition","jsonPathExtractionQuery","path","tail","value","str","paths","toPath","column","shift","format","call","addColumnQuery","dbDataType","attributeToSQL","context","type","definition","quotedKey","extractTableDetails","query","ENUM","pgEnum","removeColumnQuery","attributeName","quotedTableName","quotedAttributeName","changeColumnQuery","subQuery","sql","attrSql","replace","trim","match","startsWith","pgEnumName","renameColumnQuery","attrBefore","attrString","fn","fnName","parameters","body","returns","language","truncateTableQuery","restartIdentity","deleteQuery","where","model","whereClause","getWhereConditions","limit","primaryKeys","primaryKeysSelection","Object","pk","primaryKeyAttributes","showIndexesQuery","schemaJoin","schemaWhere","showConstraintsQuery","removeIndexQuery","indexNameOrAttributes","indexName","underscore","concurrently","quoteIdentifiers","filter","Boolean","addLimitAndOffset","fragment","offset","isPlainObject","ARRAY","enumType","Array","isArray","toString","prototype","hasOwnProperty","allowNull","autoIncrement","autoIncrementIdentity","defaultValueSchemable","defaultValue","unique","primaryKey","references","referencesTable","addSchema","_schema","referencesKey","withoutForeignKeyConstraints","onDelete","toUpperCase","onUpdate","deferrable","deferConstraintsQuery","setConstraintQuery","columnFragment","setDeferredQuery","setImmediateQuery","attributesToSQL","result","createTrigger","triggerName","eventType","fireOnSpec","functionName","functionParams","optionsArray","decodedEventType","decodeTriggerEventType","eventSpec","expandTriggerEventSpec","expandedOptions","expandOptions","paramList","_expandFunctionParamList","triggerEventTypeIsConstraint","dropTrigger","renameTrigger","oldTriggerName","newTriggerName","createFunction","params","returnType","variableList","variables","_expandFunctionVariableList","expandedOptionsArray","statement","force","dropFunction","renameFunction","oldFunctionName","newFunctionName","pgEscapeAndQuote","val","removeTicks","forEach","curParam","paramDef","direction","name","joined","variableDefinitions","variable","variableDefinition","default","isEmpty","eventSpecifier","EVENT_DECODER","fireValue","fireKey","EVENT_MAP","tableDetails","enumName","addTicks","generateEnumName","delimiter","pgListEnums","attrName","pgEnumDrop","pgEnumAdd","sequelize","before","after","fromArray","text","matches","m","slice","getForeignKeysQuery","_getForeignKeyReferencesQueryPrefix","getForeignKeyReferencesQuery","catalogName","schemaName","getForeignKeyReferenceQuery","columnName","dropForeignKeyQuery","foreignKey","identifier","optForceQuote","optQuoteIdentifiers","rawIdentifier","toLowerCase","module","exports","PostgresQueryGenerator"],"sources":["/Users/aurele/node_modules/sequelize/src/dialects/postgres/query-generator.js"],"sourcesContent":["'use strict';\n\nconst Utils = require('../../utils');\nconst util = require('util');\nconst DataTypes = require('../../data-types');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\nconst semver = require('semver');\nconst _ = require('lodash');\n\n/**\n * list of reserved words in PostgreSQL 10\n * source: https://www.postgresql.org/docs/10/static/sql-keywords-appendix.html\n *\n * @private\n */\nconst POSTGRES_RESERVED_WORDS = 'all,analyse,analyze,and,any,array,as,asc,asymmetric,authorization,binary,both,case,cast,check,collate,collation,column,concurrently,constraint,create,cross,current_catalog,current_date,current_role,current_schema,current_time,current_timestamp,current_user,default,deferrable,desc,distinct,do,else,end,except,false,fetch,for,foreign,freeze,from,full,grant,group,having,ilike,in,initially,inner,intersect,into,is,isnull,join,lateral,leading,left,like,limit,localtime,localtimestamp,natural,not,notnull,null,offset,on,only,or,order,outer,overlaps,placing,primary,references,returning,right,select,session_user,similar,some,symmetric,table,tablesample,then,to,trailing,true,union,unique,user,using,variadic,verbose,when,where,window,with'.split(',');\n\nclass PostgresQueryGenerator extends AbstractQueryGenerator {\n  setSearchPath(searchPath) {\n    return `SET search_path to ${searchPath};`;\n  }\n\n  createDatabaseQuery(databaseName, options) {\n    options = {\n      encoding: null,\n      collate: null,\n      ...options\n    };\n\n    const values = {\n      database: this.quoteTable(databaseName),\n      encoding: options.encoding ? ` ENCODING = ${this.escape(options.encoding)}` : '',\n      collation: options.collate ? ` LC_COLLATE = ${this.escape(options.collate)}` : '',\n      ctype: options.ctype ? ` LC_CTYPE = ${this.escape(options.ctype)}` : '',\n      template: options.template ? ` TEMPLATE = ${this.escape(options.template)}` : ''\n    };\n\n    return `CREATE DATABASE ${values.database}${values.encoding}${values.collation}${values.ctype}${values.template};`;\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteTable(databaseName)};`;\n  }\n\n  createSchema(schema) {\n    const databaseVersion = _.get(this, 'sequelize.options.databaseVersion', 0);\n\n    if (databaseVersion && semver.gte(databaseVersion, '9.2.0')) {\n      return `CREATE SCHEMA IF NOT EXISTS ${schema};`;\n    }\n\n    return `CREATE SCHEMA ${schema};`;\n  }\n\n  dropSchema(schema) {\n    return `DROP SCHEMA IF EXISTS ${schema} CASCADE;`;\n  }\n\n  showSchemasQuery() {\n    return \"SELECT schema_name FROM information_schema.schemata WHERE schema_name <> 'information_schema' AND schema_name != 'public' AND schema_name !~ E'^pg_';\";\n  }\n\n  versionQuery() {\n    return 'SHOW SERVER_VERSION';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = { ...options };\n\n    //Postgres 9.0 does not support CREATE TABLE IF NOT EXISTS, 9.1 and above do\n    const databaseVersion = _.get(this, 'sequelize.options.databaseVersion', 0);\n    const attrStr = [];\n    let comments = '';\n    let columnComments = '';\n\n    const quotedTable = this.quoteTable(tableName);\n\n    if (options.comment && typeof options.comment === 'string') {\n      comments += `; COMMENT ON TABLE ${quotedTable} IS ${this.escape(options.comment)}`;\n    }\n\n    for (const attr in attributes) {\n      const quotedAttr = this.quoteIdentifier(attr);\n      const i = attributes[attr].indexOf('COMMENT ');\n      if (i !== -1) {\n        // Move comment to a separate query\n        const escapedCommentText = this.escape(attributes[attr].substring(i + 8));\n        columnComments += `; COMMENT ON COLUMN ${quotedTable}.${quotedAttr} IS ${escapedCommentText}`;\n        attributes[attr] = attributes[attr].substring(0, i);\n      }\n\n      const dataType = this.dataTypeMapping(tableName, attr, attributes[attr]);\n      attrStr.push(`${quotedAttr} ${dataType}`);\n    }\n\n\n    let attributesClause = attrStr.join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, columns => {\n        if (columns.customIndex) {\n          attributesClause += `, UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    const pks = _.reduce(attributes, (acc, attribute, key) => {\n      if (attribute.includes('PRIMARY KEY')) {\n        acc.push(this.quoteIdentifier(key));\n      }\n      return acc;\n    }, []).join(',');\n\n    if (pks.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pks})`;\n    }\n\n    return `CREATE TABLE ${databaseVersion === 0 || semver.gte(databaseVersion, '9.1.0') ? 'IF NOT EXISTS ' : ''}${quotedTable} (${attributesClause})${comments}${columnComments};`;\n  }\n\n  dropTableQuery(tableName, options) {\n    options = options || {};\n    return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)}${options.cascade ? ' CASCADE' : ''};`;\n  }\n\n  showTablesQuery() {\n    const schema = this.options.schema || 'public';\n\n    return `SELECT table_name FROM information_schema.tables WHERE table_schema = ${this.escape(schema)} AND table_type LIKE '%TABLE' AND table_name != 'spatial_ref_sys';`;\n  }\n\n  tableExistsQuery(tableName) {\n    const table = tableName.tableName || tableName;\n    const schema = tableName.schema || 'public';\n\n    return `SELECT table_name FROM information_schema.tables WHERE table_schema = ${this.escape(schema)} AND table_name = ${this.escape(table)}`;\n  }\n\n  describeTableQuery(tableName, schema) {\n    schema = schema || this.options.schema || 'public';\n\n    return 'SELECT ' +\n      'pk.constraint_type as \"Constraint\",' +\n      'c.column_name as \"Field\", ' +\n      'c.column_default as \"Default\",' +\n      'c.is_nullable as \"Null\", ' +\n      '(CASE WHEN c.udt_name = \\'hstore\\' THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN \\'(\\' || c.character_maximum_length || \\')\\' ELSE \\'\\' END) as \"Type\", ' +\n      '(SELECT array_agg(e.enumlabel) FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid WHERE t.typname=c.udt_name) AS \"special\", ' +\n      '(SELECT pgd.description FROM pg_catalog.pg_statio_all_tables AS st INNER JOIN pg_catalog.pg_description pgd on (pgd.objoid=st.relid) WHERE c.ordinal_position=pgd.objsubid AND c.table_name=st.relname) AS \"Comment\" ' +\n      'FROM information_schema.columns c ' +\n      'LEFT JOIN (SELECT tc.table_schema, tc.table_name, ' +\n      'cu.column_name, tc.constraint_type ' +\n      'FROM information_schema.TABLE_CONSTRAINTS tc ' +\n      'JOIN information_schema.KEY_COLUMN_USAGE  cu ' +\n      'ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name ' +\n      'and tc.constraint_name=cu.constraint_name ' +\n      'and tc.constraint_type=\\'PRIMARY KEY\\') pk ' +\n      'ON pk.table_schema=c.table_schema ' +\n      'AND pk.table_name=c.table_name ' +\n      'AND pk.column_name=c.column_name ' +\n      `WHERE c.table_name = ${this.escape(tableName)} AND c.table_schema = ${this.escape(schema)}`;\n  }\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   */\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    // https://www.postgresql.org/docs/current/static/functions-json.html\n    const jsonFunctionRegex = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const jsonOperatorRegex = /^\\s*(->>?|#>>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = jsonOperatorRegex.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition =>\n          `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`\n        );\n\n        return conditions.join(' AND ');\n      }\n      if (smth.path) {\n        let str;\n\n        // Allow specifying conditions using the postgres json syntax\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json property accessors\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    }\n    return super.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  }\n\n  addColumnQuery(table, key, attribute) {\n    const dbDataType = this.attributeToSQL(attribute, { context: 'addColumn', table, key });\n    const dataType = attribute.type || attribute;\n    const definition = this.dataTypeMapping(table, key, dbDataType);\n    const quotedKey = this.quoteIdentifier(key);\n    const quotedTable = this.quoteTable(this.extractTableDetails(table));\n\n    let query = `ALTER TABLE ${quotedTable} ADD COLUMN ${quotedKey} ${definition};`;\n\n    if (dataType instanceof DataTypes.ENUM) {\n      query = this.pgEnum(table, key, dataType) + query;\n    } else if (dataType.type && dataType.type instanceof DataTypes.ENUM) {\n      query = this.pgEnum(table, key, dataType.type) + query;\n    }\n\n    return query;\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    const quotedTableName = this.quoteTable(this.extractTableDetails(tableName));\n    const quotedAttributeName = this.quoteIdentifier(attributeName);\n    return `ALTER TABLE ${quotedTableName} DROP COLUMN ${quotedAttributeName};`;\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const query = subQuery => `ALTER TABLE ${this.quoteTable(tableName)} ALTER COLUMN ${subQuery};`;\n    const sql = [];\n    for (const attributeName in attributes) {\n      let definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);\n      let attrSql = '';\n\n      if (definition.includes('NOT NULL')) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} SET NOT NULL`);\n\n        definition = definition.replace('NOT NULL', '').trim();\n      } else if (!definition.includes('REFERENCES')) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP NOT NULL`);\n      }\n\n      if (definition.includes('DEFAULT')) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} SET DEFAULT ${definition.match(/DEFAULT ([^;]+)/)[1]}`);\n\n        definition = definition.replace(/(DEFAULT[^;]+)/, '').trim();\n      } else if (!definition.includes('REFERENCES')) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP DEFAULT`);\n      }\n\n      if (attributes[attributeName].startsWith('ENUM(')) {\n        attrSql += this.pgEnum(tableName, attributeName, attributes[attributeName]);\n        definition = definition.replace(/^ENUM\\(.+\\)/, this.pgEnumName(tableName, attributeName, { schema: false }));\n        definition += ` USING (${this.quoteIdentifier(attributeName)}::${this.pgEnumName(tableName, attributeName)})`;\n      }\n\n      if (definition.match(/UNIQUE;*$/)) {\n        definition = definition.replace(/UNIQUE;*$/, '');\n        attrSql += query(`ADD UNIQUE (${this.quoteIdentifier(attributeName)})`).replace('ALTER COLUMN', '');\n      }\n\n      if (definition.includes('REFERENCES')) {\n        definition = definition.replace(/.+?(?=REFERENCES)/, '');\n        attrSql += query(`ADD FOREIGN KEY (${this.quoteIdentifier(attributeName)}) ${definition}`).replace('ALTER COLUMN', '');\n      } else {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} TYPE ${definition}`);\n      }\n\n      sql.push(attrSql);\n    }\n\n    return sql.join('');\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n\n    const attrString = [];\n\n    for (const attributeName in attributes) {\n      attrString.push(`${this.quoteIdentifier(attrBefore)} TO ${this.quoteIdentifier(attributeName)}`);\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${attrString.join(', ')};`;\n  }\n\n  fn(fnName, tableName, parameters, body, returns, language) {\n    fnName = fnName || 'testfunc';\n    language = language || 'plpgsql';\n    returns = returns ? `RETURNS ${returns}` : '';\n    parameters = parameters || '';\n\n    return `CREATE OR REPLACE FUNCTION pg_temp.${fnName}(${parameters}) ${returns} AS $func$ BEGIN ${body} END; $func$ LANGUAGE ${language}; SELECT * FROM pg_temp.${fnName}();`;\n  }\n\n  truncateTableQuery(tableName, options = {}) {\n    return [\n      `TRUNCATE ${this.quoteTable(tableName)}`,\n      options.restartIdentity ? ' RESTART IDENTITY' : '',\n      options.cascade ? ' CASCADE' : ''\n    ].join('');\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    let whereClause = this.getWhereConditions(where, null, model, options);\n    const limit = options.limit ? ` LIMIT ${this.escape(options.limit)}` : '';\n    let primaryKeys = '';\n    let primaryKeysSelection = '';\n\n    if (whereClause) {\n      whereClause = ` WHERE ${whereClause}`;\n    }\n\n    if (options.limit) {\n      if (!model) {\n        throw new Error('Cannot LIMIT delete without a model.');\n      }\n\n      const pks = Object.values(model.primaryKeys).map(pk => this.quoteIdentifier(pk.field)).join(',');\n\n      primaryKeys = model.primaryKeyAttributes.length > 1 ? `(${pks})` : pks;\n      primaryKeysSelection = pks;\n\n      return `DELETE FROM ${table} WHERE ${primaryKeys} IN (SELECT ${primaryKeysSelection} FROM ${table}${whereClause}${limit})`;\n    }\n    return `DELETE FROM ${table}${whereClause}`;\n  }\n\n  showIndexesQuery(tableName) {\n    let schemaJoin = '';\n    let schemaWhere = '';\n    if (typeof tableName !== 'string') {\n      schemaJoin = ', pg_namespace s';\n      schemaWhere = ` AND s.oid = t.relnamespace AND s.nspname = '${tableName.schema}'`;\n      tableName = tableName.tableName;\n    }\n\n    // This is ARCANE!\n    return 'SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, ' +\n      'array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) ' +\n      `AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a${schemaJoin} ` +\n      'WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND ' +\n      `t.relkind = 'r' and t.relname = '${tableName}'${schemaWhere} ` +\n      'GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;';\n  }\n\n  showConstraintsQuery(tableName) {\n    //Postgres converts camelCased alias to lowercase unless quoted\n    return [\n      'SELECT constraint_catalog AS \"constraintCatalog\",',\n      'constraint_schema AS \"constraintSchema\",',\n      'constraint_name AS \"constraintName\",',\n      'table_catalog AS \"tableCatalog\",',\n      'table_schema AS \"tableSchema\",',\n      'table_name AS \"tableName\",',\n      'constraint_type AS \"constraintType\",',\n      'is_deferrable AS \"isDeferrable\",',\n      'initially_deferred AS \"initiallyDeferred\"',\n      'from INFORMATION_SCHEMA.table_constraints',\n      `WHERE table_name='${tableName}';`\n    ].join(' ');\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes, options) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return [\n      'DROP INDEX',\n      options && options.concurrently && 'CONCURRENTLY',\n      `IF EXISTS ${this.quoteIdentifiers(indexName)}`\n    ].filter(Boolean).join(' ');\n  }\n\n  addLimitAndOffset(options) {\n    let fragment = '';\n    /* eslint-disable */\n    if (options.limit != null) {\n      fragment += ' LIMIT ' + this.escape(options.limit);\n    }\n    if (options.offset != null) {\n      fragment += ' OFFSET ' + this.escape(options.offset);\n    }\n    /* eslint-enable */\n\n    return fragment;\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    let type;\n    if (\n      attribute.type instanceof DataTypes.ENUM ||\n      attribute.type instanceof DataTypes.ARRAY && attribute.type.type instanceof DataTypes.ENUM\n    ) {\n      const enumType = attribute.type.type || attribute.type;\n      let values = attribute.values;\n\n      if (enumType.values && !attribute.values) {\n        values = enumType.values;\n      }\n\n      if (Array.isArray(values) && values.length > 0) {\n        type = `ENUM(${values.map(value => this.escape(value)).join(', ')})`;\n\n        if (attribute.type instanceof DataTypes.ARRAY) {\n          type += '[]';\n        }\n\n      } else {\n        throw new Error(\"Values for ENUM haven't been defined.\");\n      }\n    }\n\n    if (!type) {\n      type = attribute.type;\n    }\n\n    let sql = type.toString();\n\n    if (Object.prototype.hasOwnProperty.call(attribute, 'allowNull') && !attribute.allowNull) {\n      sql += ' NOT NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      if (attribute.autoIncrementIdentity) {\n        sql += ' GENERATED BY DEFAULT AS IDENTITY';\n      } else {\n        sql += ' SERIAL';\n      }\n    }\n\n    if (Utils.defaultValueSchemable(attribute.defaultValue)) {\n      sql += ` DEFAULT ${this.escape(attribute.defaultValue, attribute)}`;\n    }\n\n    if (attribute.unique === true) {\n      sql += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      sql += ' PRIMARY KEY';\n    }\n\n    if (attribute.references) {\n      let referencesTable = this.quoteTable(attribute.references.model);\n      let schema;\n\n      if (options.schema) {\n        schema = options.schema;\n      } else if (\n        (!attribute.references.model || typeof attribute.references.model == 'string')\n        && options.table\n        && options.table.schema\n      ) {\n        schema = options.table.schema;\n      }\n\n      if (schema) {\n        referencesTable = this.quoteTable(this.addSchema({\n          tableName: referencesTable,\n          _schema: schema\n        }));\n      }\n\n      let referencesKey;\n\n      if (!options.withoutForeignKeyConstraints) {\n        if (attribute.references.key) {\n          referencesKey = this.quoteIdentifiers(attribute.references.key);\n        } else {\n          referencesKey = this.quoteIdentifier('id');\n        }\n\n        sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n\n        if (attribute.onDelete) {\n          sql += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n        }\n\n        if (attribute.onUpdate) {\n          sql += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n        }\n\n        if (attribute.references.deferrable) {\n          sql += ` ${attribute.references.deferrable.toString(this)}`;\n        }\n      }\n    }\n\n    if (attribute.comment && typeof attribute.comment === 'string') {\n      if (options && ['addColumn', 'changeColumn'].includes(options.context)) {\n        const quotedAttr = this.quoteIdentifier(options.key);\n        const escapedCommentText = this.escape(attribute.comment);\n        sql += `; COMMENT ON COLUMN ${this.quoteTable(options.table)}.${quotedAttr} IS ${escapedCommentText}`;\n      } else {\n        // for createTable event which does it's own parsing\n        // TODO: centralize creation of comment statements here\n        sql += ` COMMENT ${attribute.comment}`;\n      }\n    }\n\n    return sql;\n  }\n\n  deferConstraintsQuery(options) {\n    return options.deferrable.toString(this);\n  }\n\n  setConstraintQuery(columns, type) {\n    let columnFragment = 'ALL';\n\n    if (columns) {\n      columnFragment = columns.map(column => this.quoteIdentifier(column)).join(', ');\n    }\n\n    return `SET CONSTRAINTS ${columnFragment} ${type}`;\n  }\n\n  setDeferredQuery(columns) {\n    return this.setConstraintQuery(columns, 'DEFERRED');\n  }\n\n  setImmediateQuery(columns) {\n    return this.setConstraintQuery(columns, 'IMMEDIATE');\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, { key, ...options });\n    }\n\n    return result;\n  }\n\n  createTrigger(tableName, triggerName, eventType, fireOnSpec, functionName, functionParams, optionsArray) {\n    const decodedEventType = this.decodeTriggerEventType(eventType);\n    const eventSpec = this.expandTriggerEventSpec(fireOnSpec);\n    const expandedOptions = this.expandOptions(optionsArray);\n    const paramList = this._expandFunctionParamList(functionParams);\n\n    return `CREATE ${this.triggerEventTypeIsConstraint(eventType)}TRIGGER ${this.quoteIdentifier(triggerName)} ${decodedEventType} ${\n      eventSpec} ON ${this.quoteTable(tableName)}${expandedOptions ? ` ${expandedOptions}` : ''} EXECUTE PROCEDURE ${functionName}(${paramList});`;\n  }\n\n  dropTrigger(tableName, triggerName) {\n    return `DROP TRIGGER ${this.quoteIdentifier(triggerName)} ON ${this.quoteTable(tableName)} RESTRICT;`;\n  }\n\n  renameTrigger(tableName, oldTriggerName, newTriggerName) {\n    return `ALTER TRIGGER ${this.quoteIdentifier(oldTriggerName)} ON ${this.quoteTable(tableName)} RENAME TO ${this.quoteIdentifier(newTriggerName)};`;\n  }\n\n  createFunction(functionName, params, returnType, language, body, optionsArray, options) {\n    if (!functionName || !returnType || !language || !body) throw new Error('createFunction missing some parameters. Did you pass functionName, returnType, language and body?');\n\n    const paramList = this._expandFunctionParamList(params);\n    const variableList = options && options.variables ? this._expandFunctionVariableList(options.variables) : '';\n    const expandedOptionsArray = this.expandOptions(optionsArray);\n\n    const statement = options && options.force ? 'CREATE OR REPLACE FUNCTION' : 'CREATE FUNCTION';\n\n    return `${statement} ${functionName}(${paramList}) RETURNS ${returnType} AS $func$ ${variableList} BEGIN ${body} END; $func$ language '${language}'${expandedOptionsArray};`;\n  }\n\n  dropFunction(functionName, params) {\n    if (!functionName) throw new Error('requires functionName');\n    // RESTRICT is (currently, as of 9.2) default but we'll be explicit\n    const paramList = this._expandFunctionParamList(params);\n    return `DROP FUNCTION ${functionName}(${paramList}) RESTRICT;`;\n  }\n\n  renameFunction(oldFunctionName, params, newFunctionName) {\n    const paramList = this._expandFunctionParamList(params);\n    return `ALTER FUNCTION ${oldFunctionName}(${paramList}) RENAME TO ${newFunctionName};`;\n  }\n\n  pgEscapeAndQuote(val) {\n    return this.quoteIdentifier(Utils.removeTicks(this.escape(val), \"'\"));\n  }\n\n  _expandFunctionParamList(params) {\n    if (params === undefined || !Array.isArray(params)) {\n      throw new Error('_expandFunctionParamList: function parameters array required, including an empty one for no arguments');\n    }\n\n    const paramList = [];\n    params.forEach(curParam => {\n      const paramDef = [];\n      if (curParam.type) {\n        if (curParam.direction) { paramDef.push(curParam.direction); }\n        if (curParam.name) { paramDef.push(curParam.name); }\n        paramDef.push(curParam.type);\n      } else {\n        throw new Error('function or trigger used with a parameter without any type');\n      }\n\n      const joined = paramDef.join(' ');\n      if (joined) paramList.push(joined);\n\n    });\n\n    return paramList.join(', ');\n  }\n\n  _expandFunctionVariableList(variables) {\n    if (!Array.isArray(variables)) {\n      throw new Error('_expandFunctionVariableList: function variables must be an array');\n    }\n    const variableDefinitions = [];\n    variables.forEach(variable => {\n      if (!variable.name || !variable.type) {\n        throw new Error('function variable must have a name and type');\n      }\n      let variableDefinition = `DECLARE ${variable.name} ${variable.type}`;\n      if (variable.default) {\n        variableDefinition += ` := ${variable.default}`;\n      }\n      variableDefinition += ';';\n      variableDefinitions.push(variableDefinition);\n    });\n    return variableDefinitions.join(' ');\n  }\n\n  expandOptions(options) {\n    return options === undefined || _.isEmpty(options) ?\n      '' : options.join(' ');\n  }\n\n  decodeTriggerEventType(eventSpecifier) {\n    const EVENT_DECODER = {\n      'after': 'AFTER',\n      'before': 'BEFORE',\n      'instead_of': 'INSTEAD OF',\n      'after_constraint': 'AFTER'\n    };\n\n    if (!EVENT_DECODER[eventSpecifier]) {\n      throw new Error(`Invalid trigger event specified: ${eventSpecifier}`);\n    }\n\n    return EVENT_DECODER[eventSpecifier];\n  }\n\n  triggerEventTypeIsConstraint(eventSpecifier) {\n    return eventSpecifier === 'after_constraint' ? 'CONSTRAINT ' : '';\n  }\n\n  expandTriggerEventSpec(fireOnSpec) {\n    if (_.isEmpty(fireOnSpec)) {\n      throw new Error('no table change events specified to trigger on');\n    }\n\n    return _.map(fireOnSpec, (fireValue, fireKey) => {\n      const EVENT_MAP = {\n        'insert': 'INSERT',\n        'update': 'UPDATE',\n        'delete': 'DELETE',\n        'truncate': 'TRUNCATE'\n      };\n\n      if (!EVENT_MAP[fireValue]) {\n        throw new Error(`parseTriggerEventSpec: undefined trigger event ${fireKey}`);\n      }\n\n      let eventSpec = EVENT_MAP[fireValue];\n      if (eventSpec === 'UPDATE') {\n        if (Array.isArray(fireValue) && fireValue.length > 0) {\n          eventSpec += ` OF ${fireValue.join(', ')}`;\n        }\n      }\n\n      return eventSpec;\n    }).join(' OR ');\n  }\n\n  pgEnumName(tableName, attr, options) {\n    options = options || {};\n\n    const tableDetails = this.extractTableDetails(tableName, options);\n    let enumName = Utils.addTicks(Utils.generateEnumName(tableDetails.tableName, attr), '\"');\n\n    // pgListEnums requires the enum name only, without the schema\n    if (options.schema !== false && tableDetails.schema) {\n      enumName = this.quoteIdentifier(tableDetails.schema) + tableDetails.delimiter + enumName;\n    }\n\n    return enumName;\n  }\n\n  pgListEnums(tableName, attrName, options) {\n    let enumName = '';\n    const tableDetails = this.extractTableDetails(tableName, options);\n\n    if (tableDetails.tableName && attrName) {\n      enumName = ` AND t.typname=${this.pgEnumName(tableDetails.tableName, attrName, { schema: false }).replace(/\"/g, \"'\")}`;\n    }\n\n    return 'SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t ' +\n      'JOIN pg_enum e ON t.oid = e.enumtypid ' +\n      'JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace ' +\n      `WHERE n.nspname = '${tableDetails.schema}'${enumName} GROUP BY 1`;\n  }\n\n  pgEnum(tableName, attr, dataType, options) {\n    const enumName = this.pgEnumName(tableName, attr, options);\n    let values;\n\n    if (dataType.values) {\n      values = `ENUM(${dataType.values.map(value => this.escape(value)).join(', ')})`;\n    } else {\n      values = dataType.toString().match(/^ENUM\\(.+\\)/)[0];\n    }\n\n    let sql = `CREATE TYPE ${enumName} AS ${values};`;\n    if (!!options && options.force === true) {\n      sql = this.pgEnumDrop(tableName, attr) + sql;\n    }\n    return sql;\n  }\n\n  pgEnumAdd(tableName, attr, value, options) {\n    const enumName = this.pgEnumName(tableName, attr);\n    let sql = `ALTER TYPE ${enumName} ADD VALUE `;\n\n    if (semver.gte(this.sequelize.options.databaseVersion, '9.3.0')) {\n      sql += 'IF NOT EXISTS ';\n    }\n    sql += this.escape(value);\n\n    if (options.before) {\n      sql += ` BEFORE ${this.escape(options.before)}`;\n    } else if (options.after) {\n      sql += ` AFTER ${this.escape(options.after)}`;\n    }\n\n    return sql;\n  }\n\n  pgEnumDrop(tableName, attr, enumName) {\n    enumName = enumName || this.pgEnumName(tableName, attr);\n    return `DROP TYPE IF EXISTS ${enumName}; `;\n  }\n\n  fromArray(text) {\n    text = text.replace(/^{/, '').replace(/}$/, '');\n    let matches = text.match(/(\"(?:\\\\.|[^\"\\\\\\\\])*\"|[^,]*)(?:\\s*,\\s*|\\s*$)/ig);\n\n    if (matches.length < 1) {\n      return [];\n    }\n\n    matches = matches.map(m => m.replace(/\",$/, '').replace(/,$/, '').replace(/(^\"|\"$)/g, ''));\n\n    return matches.slice(0, -1);\n  }\n\n  dataTypeMapping(tableName, attr, dataType) {\n    if (dataType.includes('PRIMARY KEY')) {\n      dataType = dataType.replace('PRIMARY KEY', '');\n    }\n\n    if (dataType.includes('SERIAL')) {\n      if (dataType.includes('BIGINT')) {\n        dataType = dataType.replace('SERIAL', 'BIGSERIAL');\n        dataType = dataType.replace('BIGINT', '');\n      } else if (dataType.includes('SMALLINT')) {\n        dataType = dataType.replace('SERIAL', 'SMALLSERIAL');\n        dataType = dataType.replace('SMALLINT', '');\n      } else {\n        dataType = dataType.replace('INTEGER', '');\n      }\n      dataType = dataType.replace('NOT NULL', '');\n    }\n\n    if (dataType.startsWith('ENUM(')) {\n      dataType = dataType.replace(/^ENUM\\(.+\\)/, this.pgEnumName(tableName, attr));\n    }\n\n    return dataType;\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(tableName) {\n    return 'SELECT conname as constraint_name, pg_catalog.pg_get_constraintdef(r.oid, true) as condef FROM pg_catalog.pg_constraint r ' +\n      `WHERE r.conrelid = (SELECT oid FROM pg_class WHERE relname = '${tableName}' LIMIT 1) AND r.contype = 'f' ORDER BY 1;`;\n  }\n\n  /**\n   * Generate common SQL prefix for getForeignKeyReferencesQuery.\n   *\n   * @returns {string}\n   */\n  _getForeignKeyReferencesQueryPrefix() {\n    return 'SELECT ' +\n      'DISTINCT tc.constraint_name as constraint_name, ' +\n      'tc.constraint_schema as constraint_schema, ' +\n      'tc.constraint_catalog as constraint_catalog, ' +\n      'tc.table_name as table_name,' +\n      'tc.table_schema as table_schema,' +\n      'tc.table_catalog as table_catalog,' +\n      'tc.initially_deferred as initially_deferred,' +\n      'tc.is_deferrable as is_deferrable,' +\n      'kcu.column_name as column_name,' +\n      'ccu.table_schema  AS referenced_table_schema,' +\n      'ccu.table_catalog  AS referenced_table_catalog,' +\n      'ccu.table_name  AS referenced_table_name,' +\n      'ccu.column_name AS referenced_column_name ' +\n      'FROM information_schema.table_constraints AS tc ' +\n      'JOIN information_schema.key_column_usage AS kcu ' +\n      'ON tc.constraint_name = kcu.constraint_name ' +\n      'JOIN information_schema.constraint_column_usage AS ccu ' +\n      'ON ccu.constraint_name = tc.constraint_name ';\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys details of a table.\n   *\n   * As for getForeignKeysQuery is not compatible with getForeignKeyReferencesQuery, so add a new function.\n   *\n   * @param {string} tableName\n   * @param {string} catalogName\n   * @param {string} schemaName\n   */\n  getForeignKeyReferencesQuery(tableName, catalogName, schemaName) {\n    return `${this._getForeignKeyReferencesQueryPrefix()\n    }WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = '${tableName}'${\n      catalogName ? ` AND tc.table_catalog = '${catalogName}'` : ''\n    }${schemaName ? ` AND tc.table_schema = '${schemaName}'` : ''}`;\n  }\n\n  getForeignKeyReferenceQuery(table, columnName) {\n    const tableName = table.tableName || table;\n    const schema = table.schema;\n    return `${this._getForeignKeyReferencesQueryPrefix()\n    }WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name='${tableName}' AND  kcu.column_name = '${columnName}'${\n      schema ? ` AND tc.table_schema = '${schema}'` : ''}`;\n  }\n\n  /**\n   * Generates an SQL query that removes a foreign key from a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @param  {string} foreignKey The name of the foreign key constraint.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${this.quoteIdentifier(foreignKey)};`;\n  }\n\n  /**\n   * Quote identifier in sql clause\n   *\n   * @param {string} identifier\n   * @param {boolean} force\n   *\n   * @returns {string}\n   */\n  quoteIdentifier(identifier, force) {\n    const optForceQuote = force || false;\n    const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;\n    const rawIdentifier = Utils.removeTicks(identifier, '\"');\n\n    if (\n      optForceQuote === true ||\n      optQuoteIdentifiers !== false ||\n      identifier.includes('.') ||\n      identifier.includes('->') ||\n      POSTGRES_RESERVED_WORDS.includes(rawIdentifier.toLowerCase())\n    ) {\n      // In Postgres if tables or attributes are created double-quoted,\n      // they are also case sensitive. If they contain any uppercase\n      // characters, they must always be double-quoted. This makes it\n      // impossible to write queries in portable SQL if tables are created in\n      // this way. Hence, we strip quotes if we don't want case sensitivity.\n      return Utils.addTicks(rawIdentifier, '\"');\n    }\n    return rawIdentifier;\n  }\n}\n\nmodule.exports = PostgresQueryGenerator;\n"]},"metadata":{},"sourceType":"script"}