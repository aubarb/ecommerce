{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nconst Utils = require(\"../../utils\");\n\nconst Transaction = require(\"../../transaction\");\n\nconst _ = require(\"lodash\");\n\nconst MySqlQueryGenerator = require(\"../mysql/query-generator\");\n\nconst AbstractQueryGenerator = require(\"../abstract/query-generator\");\n\nclass SQLiteQueryGenerator extends MySqlQueryGenerator {\n  createSchema() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n\n  showSchemasQuery() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n\n  versionQuery() {\n    return \"SELECT sqlite_version() as `version`\";\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = options || {};\n    const primaryKeys = [];\n    const needsMultiplePrimaryKeys = Object.values(attributes).filter(definition => definition.includes(\"PRIMARY KEY\")).length > 1;\n    const attrArray = [];\n\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        const dataType = attributes[attr];\n        const containsAutoIncrement = dataType.includes(\"AUTOINCREMENT\");\n        let dataTypeString = dataType;\n\n        if (dataType.includes(\"PRIMARY KEY\")) {\n          if (dataType.includes(\"INT\")) {\n            dataTypeString = containsAutoIncrement ? \"INTEGER PRIMARY KEY AUTOINCREMENT\" : \"INTEGER PRIMARY KEY\";\n\n            if (dataType.includes(\" REFERENCES\")) {\n              dataTypeString += dataType.substr(dataType.indexOf(\" REFERENCES\"));\n            }\n          }\n\n          if (needsMultiplePrimaryKeys) {\n            primaryKeys.push(attr);\n\n            if (dataType.includes(\"NOT NULL\")) {\n              dataTypeString = dataType.replace(\" PRIMARY KEY\", \"\");\n            } else {\n              dataTypeString = dataType.replace(\"PRIMARY KEY\", \"NOT NULL\");\n            }\n          }\n        }\n\n        attrArray.push(`${this.quoteIdentifier(attr)} ${dataTypeString}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attrStr = attrArray.join(\", \");\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(\", \");\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, columns => {\n        if (columns.customIndex) {\n          attrStr += `, UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(\", \")})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attrStr += `, PRIMARY KEY (${pkString})`;\n    }\n\n    const sql = `CREATE TABLE IF NOT EXISTS ${table} (${attrStr});`;\n    return this.replaceBooleanDefaults(sql);\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== \"string\") {\n      return false;\n    }\n\n    const jsonFunctionRegex = /^\\s*(json(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf(\"(\");\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n\n        if (capturedToken === \"(\") {\n          openingBrackets++;\n        } else if (capturedToken === \")\") {\n          closingBrackets++;\n        } else if (capturedToken === \";\") {\n          hasInvalidToken = true;\n          break;\n        }\n\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    return hasJsonFunction;\n  }\n\n  _toJSONValue(value) {\n    if (value instanceof Date) {\n      return value.toISOString();\n    }\n\n    if (Array.isArray(value) && value[0] instanceof Date) {\n      return value.map(val => val.toISOString());\n    }\n\n    return value;\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n    }\n\n    if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = \"datetime\";\n      }\n    }\n\n    return AbstractQueryGenerator.prototype.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  }\n\n  addColumnQuery(table, key, dataType) {\n    const attributes = {};\n    attributes[key] = dataType;\n    const fields = this.attributesToSQL(attributes, {\n      context: \"addColumn\"\n    });\n    const attribute = `${this.quoteIdentifier(key)} ${fields[key]}`;\n    const sql = `ALTER TABLE ${this.quoteTable(table)} ADD ${attribute};`;\n    return this.replaceBooleanDefaults(sql);\n  }\n\n  showTablesQuery() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n\n    _.defaults(options, this.options);\n\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n    const modelAttributeMap = {};\n    const values = [];\n    const bind = [];\n    const bindParam = options.bindParam || this.bindParam(bind);\n\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || void 0, {\n          context: \"UPDATE\"\n        })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || void 0, {\n          context: \"UPDATE\"\n        }, bindParam)}`);\n      }\n    }\n\n    let query;\n\n    const whereOptions = __spreadProps(__spreadValues({}, options), {\n      bindParam\n    });\n\n    if (options.limit) {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(\",\")} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} LIMIT ${this.escape(options.limit)})`;\n    } else {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(\",\")} ${this.whereQuery(where, whereOptions)}`;\n    }\n\n    return {\n      query,\n      bind\n    };\n  }\n\n  truncateTableQuery(tableName) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return [`DELETE FROM ${this.quoteTable(tableName)}`, options.restartIdentity ? `; DELETE FROM ${this.quoteTable(\"sqlite_sequence\")} WHERE ${this.quoteIdentifier(\"name\")} = ${Utils.addTicks(Utils.removeTicks(this.quoteTable(tableName), \"`\"), \"'\")};` : \"\"].join(\"\");\n  }\n\n  deleteQuery(tableName, where) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let model = arguments.length > 3 ? arguments[3] : undefined;\n\n    _.defaults(options, this.options);\n\n    let whereClause = this.getWhereConditions(where, null, model, options);\n\n    if (whereClause) {\n      whereClause = `WHERE ${whereClause}`;\n    }\n\n    if (options.limit) {\n      whereClause = `WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${whereClause} LIMIT ${this.escape(options.limit)})`;\n    }\n\n    return `DELETE FROM ${this.quoteTable(tableName)} ${whereClause}`;\n  }\n\n  attributesToSQL(attributes) {\n    const result = {};\n\n    for (const name in attributes) {\n      const dataType = attributes[name];\n      const fieldName = dataType.field || name;\n\n      if (_.isObject(dataType)) {\n        let sql = dataType.type.toString();\n\n        if (Object.prototype.hasOwnProperty.call(dataType, \"allowNull\") && !dataType.allowNull) {\n          sql += \" NOT NULL\";\n        }\n\n        if (Utils.defaultValueSchemable(dataType.defaultValue)) {\n          sql += ` DEFAULT ${this.escape(dataType.defaultValue, dataType)}`;\n        }\n\n        if (dataType.unique === true) {\n          sql += \" UNIQUE\";\n        }\n\n        if (dataType.primaryKey) {\n          sql += \" PRIMARY KEY\";\n\n          if (dataType.autoIncrement) {\n            sql += \" AUTOINCREMENT\";\n          }\n        }\n\n        if (dataType.references) {\n          const referencesTable = this.quoteTable(dataType.references.model);\n          let referencesKey;\n\n          if (dataType.references.key) {\n            referencesKey = this.quoteIdentifier(dataType.references.key);\n          } else {\n            referencesKey = this.quoteIdentifier(\"id\");\n          }\n\n          sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n\n          if (dataType.onDelete) {\n            sql += ` ON DELETE ${dataType.onDelete.toUpperCase()}`;\n          }\n\n          if (dataType.onUpdate) {\n            sql += ` ON UPDATE ${dataType.onUpdate.toUpperCase()}`;\n          }\n        }\n\n        result[fieldName] = sql;\n      } else {\n        result[fieldName] = dataType;\n      }\n    }\n\n    return result;\n  }\n\n  showIndexesQuery(tableName) {\n    return `PRAGMA INDEX_LIST(${this.quoteTable(tableName)})`;\n  }\n\n  showConstraintsQuery(tableName, constraintName) {\n    let sql = `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}'`;\n\n    if (constraintName) {\n      sql += ` AND sql LIKE '%${constraintName}%'`;\n    }\n\n    return `${sql};`;\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n\n    return `DROP INDEX IF EXISTS ${this.quoteIdentifier(indexName)}`;\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = {\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter,\n      tableName\n    };\n    return `PRAGMA TABLE_INFO(${this.quoteTable(this.addSchema(table))});`;\n  }\n\n  describeCreateTableQuery(tableName) {\n    return `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}';`;\n  }\n\n  removeColumnQuery(tableName, attributes) {\n    attributes = this.attributesToSQL(attributes);\n    let backupTableName;\n\n    if (typeof tableName === \"object\") {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(\", \");\n    return `${this.createTableQuery(backupTableName, attributes)}INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};DROP TABLE ${quotedTableName};${this.createTableQuery(tableName, attributes)}INSERT INTO ${quotedTableName} SELECT ${attributeNames} FROM ${quotedBackupTableName};DROP TABLE ${quotedBackupTableName};`;\n  }\n\n  _alterConstraintQuery(tableName, attributes, createTableSql) {\n    let backupTableName;\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === \"object\") {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(\", \");\n    return `${createTableSql.replace(`CREATE TABLE ${quotedTableName}`, `CREATE TABLE ${quotedBackupTableName}`).replace(`CREATE TABLE ${quotedTableName.replace(/`/g, '\"')}`, `CREATE TABLE ${quotedBackupTableName}`)}INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};DROP TABLE ${quotedTableName};ALTER TABLE ${quotedBackupTableName} RENAME TO ${quotedTableName};`;\n  }\n\n  renameColumnQuery(tableName, attrNameBefore, attrNameAfter, attributes) {\n    let backupTableName;\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === \"object\") {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNamesImport = Object.keys(attributes).map(attr => attrNameAfter === attr ? `${this.quoteIdentifier(attrNameBefore)} AS ${this.quoteIdentifier(attr)}` : this.quoteIdentifier(attr)).join(\", \");\n    const attributeNamesExport = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(\", \");\n    return `${this.createTableQuery(backupTableName, attributes)}INSERT INTO ${quotedBackupTableName} SELECT ${attributeNamesImport} FROM ${quotedTableName};DROP TABLE ${quotedTableName};${this.createTableQuery(tableName, attributes)}INSERT INTO ${quotedTableName} SELECT ${attributeNamesExport} FROM ${quotedBackupTableName};DROP TABLE ${quotedBackupTableName};`;\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return `BEGIN ${transaction.options.type} TRANSACTION;`;\n  }\n\n  setIsolationLevelQuery(value) {\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        return \"-- SQLite is not able to choose the isolation level REPEATABLE READ.\";\n\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n        return \"PRAGMA read_uncommitted = ON;\";\n\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return \"PRAGMA read_uncommitted = OFF;\";\n\n      case Transaction.ISOLATION_LEVELS.SERIALIZABLE:\n        return \"-- SQLite's default isolation level is SERIALIZABLE. Nothing to do.\";\n\n      default:\n        throw new Error(`Unknown isolation level: ${value}`);\n    }\n  }\n\n  replaceBooleanDefaults(sql) {\n    return sql.replace(/DEFAULT '?false'?/g, \"DEFAULT 0\").replace(/DEFAULT '?true'?/g, \"DEFAULT 1\");\n  }\n\n  getForeignKeysQuery(tableName) {\n    return `PRAGMA foreign_key_list(${this.quoteTable(this.addSchema(tableName))})`;\n  }\n\n  tableExistsQuery(tableName) {\n    return `SELECT name FROM sqlite_master WHERE type='table' AND name=${this.escape(this.addSchema(tableName))};`;\n  }\n\n  quoteIdentifier(identifier, force) {\n    return Utils.addTicks(Utils.removeTicks(identifier, \"`\"), \"`\");\n  }\n\n}\n\nmodule.exports = SQLiteQueryGenerator;","map":{"version":3,"mappings":"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","names":["Utils","require","Transaction","_","MySqlQueryGenerator","AbstractQueryGenerator","createSchema","showSchemasQuery","versionQuery","createTableQuery","tableName","attributes","options","primaryKeys","needsMultiplePrimaryKeys","Object","values","filter","definition","includes","length","attrArray","attr","prototype","hasOwnProperty","call","dataType","containsAutoIncrement","dataTypeString","substr","indexOf","push","replace","quoteIdentifier","table","quoteTable","attrStr","join","pkString","map","pk","uniqueKeys","each","columns","customIndex","fields","field","sql","replaceBooleanDefaults","booleanValue","value","_checkValidJsonStatement","stmt","jsonFunctionRegex","tokenCaptureRegex","currentIndex","openingBrackets","closingBrackets","hasJsonFunction","hasInvalidToken","string","functionMatches","exec","tokenMatches","capturedToken","Error","_toJSONValue","Date","toISOString","Array","isArray","val","handleSequelizeMethod","smth","factory","prepend","Json","Cast","test","type","addColumnQuery","key","attributesToSQL","context","attribute","showTablesQuery","updateQuery","attrValueHash","where","defaults","removeNullValuesFromHash","omitNull","modelAttributeMap","bind","bindParam","SequelizeMethod","escape","format","query","whereOptions","__spreadProps","limit","whereQuery","truncateTableQuery","restartIdentity","addTicks","removeTicks","deleteQuery","model","whereClause","getWhereConditions","result","name","fieldName","isObject","toString","allowNull","defaultValueSchemable","defaultValue","unique","primaryKey","autoIncrement","references","referencesTable","referencesKey","onDelete","toUpperCase","onUpdate","showIndexesQuery","showConstraintsQuery","constraintName","removeIndexQuery","indexNameOrAttributes","indexName","underscore","describeTableQuery","schema","schemaDelimiter","_schema","_schemaDelimiter","addSchema","describeCreateTableQuery","removeColumnQuery","backupTableName","quotedTableName","quotedBackupTableName","attributeNames","keys","_alterConstraintQuery","createTableSql","renameColumnQuery","attrNameBefore","attrNameAfter","attributeNamesImport","attributeNamesExport","startTransactionQuery","transaction","parent","setIsolationLevelQuery","ISOLATION_LEVELS","REPEATABLE_READ","READ_UNCOMMITTED","READ_COMMITTED","SERIALIZABLE","getForeignKeysQuery","tableExistsQuery","identifier","force","module","exports","SQLiteQueryGenerator"],"sources":["/Users/aurele/node_modules/sequelize/src/dialects/sqlite/query-generator.js"],"sourcesContent":["'use strict';\n\nconst Utils = require('../../utils');\nconst Transaction = require('../../transaction');\nconst _ = require('lodash');\nconst MySqlQueryGenerator = require('../mysql/query-generator');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\n\nclass SQLiteQueryGenerator extends MySqlQueryGenerator {\n  createSchema() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n\n  showSchemasQuery() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n\n  versionQuery() {\n    return 'SELECT sqlite_version() as `version`';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = options || {};\n\n    const primaryKeys = [];\n    const needsMultiplePrimaryKeys = Object.values(attributes).filter(definition => definition.includes('PRIMARY KEY')).length > 1;\n    const attrArray = [];\n\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        const dataType = attributes[attr];\n        const containsAutoIncrement = dataType.includes('AUTOINCREMENT');\n\n        let dataTypeString = dataType;\n        if (dataType.includes('PRIMARY KEY')) {\n          if (dataType.includes('INT')) {\n            // Only INTEGER is allowed for primary key, see https://github.com/sequelize/sequelize/issues/969 (no lenght, unsigned etc)\n            dataTypeString = containsAutoIncrement ? 'INTEGER PRIMARY KEY AUTOINCREMENT' : 'INTEGER PRIMARY KEY';\n\n            if (dataType.includes(' REFERENCES')) {\n              dataTypeString += dataType.substr(dataType.indexOf(' REFERENCES'));\n            }\n          }\n\n          if (needsMultiplePrimaryKeys) {\n            primaryKeys.push(attr);\n            if (dataType.includes('NOT NULL')) {\n              dataTypeString = dataType.replace(' PRIMARY KEY', '');\n            } else {\n              dataTypeString = dataType.replace('PRIMARY KEY', 'NOT NULL');\n            }\n          }\n        }\n        attrArray.push(`${this.quoteIdentifier(attr)} ${dataTypeString}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attrStr = attrArray.join(', ');\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, columns => {\n        if (columns.customIndex) {\n          attrStr += `, UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attrStr += `, PRIMARY KEY (${pkString})`;\n    }\n\n    const sql = `CREATE TABLE IF NOT EXISTS ${table} (${attrStr});`;\n    return this.replaceBooleanDefaults(sql);\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   */\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    // https://sqlite.org/json1.html\n    const jsonFunctionRegex = /^\\s*(json(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  }\n\n  //sqlite can't cast to datetime so we need to convert date values to their ISO strings\n  _toJSONValue(value) {\n    if (value instanceof Date) {\n      return value.toISOString();\n    }\n    if (Array.isArray(value) && value[0] instanceof Date) {\n      return value.map(val => val.toISOString());\n    }\n    return value;\n  }\n\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n    }\n\n    if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = 'datetime';\n      }\n    }\n\n    return AbstractQueryGenerator.prototype.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  }\n\n  addColumnQuery(table, key, dataType) {\n    const attributes = {};\n    attributes[key] = dataType;\n    const fields = this.attributesToSQL(attributes, { context: 'addColumn' });\n    const attribute = `${this.quoteIdentifier(key)} ${fields[key]}`;\n\n    const sql = `ALTER TABLE ${this.quoteTable(table)} ADD ${attribute};`;\n\n    return this.replaceBooleanDefaults(sql);\n  }\n\n  showTablesQuery() {\n    return 'SELECT name FROM `sqlite_master` WHERE type=\\'table\\' and name!=\\'sqlite_sequence\\';';\n  }\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n\n    const modelAttributeMap = {};\n    const values = [];\n    const bind = [];\n    const bindParam = options.bindParam || this.bindParam(bind);\n\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' }, bindParam)}`);\n      }\n    }\n\n    let query;\n    const whereOptions = { ...options, bindParam };\n\n    if (options.limit) {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} LIMIT ${this.escape(options.limit)})`;\n    } else {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} ${this.whereQuery(where, whereOptions)}`;\n    }\n\n    return { query, bind };\n  }\n\n  truncateTableQuery(tableName, options = {}) {\n    return [\n      `DELETE FROM ${this.quoteTable(tableName)}`,\n      options.restartIdentity ? `; DELETE FROM ${this.quoteTable('sqlite_sequence')} WHERE ${this.quoteIdentifier('name')} = ${Utils.addTicks(Utils.removeTicks(this.quoteTable(tableName), '`'), \"'\")};` : ''\n    ].join('');\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    _.defaults(options, this.options);\n\n    let whereClause = this.getWhereConditions(where, null, model, options);\n\n    if (whereClause) {\n      whereClause = `WHERE ${whereClause}`;\n    }\n\n    if (options.limit) {\n      whereClause = `WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${whereClause} LIMIT ${this.escape(options.limit)})`;\n    }\n\n    return `DELETE FROM ${this.quoteTable(tableName)} ${whereClause}`;\n  }\n\n  attributesToSQL(attributes) {\n    const result = {};\n    for (const name in attributes) {\n      const dataType = attributes[name];\n      const fieldName = dataType.field || name;\n\n      if (_.isObject(dataType)) {\n        let sql = dataType.type.toString();\n\n        if (Object.prototype.hasOwnProperty.call(dataType, 'allowNull') && !dataType.allowNull) {\n          sql += ' NOT NULL';\n        }\n\n        if (Utils.defaultValueSchemable(dataType.defaultValue)) {\n          // TODO thoroughly check that DataTypes.NOW will properly\n          // get populated on all databases as DEFAULT value\n          // i.e. mysql requires: DEFAULT CURRENT_TIMESTAMP\n          sql += ` DEFAULT ${this.escape(dataType.defaultValue, dataType)}`;\n        }\n\n        if (dataType.unique === true) {\n          sql += ' UNIQUE';\n        }\n\n        if (dataType.primaryKey) {\n          sql += ' PRIMARY KEY';\n\n          if (dataType.autoIncrement) {\n            sql += ' AUTOINCREMENT';\n          }\n        }\n\n        if (dataType.references) {\n          const referencesTable = this.quoteTable(dataType.references.model);\n\n          let referencesKey;\n          if (dataType.references.key) {\n            referencesKey = this.quoteIdentifier(dataType.references.key);\n          } else {\n            referencesKey = this.quoteIdentifier('id');\n          }\n\n          sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n\n          if (dataType.onDelete) {\n            sql += ` ON DELETE ${dataType.onDelete.toUpperCase()}`;\n          }\n\n          if (dataType.onUpdate) {\n            sql += ` ON UPDATE ${dataType.onUpdate.toUpperCase()}`;\n          }\n\n        }\n\n        result[fieldName] = sql;\n      } else {\n        result[fieldName] = dataType;\n      }\n    }\n\n    return result;\n  }\n\n  showIndexesQuery(tableName) {\n    return `PRAGMA INDEX_LIST(${this.quoteTable(tableName)})`;\n  }\n\n  showConstraintsQuery(tableName, constraintName) {\n    let sql = `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}'`;\n\n    if (constraintName) {\n      sql += ` AND sql LIKE '%${constraintName}%'`;\n    }\n\n    return `${sql};`;\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX IF EXISTS ${this.quoteIdentifier(indexName)}`;\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = {\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter,\n      tableName\n    };\n    return `PRAGMA TABLE_INFO(${this.quoteTable(this.addSchema(table))});`;\n  }\n\n  describeCreateTableQuery(tableName) {\n    return `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}';`;\n  }\n\n  removeColumnQuery(tableName, attributes) {\n\n    attributes = this.attributesToSQL(attributes);\n\n    let backupTableName;\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    // Temporary table cannot work for foreign keys.\n    return `${this.createTableQuery(backupTableName, attributes)\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};${\n        this.createTableQuery(tableName, attributes)\n      }INSERT INTO ${quotedTableName} SELECT ${attributeNames} FROM ${quotedBackupTableName};`\n      + `DROP TABLE ${quotedBackupTableName};`;\n  }\n\n  _alterConstraintQuery(tableName, attributes, createTableSql) {\n    let backupTableName;\n\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    return `${createTableSql\n      .replace(`CREATE TABLE ${quotedTableName}`, `CREATE TABLE ${quotedBackupTableName}`)\n      .replace(`CREATE TABLE ${quotedTableName.replace(/`/g, '\"')}`, `CREATE TABLE ${quotedBackupTableName}`)\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};`\n      + `ALTER TABLE ${quotedBackupTableName} RENAME TO ${quotedTableName};`;\n  }\n\n  renameColumnQuery(tableName, attrNameBefore, attrNameAfter, attributes) {\n\n    let backupTableName;\n\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNamesImport = Object.keys(attributes).map(attr =>\n      attrNameAfter === attr ? `${this.quoteIdentifier(attrNameBefore)} AS ${this.quoteIdentifier(attr)}` : this.quoteIdentifier(attr)\n    ).join(', ');\n    const attributeNamesExport = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    // Temporary tables don't support foreign keys, so creating a temporary table will not allow foreign keys to be preserved\n    return `${this.createTableQuery(backupTableName, attributes)\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNamesImport} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};${\n        this.createTableQuery(tableName, attributes)\n      }INSERT INTO ${quotedTableName} SELECT ${attributeNamesExport} FROM ${quotedBackupTableName};`\n      + `DROP TABLE ${quotedBackupTableName};`;\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return `BEGIN ${transaction.options.type} TRANSACTION;`;\n  }\n\n  setIsolationLevelQuery(value) {\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        return '-- SQLite is not able to choose the isolation level REPEATABLE READ.';\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n        return 'PRAGMA read_uncommitted = ON;';\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return 'PRAGMA read_uncommitted = OFF;';\n      case Transaction.ISOLATION_LEVELS.SERIALIZABLE:\n        return '-- SQLite\\'s default isolation level is SERIALIZABLE. Nothing to do.';\n      default:\n        throw new Error(`Unknown isolation level: ${value}`);\n    }\n  }\n\n  replaceBooleanDefaults(sql) {\n    return sql.replace(/DEFAULT '?false'?/g, 'DEFAULT 0').replace(/DEFAULT '?true'?/g, 'DEFAULT 1');\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {TableName} tableName  The name of the table.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(tableName) {\n    return `PRAGMA foreign_key_list(${this.quoteTable(this.addSchema(tableName))})`;\n  }\n\n  tableExistsQuery(tableName) {\n    return `SELECT name FROM sqlite_master WHERE type='table' AND name=${this.escape(this.addSchema(tableName))};`;\n  }\n\n  /**\n   * Quote identifier in sql clause\n   *\n   * @param {string} identifier\n   * @param {boolean} force\n   *\n   * @returns {string}\n   */\n  quoteIdentifier(identifier, force) {\n    return Utils.addTicks(Utils.removeTicks(identifier, '`'), '`');\n  }\n\n}\n\nmodule.exports = SQLiteQueryGenerator;\n"]},"metadata":{},"sourceType":"script"}