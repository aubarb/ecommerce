{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __markAsModule = target => __defProp(target, \"__esModule\", {\n  value: true\n});\n\nvar __export = (target, all) => {\n  __markAsModule(target);\n\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n\n__export(exports, {\n  OracleQueryInterface: () => OracleQueryInterface\n});\n\nconst {\n  QueryInterface\n} = require(\"../abstract/query-interface\");\n\nconst QueryTypes = require(\"../../query-types\");\n\nconst _ = require(\"lodash\");\n\nclass OracleQueryInterface extends QueryInterface {\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = __spreadValues({}, options);\n    const model = options.model;\n    const primaryKeys = Object.values(model.primaryKeys).map(item => item.field);\n    const uniqueKeys = Object.values(model.uniqueKeys).filter(c => c.fields.length > 0).map(c => c.fields);\n    const indexKeys = Object.values(model._indexes).filter(c => c.unique && c.fields.length > 0).map(c => c.fields);\n    options.type = QueryTypes.UPSERT;\n    options.updateOnDuplicate = Object.keys(updateValues);\n    options.upsertKeys = [];\n\n    for (const field of options.updateOnDuplicate) {\n      const uniqueKey = uniqueKeys.find(fields => fields.includes(field));\n\n      if (uniqueKey) {\n        options.upsertKeys = uniqueKey;\n        break;\n      }\n\n      const indexKey = indexKeys.find(fields => fields.includes(field));\n\n      if (indexKey) {\n        options.upsertKeys = indexKey;\n        break;\n      }\n    }\n\n    if (options.upsertKeys.length === 0 || _.intersection(options.updateOnDuplicate, primaryKeys).length) {\n      options.upsertKeys = primaryKeys;\n    }\n\n    options.upsertKeys = _.uniq(options.upsertKeys);\n    let whereHasNull = false;\n    primaryKeys.forEach(element => {\n      if (where[element] === null) {\n        whereHasNull = true;\n      }\n    });\n\n    if (whereHasNull === true) {\n      where = options.upsertKeys.reduce((result, attribute) => {\n        result[attribute] = insertValues[attribute];\n        return result;\n      }, {});\n    }\n\n    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n\n    if (sql.bind) {\n      options.bind = void 0;\n    }\n\n    return await this.sequelize.query(sql, options);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["__export","OracleQueryInterface","QueryInterface","require","QueryTypes","_","tableName","insertValues","updateValues","where","options","__spreadValues","model","primaryKeys","Object","values","map","item","field","uniqueKeys","filter","c","fields","length","indexKeys","_indexes","unique","type","UPSERT","updateOnDuplicate","keys","upsertKeys","uniqueKey","find","includes","indexKey","intersection","uniq","whereHasNull","forEach","element","reduce","result","attribute","sql","queryGenerator","upsertQuery","bind","sequelize","query"],"sources":["/Users/aurele/node_modules/sequelize/src/dialects/oracle/query-interface.js"],"sourcesContent":["// Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved\n\n'use strict';\nconst { QueryInterface } = require('../abstract/query-interface');\nconst QueryTypes = require('../../query-types');\n\nconst _ = require('lodash');\n/**\n * The interface that Sequelize uses to talk with Oracle database\n */\nexport class OracleQueryInterface extends QueryInterface {\n\n  /**\n   * Upsert\n   *\n   * @param {string} tableName    table to upsert on\n   * @param {object} insertValues values to be inserted, mapped to field name\n   * @param {object} updateValues values to be updated, mapped to field name\n   * @param {object} where        where conditions, which can be used for UPDATE part when INSERT fails\n   * @param {object} options      query options\n   *\n   * @returns {Promise<boolean,?number>} Resolves an array with <created, primaryKey>\n   */\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = { ...options };\n\n    const model = options.model;\n    const primaryKeys = Object.values(model.primaryKeys).map(item => item.field);\n    const uniqueKeys = Object.values(model.uniqueKeys).filter(c => c.fields.length > 0).map(c => c.fields);\n    const indexKeys = Object.values(model._indexes).filter(c => c.unique && c.fields.length > 0).map(c => c.fields);\n\n    options.type = QueryTypes.UPSERT;\n    options.updateOnDuplicate = Object.keys(updateValues);\n    options.upsertKeys = [];\n\n    // For fields in updateValues, try to find a constraint or unique index\n    // that includes given field. Only first matching upsert key is used.\n    for (const field of options.updateOnDuplicate) {\n      const uniqueKey = uniqueKeys.find(fields => fields.includes(field));\n      if (uniqueKey) {\n        options.upsertKeys = uniqueKey;\n        break;\n      }\n\n      const indexKey = indexKeys.find(fields => fields.includes(field));\n      if (indexKey) {\n        options.upsertKeys = indexKey;\n        break;\n      }\n    }\n\n    // Always use PK, if no constraint available OR update data contains PK\n    if (\n      options.upsertKeys.length === 0\n      || _.intersection(options.updateOnDuplicate, primaryKeys).length\n    ) {\n      options.upsertKeys = primaryKeys;\n    }\n\n    options.upsertKeys = _.uniq(options.upsertKeys);\n\n    let whereHasNull = false;\n\n    primaryKeys.forEach(element => {\n      if (where[element] === null) {\n        whereHasNull = true;\n      }\n    });\n\n    if (whereHasNull === true) {\n      where = options.upsertKeys.reduce((result, attribute) => {\n        result[attribute] = insertValues[attribute];\n        return result;\n      }, {}); \n    }\n\n    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n    // we need set this to undefined otherwise sequelize would raise an error\n    // Error: Both `sql.bind` and `options.bind` cannot be set at the same time\n    if (sql.bind) {\n      options.bind = undefined;\n    }\n    return await this.sequelize.query(sql, options);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}