{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nvar __objRest = (source, exclude) => {\n  var target = {};\n\n  for (var prop in source) if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n\n  if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)) {\n    if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n  }\n  return target;\n};\n\nconst DataTypes = require(\"../../data-types\");\n\nconst QueryTypes = require(\"../../query-types\");\n\nconst {\n  QueryInterface\n} = require(\"../abstract/query-interface\");\n\nconst Utils = require(\"../../utils\");\n\nconst Deferrable = require(\"../../deferrable\");\n\nclass PostgresQueryInterface extends QueryInterface {\n  async ensureEnums(tableName, attributes, options, model) {\n    var _this = this;\n\n    const keys = Object.keys(attributes);\n    const keyLen = keys.length;\n    let sql = \"\";\n    let promises = [];\n    let i = 0;\n\n    for (i = 0; i < keyLen; i++) {\n      const attribute = attributes[keys[i]];\n      const type = attribute.type;\n\n      if (type instanceof DataTypes.ENUM || type instanceof DataTypes.ARRAY && type.type instanceof DataTypes.ENUM) {\n        sql = this.queryGenerator.pgListEnums(tableName, attribute.field || keys[i], options);\n        promises.push(this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {\n          plain: true,\n          raw: true,\n          type: QueryTypes.SELECT\n        })));\n      }\n    }\n\n    const results = await Promise.all(promises);\n    promises = [];\n    let enumIdx = 0;\n\n    const addEnumValue = function (field, value, relativeValue) {\n      let position = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"before\";\n      let spliceStart = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : promises.length;\n\n      const valueOptions = __spreadValues({}, options);\n\n      valueOptions.before = null;\n      valueOptions.after = null;\n\n      switch (position) {\n        case \"after\":\n          valueOptions.after = relativeValue;\n          break;\n\n        case \"before\":\n        default:\n          valueOptions.before = relativeValue;\n          break;\n      }\n\n      promises.splice(spliceStart, 0, () => {\n        return _this.sequelize.query(_this.queryGenerator.pgEnumAdd(tableName, field, value, valueOptions), valueOptions);\n      });\n    };\n\n    for (i = 0; i < keyLen; i++) {\n      const attribute = attributes[keys[i]];\n      const type = attribute.type;\n      const enumType = type.type || type;\n      const field = attribute.field || keys[i];\n\n      if (type instanceof DataTypes.ENUM || type instanceof DataTypes.ARRAY && enumType instanceof DataTypes.ENUM) {\n        if (!results[enumIdx]) {\n          promises.push(() => {\n            return this.sequelize.query(this.queryGenerator.pgEnum(tableName, field, enumType, options), __spreadProps(__spreadValues({}, options), {\n              raw: true\n            }));\n          });\n        } else if (!!results[enumIdx] && !!model) {\n          const enumVals = this.queryGenerator.fromArray(results[enumIdx].enum_value);\n          const vals = enumType.values;\n          let lastOldEnumValue;\n          let rightestPosition = -1;\n\n          for (let oldIndex = 0; oldIndex < enumVals.length; oldIndex++) {\n            const enumVal = enumVals[oldIndex];\n            const newIdx = vals.indexOf(enumVal);\n            lastOldEnumValue = enumVal;\n\n            if (newIdx === -1) {\n              continue;\n            }\n\n            const newValuesBefore = vals.slice(0, newIdx);\n            const promisesLength = promises.length;\n\n            for (let reverseIdx = newValuesBefore.length - 1; reverseIdx >= 0; reverseIdx--) {\n              if (~enumVals.indexOf(newValuesBefore[reverseIdx])) {\n                break;\n              }\n\n              addEnumValue(field, newValuesBefore[reverseIdx], lastOldEnumValue, \"before\", promisesLength);\n            }\n\n            if (newIdx > rightestPosition) {\n              rightestPosition = newIdx;\n            }\n          }\n\n          if (lastOldEnumValue && rightestPosition < vals.length - 1) {\n            const remainingEnumValues = vals.slice(rightestPosition + 1);\n\n            for (let reverseIdx = remainingEnumValues.length - 1; reverseIdx >= 0; reverseIdx--) {\n              addEnumValue(field, remainingEnumValues[reverseIdx], lastOldEnumValue, \"after\");\n            }\n          }\n\n          enumIdx++;\n        }\n      }\n    }\n\n    const result = await promises.reduce(async (promise, asyncFunction) => await asyncFunction(await promise), Promise.resolve());\n\n    if (promises.length) {\n      await this.sequelize.dialect.connectionManager._refreshDynamicOIDs();\n    }\n\n    return result;\n  }\n\n  async getForeignKeyReferencesForTable(table, options) {\n    const queryOptions = __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.FOREIGNKEYS\n    });\n\n    const query = this.queryGenerator.getForeignKeyReferencesQuery(table.tableName || table, this.sequelize.config.database);\n    const result = await this.sequelize.query(query, queryOptions);\n    return result.map(fkMeta => {\n      const _a = Utils.camelizeObjectKeys(fkMeta),\n            {\n        initiallyDeferred,\n        isDeferrable\n      } = _a,\n            remaining = __objRest(_a, [\"initiallyDeferred\", \"isDeferrable\"]);\n\n      return __spreadProps(__spreadValues({}, remaining), {\n        deferrable: isDeferrable === \"NO\" ? Deferrable.NOT : initiallyDeferred === \"NO\" ? Deferrable.INITIALLY_IMMEDIATE : Deferrable.INITIALLY_DEFERRED\n      });\n    });\n  }\n\n  async dropEnum(enumName, options) {\n    options = options || {};\n    return this.sequelize.query(this.queryGenerator.pgEnumDrop(null, null, this.queryGenerator.pgEscapeAndQuote(enumName)), __spreadProps(__spreadValues({}, options), {\n      raw: true\n    }));\n  }\n\n  async dropAllEnums(options) {\n    options = options || {};\n    const enums = await this.pgListEnums(null, options);\n    return await Promise.all(enums.map(result => this.sequelize.query(this.queryGenerator.pgEnumDrop(null, null, this.queryGenerator.pgEscapeAndQuote(result.enum_name)), __spreadProps(__spreadValues({}, options), {\n      raw: true\n    }))));\n  }\n\n  async pgListEnums(tableName, options) {\n    options = options || {};\n    const sql = this.queryGenerator.pgListEnums(tableName);\n    return this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {\n      plain: false,\n      raw: true,\n      type: QueryTypes.SELECT\n    }));\n  }\n\n  async dropTable(tableName, options) {\n    await super.dropTable(tableName, options);\n    const promises = [];\n    const instanceTable = this.sequelize.modelManager.getModel(tableName, {\n      attribute: \"tableName\"\n    });\n\n    if (!instanceTable) {\n      return;\n    }\n\n    const getTableName = (!options || !options.schema || options.schema === \"public\" ? \"\" : `${options.schema}_`) + tableName;\n    const keys = Object.keys(instanceTable.rawAttributes);\n    const keyLen = keys.length;\n\n    for (let i = 0; i < keyLen; i++) {\n      if (instanceTable.rawAttributes[keys[i]].type instanceof DataTypes.ENUM) {\n        const sql = this.queryGenerator.pgEnumDrop(getTableName, keys[i]);\n        options.supportsSearchPath = false;\n        promises.push(this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {\n          raw: true\n        })));\n      }\n    }\n\n    await Promise.all(promises);\n  }\n\n}\n\nexports.PostgresQueryInterface = PostgresQueryInterface;","map":{"version":3,"mappings":"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","names":["DataTypes","require","QueryTypes","QueryInterface","Utils","Deferrable","tableName","attributes","options","model","keys","Object","keyLen","length","sql","promises","i","attribute","type","ENUM","ARRAY","queryGenerator","pgListEnums","field","push","sequelize","query","__spreadProps","plain","raw","SELECT","results","Promise","all","enumIdx","addEnumValue","value","relativeValue","position","spliceStart","valueOptions","__spreadValues","before","after","splice","pgEnumAdd","enumType","pgEnum","enumVals","fromArray","enum_value","vals","values","lastOldEnumValue","rightestPosition","oldIndex","enumVal","newIdx","indexOf","newValuesBefore","slice","promisesLength","reverseIdx","remainingEnumValues","result","reduce","promise","asyncFunction","resolve","dialect","connectionManager","_refreshDynamicOIDs","table","queryOptions","FOREIGNKEYS","getForeignKeyReferencesQuery","config","database","map","fkMeta","_a","camelizeObjectKeys","initiallyDeferred","isDeferrable","remaining","deferrable","NOT","INITIALLY_IMMEDIATE","INITIALLY_DEFERRED","enumName","pgEnumDrop","pgEscapeAndQuote","enums","enum_name","dropTable","instanceTable","modelManager","getModel","getTableName","schema","rawAttributes","supportsSearchPath","exports","PostgresQueryInterface"],"sources":["/Users/aurele/node_modules/sequelize/src/dialects/postgres/query-interface.js"],"sourcesContent":["'use strict';\n\nconst DataTypes = require('../../data-types');\nconst QueryTypes = require('../../query-types');\nconst { QueryInterface } = require('../abstract/query-interface');\nconst Utils = require('../../utils');\nconst Deferrable = require('../../deferrable');\n\n/**\n * The interface that Sequelize uses to talk with Postgres database\n */\nclass PostgresQueryInterface extends QueryInterface {\n  /**\n   * Ensure enum and their values.\n   *\n   * @param {string} tableName  Name of table to create\n   * @param {object} attributes Object representing a list of normalized table attributes\n   * @param {object} [options]\n   * @param {Model}  [model]\n   *\n   * @protected\n   */\n  async ensureEnums(tableName, attributes, options, model) {\n    const keys = Object.keys(attributes);\n    const keyLen = keys.length;\n\n    let sql = '';\n    let promises = [];\n    let i = 0;\n\n    for (i = 0; i < keyLen; i++) {\n      const attribute = attributes[keys[i]];\n      const type = attribute.type;\n\n      if (\n        type instanceof DataTypes.ENUM ||\n        type instanceof DataTypes.ARRAY && type.type instanceof DataTypes.ENUM //ARRAY sub type is ENUM\n      ) {\n        sql = this.queryGenerator.pgListEnums(tableName, attribute.field || keys[i], options);\n        promises.push(this.sequelize.query(\n          sql,\n          { ...options, plain: true, raw: true, type: QueryTypes.SELECT }\n        ));\n      }\n    }\n\n    const results = await Promise.all(promises);\n    promises = [];\n    let enumIdx = 0;\n\n    // This little function allows us to re-use the same code that prepends or appends new value to enum array\n    const addEnumValue = (field, value, relativeValue, position = 'before', spliceStart = promises.length) => {\n      const valueOptions = { ...options };\n      valueOptions.before = null;\n      valueOptions.after = null;\n\n      switch (position) {\n        case 'after':\n          valueOptions.after = relativeValue;\n          break;\n        case 'before':\n        default:\n          valueOptions.before = relativeValue;\n          break;\n      }\n\n      promises.splice(spliceStart, 0, () => {\n        return this.sequelize.query(this.queryGenerator.pgEnumAdd(\n          tableName, field, value, valueOptions\n        ), valueOptions);\n      });\n    };\n\n    for (i = 0; i < keyLen; i++) {\n      const attribute = attributes[keys[i]];\n      const type = attribute.type;\n      const enumType = type.type || type;\n      const field = attribute.field || keys[i];\n\n      if (\n        type instanceof DataTypes.ENUM ||\n        type instanceof DataTypes.ARRAY && enumType instanceof DataTypes.ENUM //ARRAY sub type is ENUM\n      ) {\n        // If the enum type doesn't exist then create it\n        if (!results[enumIdx]) {\n          promises.push(() => {\n            return this.sequelize.query(this.queryGenerator.pgEnum(tableName, field, enumType, options), { ...options, raw: true });\n          });\n        } else if (!!results[enumIdx] && !!model) {\n          const enumVals = this.queryGenerator.fromArray(results[enumIdx].enum_value);\n          const vals = enumType.values;\n\n          // Going through already existing values allows us to make queries that depend on those values\n          // We will prepend all new values between the old ones, but keep in mind - we can't change order of already existing values\n          // Then we append the rest of new values AFTER the latest already existing value\n          // E.g.: [1,2] -> [0,2,1] ==> [1,0,2]\n          // E.g.: [1,2,3] -> [2,1,3,4] ==> [1,2,3,4]\n          // E.g.: [1] -> [0,2,3] ==> [1,0,2,3]\n          let lastOldEnumValue;\n          let rightestPosition = -1;\n          for (let oldIndex = 0; oldIndex < enumVals.length; oldIndex++) {\n            const enumVal = enumVals[oldIndex];\n            const newIdx = vals.indexOf(enumVal);\n            lastOldEnumValue = enumVal;\n\n            if (newIdx === -1) {\n              continue;\n            }\n\n            const newValuesBefore = vals.slice(0, newIdx);\n            const promisesLength = promises.length;\n            // we go in reverse order so we could stop when we meet old value\n            for (let reverseIdx = newValuesBefore.length - 1; reverseIdx >= 0; reverseIdx--) {\n              if (~enumVals.indexOf(newValuesBefore[reverseIdx])) {\n                break;\n              }\n\n              addEnumValue(field, newValuesBefore[reverseIdx], lastOldEnumValue, 'before', promisesLength);\n            }\n\n            // we detect the most 'right' position of old value in new enum array so we can append new values to it\n            if (newIdx > rightestPosition) {\n              rightestPosition = newIdx;\n            }\n          }\n\n          if (lastOldEnumValue && rightestPosition < vals.length - 1) {\n            const remainingEnumValues = vals.slice(rightestPosition + 1);\n            for (let reverseIdx = remainingEnumValues.length - 1; reverseIdx >= 0; reverseIdx--) {\n              addEnumValue(field, remainingEnumValues[reverseIdx], lastOldEnumValue, 'after');\n            }\n          }\n\n          enumIdx++;\n        }\n      }\n    }\n\n    const result = await promises\n      .reduce(async (promise, asyncFunction) => await asyncFunction(await promise), Promise.resolve());\n\n    // If ENUM processed, then refresh OIDs\n    if (promises.length) {\n      await this.sequelize.dialect.connectionManager._refreshDynamicOIDs();\n    }\n    return result;\n  }\n\n  /**\n   * @override\n   */\n  async getForeignKeyReferencesForTable(table, options) {\n    const queryOptions = {\n      ...options,\n      type: QueryTypes.FOREIGNKEYS\n    };\n\n    // postgres needs some special treatment as those field names returned are all lowercase\n    // in order to keep same result with other dialects.\n    const query = this.queryGenerator.getForeignKeyReferencesQuery(table.tableName || table, this.sequelize.config.database);\n    const result = await this.sequelize.query(query, queryOptions);\n\n    return result.map(fkMeta => {\n      const { initiallyDeferred, isDeferrable, ...remaining } = Utils.camelizeObjectKeys(fkMeta);\n\n      return {\n        ...remaining,\n        deferrable: isDeferrable === 'NO' ? Deferrable.NOT\n          : initiallyDeferred === 'NO' ? Deferrable.INITIALLY_IMMEDIATE\n            : Deferrable.INITIALLY_DEFERRED\n      };\n    });\n  }\n\n  /**\n   * Drop specified enum from database (Postgres only)\n   *\n   * @param {string} [enumName]  Enum name to drop\n   * @param {object} options Query options\n   *\n   * @returns {Promise}\n   */\n  async dropEnum(enumName, options) {\n    options = options || {};\n\n    return this.sequelize.query(\n      this.queryGenerator.pgEnumDrop(null, null, this.queryGenerator.pgEscapeAndQuote(enumName)),\n      { ...options, raw: true }\n    );\n  }\n\n  /**\n   * Drop all enums from database (Postgres only)\n   *\n   * @param {object} options Query options\n   *\n   * @returns {Promise}\n   */\n  async dropAllEnums(options) {\n    options = options || {};\n\n    const enums = await this.pgListEnums(null, options);\n\n    return await Promise.all(enums.map(result => this.sequelize.query(\n      this.queryGenerator.pgEnumDrop(null, null, this.queryGenerator.pgEscapeAndQuote(result.enum_name)),\n      { ...options, raw: true }\n    )));\n  }\n\n  /**\n   * List all enums (Postgres only)\n   *\n   * @param {string} [tableName]  Table whose enum to list\n   * @param {object} [options]    Query options\n   *\n   * @returns {Promise}\n   */\n  async pgListEnums(tableName, options) {\n    options = options || {};\n    const sql = this.queryGenerator.pgListEnums(tableName);\n    return this.sequelize.query(sql, { ...options, plain: false, raw: true, type: QueryTypes.SELECT });\n  }\n\n  /**\n   * Since postgres has a special case for enums, we should drop the related\n   * enum type within the table and attribute\n   *\n   * @override\n   */\n  async dropTable(tableName, options) {\n    await super.dropTable(tableName, options);\n    const promises = [];\n    const instanceTable = this.sequelize.modelManager.getModel(tableName, { attribute: 'tableName' });\n\n    if (!instanceTable) {\n      // Do nothing when model is not available\n      return;\n    }\n\n    const getTableName = (!options || !options.schema || options.schema === 'public' ? '' : `${options.schema}_`) + tableName;\n\n    const keys = Object.keys(instanceTable.rawAttributes);\n    const keyLen = keys.length;\n\n    for (let i = 0; i < keyLen; i++) {\n      if (instanceTable.rawAttributes[keys[i]].type instanceof DataTypes.ENUM) {\n        const sql = this.queryGenerator.pgEnumDrop(getTableName, keys[i]);\n        options.supportsSearchPath = false;\n        promises.push(this.sequelize.query(sql, { ...options, raw: true }));\n      }\n    }\n\n    await Promise.all(promises);\n  }\n}\n\nexports.PostgresQueryInterface = PostgresQueryInterface;\n"]},"metadata":{},"sourceType":"script"}