{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nconst _ = require(\"lodash\");\n\nconst Utils = require(\"../../utils\");\n\nconst Op = require(\"../../operators\");\n\nconst {\n  QueryInterface\n} = require(\"../abstract/query-interface\");\n\nconst QueryTypes = require(\"../../query-types\");\n\nclass Db2QueryInterface extends QueryInterface {\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const queryOptions = __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.FOREIGNKEYS\n    });\n\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.username.toUpperCase());\n    return this.sequelize.query(query, queryOptions);\n  }\n\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = __spreadValues({}, options);\n    const model = options.model;\n    const wheres = [];\n    const attributes = Object.keys(insertValues);\n    let indexes = [];\n    let indexFields;\n    options = _.clone(options);\n\n    if (!Utils.isWhereEmpty(where)) {\n      wheres.push(where);\n    }\n\n    indexes = _.map(model.uniqueKeys, value => {\n      return value.fields;\n    });\n\n    model._indexes.forEach(value => {\n      if (value.unique) {\n        indexFields = value.fields.map(field => {\n          if (_.isPlainObject(field)) {\n            return field.attribute;\n          }\n\n          return field;\n        });\n        indexes.push(indexFields);\n      }\n    });\n\n    for (const index of indexes) {\n      if (_.intersection(attributes, index).length === index.length) {\n        where = {};\n\n        for (const field of index) {\n          where[field] = insertValues[field];\n        }\n\n        wheres.push(where);\n      }\n    }\n\n    where = {\n      [Op.or]: wheres\n    };\n    options.type = QueryTypes.UPSERT;\n    options.raw = true;\n    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n    const result = await this.sequelize.query(sql, options);\n    return [result, void 0];\n  }\n\n  async createTable(tableName, attributes, options, model) {\n    let sql = \"\";\n    options = __spreadValues({}, options);\n\n    if (options && options.uniqueKeys) {\n      _.forOwn(options.uniqueKeys, uniqueKey => {\n        if (uniqueKey.customIndex === void 0) {\n          uniqueKey.customIndex = true;\n        }\n      });\n    }\n\n    if (model) {\n      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n    }\n\n    attributes = _.mapValues(attributes, attribute => this.sequelize.normalizeAttribute(attribute));\n\n    if (options.indexes) {\n      options.indexes.forEach(fields => {\n        const fieldArr = fields.fields;\n\n        if (fieldArr.length === 1) {\n          fieldArr.forEach(field => {\n            for (const property in attributes) {\n              if (field === attributes[property].field) {\n                attributes[property].unique = true;\n              }\n            }\n          });\n        }\n      });\n    }\n\n    if (options.alter) {\n      if (options.indexes) {\n        options.indexes.forEach(fields => {\n          const fieldArr = fields.fields;\n\n          if (fieldArr.length === 1) {\n            fieldArr.forEach(field => {\n              for (const property in attributes) {\n                if (field === attributes[property].field && attributes[property].unique) {\n                  attributes[property].unique = false;\n                }\n              }\n            });\n          }\n        });\n      }\n    }\n\n    if (!tableName.schema && (options.schema || !!model && model._schema)) {\n      tableName = this.queryGenerator.addSchema({\n        tableName,\n        _schema: !!model && model._schema || options.schema\n      });\n    }\n\n    attributes = this.queryGenerator.attributesToSQL(attributes, {\n      table: tableName,\n      context: \"createTable\",\n      withoutForeignKeyConstraints: options.withoutForeignKeyConstraints\n    });\n    sql = this.queryGenerator.createTableQuery(tableName, attributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n\n}\n\nexports.Db2QueryInterface = Db2QueryInterface;","map":{"version":3,"mappings":"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","names":["_","require","Utils","Op","QueryInterface","QueryTypes","tableName","options","queryOptions","__spreadProps","type","FOREIGNKEYS","query","queryGenerator","getForeignKeysQuery","sequelize","config","username","toUpperCase","insertValues","updateValues","where","__spreadValues","model","wheres","attributes","Object","keys","indexes","indexFields","clone","isWhereEmpty","push","map","uniqueKeys","value","fields","_indexes","forEach","unique","field","isPlainObject","attribute","index","intersection","length","or","UPSERT","raw","sql","upsertQuery","result","forOwn","uniqueKey","customIndex","mapValues","normalizeAttribute","fieldArr","property","alter","schema","_schema","addSchema","attributesToSQL","table","context","withoutForeignKeyConstraints","createTableQuery","exports","Db2QueryInterface"],"sources":["/Users/aurele/node_modules/sequelize/src/dialects/db2/query-interface.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst Op = require('../../operators');\nconst { QueryInterface } = require('../abstract/query-interface');\nconst QueryTypes = require('../../query-types');\n\n/**\n * The interface that Sequelize uses to talk with Db2 database\n */\nclass Db2QueryInterface extends QueryInterface {\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const queryOptions = {\n      ...options,\n      type: QueryTypes.FOREIGNKEYS\n    };\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.username.toUpperCase());\n    return this.sequelize.query(query, queryOptions);\n  }\n\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = { ...options };\n\n    const model = options.model;\n    const wheres = [];\n    const attributes = Object.keys(insertValues);\n    let indexes = [];\n    let indexFields;\n\n    options = _.clone(options);\n\n    if (!Utils.isWhereEmpty(where)) {\n      wheres.push(where);\n    }\n\n    // Lets combine unique keys and indexes into one\n    indexes = _.map(model.uniqueKeys, value => {\n      return value.fields;\n    });\n\n    model._indexes.forEach(value => {\n      if (value.unique) {\n        // fields in the index may both the strings or objects with an attribute property - lets sanitize that\n        indexFields = value.fields.map(field => {\n          if (_.isPlainObject(field)) {\n            return field.attribute;\n          }\n          return field;\n        });\n        indexes.push(indexFields);\n      }\n    });\n\n    for (const index of indexes) {\n      if (_.intersection(attributes, index).length === index.length) {\n        where = {};\n        for (const field of index) {\n          where[field] = insertValues[field];\n        }\n        wheres.push(where);\n      }\n    }\n\n    where = { [Op.or]: wheres };\n\n    options.type = QueryTypes.UPSERT;\n    options.raw = true;\n\n    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n    const result = await this.sequelize.query(sql, options);\n    return [result, undefined];\n  }\n\n  async createTable(tableName, attributes, options, model) {\n    let sql = '';\n\n    options = { ...options };\n\n    if (options && options.uniqueKeys) {\n      _.forOwn(options.uniqueKeys, uniqueKey => {\n        if (uniqueKey.customIndex === undefined) {\n          uniqueKey.customIndex = true;\n        }\n      });\n    }\n\n    if (model) {\n      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n    }\n    attributes = _.mapValues(\n      attributes,\n      attribute => this.sequelize.normalizeAttribute(attribute)\n    );  \n    if (options.indexes) {\n      options.indexes.forEach(fields=>{\n        const fieldArr = fields.fields;\n        if (fieldArr.length === 1) {\n          fieldArr.forEach(field=>{       \n            for (const property in attributes) {\n              if (field === attributes[property].field) {\n                attributes[property].unique = true;\n              }\n            }\n          });\n        }\n      });\n    }\n    if (options.alter) {\n      if (options.indexes) {\n        options.indexes.forEach(fields=>{\n          const fieldArr = fields.fields;\n          if (fieldArr.length === 1) {\n            fieldArr.forEach(field=>{       \n              for (const property in attributes) {\n                if (field === attributes[property].field && attributes[property].unique) {\n                  attributes[property].unique = false;\n                }\n              }\n            });\n          }\n        });\n      }\n    }\n\n    if (\n      !tableName.schema &&\n      (options.schema || !!model && model._schema)\n    ) {\n      tableName = this.queryGenerator.addSchema({\n        tableName,\n        _schema: !!model && model._schema || options.schema\n      });\n    }\n\n    attributes = this.queryGenerator.attributesToSQL(attributes, { table: tableName, context: 'createTable', withoutForeignKeyConstraints: options.withoutForeignKeyConstraints });\n    sql = this.queryGenerator.createTableQuery(tableName, attributes, options);\n\n    return await this.sequelize.query(sql, options);\n  }\n\n}\n\nexports.Db2QueryInterface = Db2QueryInterface;\n"]},"metadata":{},"sourceType":"script"}