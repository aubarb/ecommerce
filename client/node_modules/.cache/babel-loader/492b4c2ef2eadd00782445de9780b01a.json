{"ast":null,"code":"(function (undefined) {\n  var root = this; // Weird IE shit, objects do not have hasOwn, but the prototype does...\n\n  var hasOwnProp = Object.prototype.hasOwnProperty;\n\n  var reverseDupArray = function (array) {\n    var result = new Array(array.length);\n    var index = array.length;\n    var arrayMaxIndex = index - 1;\n\n    while (index--) {\n      result[arrayMaxIndex - index] = array[index];\n    }\n\n    return result;\n  };\n\n  var Dottie = function () {\n    var args = Array.prototype.slice.call(arguments);\n\n    if (args.length == 2) {\n      return Dottie.find.apply(this, args);\n    }\n\n    return Dottie.transform.apply(this, args);\n  }; // Legacy syntax, changed syntax to have get/set be similar in arg order\n\n\n  Dottie.find = function (path, object) {\n    return Dottie.get(object, path);\n  }; // Dottie memoization flag\n\n\n  Dottie.memoizePath = true;\n  var memoized = {}; // Traverse object according to path, return value if found - Return undefined if destination is unreachable\n\n  Dottie.get = function (object, path, defaultVal) {\n    if (object === undefined || object === null || path === undefined || path === null) {\n      return defaultVal;\n    }\n\n    var names;\n\n    if (typeof path === \"string\") {\n      if (Dottie.memoizePath) {\n        if (memoized[path]) {\n          names = memoized[path].slice(0);\n        } else {\n          names = path.split('.').reverse();\n          memoized[path] = names.slice(0);\n        }\n      } else {\n        names = path.split('.').reverse();\n      }\n    } else if (Array.isArray(path)) {\n      names = reverseDupArray(path);\n    }\n\n    while (names.length && (object = object[names.pop()]) !== undefined && object !== null); // Handle cases where accessing a childprop of a null value\n\n\n    if (object === null && names.length) object = undefined;\n    return object === undefined ? defaultVal : object;\n  };\n\n  Dottie.exists = function (object, path) {\n    return Dottie.get(object, path) !== undefined;\n  }; // Set nested value\n\n\n  Dottie.set = function (object, path, value, options) {\n    var pieces = Array.isArray(path) ? path : path.split('.'),\n        current = object,\n        piece,\n        length = pieces.length;\n\n    if (typeof current !== 'object') {\n      throw new Error('Parent is not an object.');\n    }\n\n    for (var index = 0; index < length; index++) {\n      piece = pieces[index]; // Create namespace (object) where none exists.\n      // If `force === true`, bruteforce the path without throwing errors.\n\n      if (!hasOwnProp.call(current, piece) || current[piece] === undefined || typeof current[piece] !== 'object' && options && options.force === true) {\n        current[piece] = {};\n      }\n\n      if (index == length - 1) {\n        // Set final value\n        current[piece] = value;\n      } else {\n        // We do not overwrite existing path pieces by default\n        if (typeof current[piece] !== 'object') {\n          throw new Error('Target key \"' + piece + '\" is not suitable for a nested value. (It is in use as non-object. Set `force` to `true` to override.)');\n        } // Traverse next in path\n\n\n        current = current[piece];\n      }\n    } // Is there any case when this is relevant? It's also the last line in the above for-loop\n\n\n    current[piece] = value;\n  }; // Set default nested value\n\n\n  Dottie['default'] = function (object, path, value) {\n    if (Dottie.get(object, path) === undefined) {\n      Dottie.set(object, path, value);\n    }\n  }; // Transform unnested object with .-seperated keys into a nested object.\n\n\n  Dottie.transform = function Dottie$transformfunction(object, options) {\n    if (Array.isArray(object)) {\n      return object.map(function (o) {\n        return Dottie.transform(o, options);\n      });\n    }\n\n    options = options || {};\n    options.delimiter = options.delimiter || '.';\n    var pieces,\n        piecesLength,\n        piece,\n        current,\n        transformed = {},\n        key,\n        keys = Object.keys(object),\n        length = keys.length,\n        i;\n\n    for (i = 0; i < length; i++) {\n      key = keys[i];\n\n      if (key.indexOf(options.delimiter) !== -1) {\n        pieces = key.split(options.delimiter);\n        piecesLength = pieces.length;\n        current = transformed;\n\n        for (var index = 0; index < piecesLength; index++) {\n          piece = pieces[index];\n\n          if (index != piecesLength - 1 && !current.hasOwnProperty(piece)) {\n            current[piece] = {};\n          }\n\n          if (index == piecesLength - 1) {\n            current[piece] = object[key];\n          }\n\n          current = current[piece];\n\n          if (current === null) {\n            break;\n          }\n        }\n      } else {\n        transformed[key] = object[key];\n      }\n    }\n\n    return transformed;\n  };\n\n  Dottie.flatten = function (object, seperator) {\n    if (typeof seperator === \"undefined\") seperator = '.';\n    var flattened = {},\n        current,\n        nested;\n\n    for (var key in object) {\n      if (hasOwnProp.call(object, key)) {\n        current = object[key];\n\n        if (Object.prototype.toString.call(current) === \"[object Object]\") {\n          nested = Dottie.flatten(current, seperator);\n\n          for (var _key in nested) {\n            flattened[key + seperator + _key] = nested[_key];\n          }\n        } else {\n          flattened[key] = current;\n        }\n      }\n    }\n\n    return flattened;\n  };\n\n  Dottie.paths = function (object, prefixes) {\n    var paths = [];\n    var value;\n    var key;\n    prefixes = prefixes || [];\n\n    if (typeof object === 'object') {\n      for (key in object) {\n        value = object[key];\n\n        if (typeof value === 'object' && value !== null) {\n          paths = paths.concat(Dottie.paths(value, prefixes.concat([key])));\n        } else {\n          paths.push(prefixes.concat(key).join('.'));\n        }\n      }\n    } else {\n      throw new Error('Paths was called with non-object argument.');\n    }\n\n    return paths;\n  };\n\n  if (typeof module !== 'undefined' && module.exports) {\n    exports = module.exports = Dottie;\n  } else {\n    root['Dottie'] = Dottie;\n    root['Dot'] = Dottie; //BC\n\n    if (typeof define === \"function\") {\n      define([], function () {\n        return Dottie;\n      });\n    }\n  }\n})();","map":{"version":3,"names":["undefined","root","hasOwnProp","Object","prototype","hasOwnProperty","reverseDupArray","array","result","Array","length","index","arrayMaxIndex","Dottie","args","slice","call","arguments","find","apply","transform","path","object","get","memoizePath","memoized","defaultVal","names","split","reverse","isArray","pop","exists","set","value","options","pieces","current","piece","Error","force","Dottie$transformfunction","map","o","delimiter","piecesLength","transformed","key","keys","i","indexOf","flatten","seperator","flattened","nested","toString","_key","paths","prefixes","concat","push","join","module","exports","define"],"sources":["/Users/aurele/node_modules/dottie/dottie.js"],"sourcesContent":["(function(undefined) {\n  var root = this;\n\n  // Weird IE shit, objects do not have hasOwn, but the prototype does...\n  var hasOwnProp = Object.prototype.hasOwnProperty;\n\n  var reverseDupArray = function (array) {\n    var result = new Array(array.length);\n    var index  = array.length;\n    var arrayMaxIndex = index - 1;\n\n    while (index--) {\n      result[arrayMaxIndex - index] = array[index];\n    }\n\n    return result;\n  };\n\n  var Dottie = function() {\n    var args = Array.prototype.slice.call(arguments);\n\n    if (args.length == 2) {\n      return Dottie.find.apply(this, args);\n    }\n    return Dottie.transform.apply(this, args);\n  };\n\n  // Legacy syntax, changed syntax to have get/set be similar in arg order\n  Dottie.find = function(path, object) {\n    return Dottie.get(object, path);\n  };\n\n  // Dottie memoization flag\n  Dottie.memoizePath = true;\n  var memoized = {};\n\n  // Traverse object according to path, return value if found - Return undefined if destination is unreachable\n  Dottie.get = function(object, path, defaultVal) {\n    if ((object === undefined) || (object === null) || (path === undefined) || (path === null)) {\n        return defaultVal;\n    }\n\n    var names;\n\n    if (typeof path === \"string\") {\n      if (Dottie.memoizePath) {\n        if (memoized[path]) {\n          names = memoized[path].slice(0);\n        } else {\n          names = path.split('.').reverse();\n          memoized[path] = names.slice(0);\n        }\n      } else {\n        names = path.split('.').reverse();\n      }\n    } else if (Array.isArray(path)) {\n      names = reverseDupArray(path);\n    }\n\n    while (names.length && (object = object[names.pop()]) !== undefined && object !== null);\n\n    // Handle cases where accessing a childprop of a null value\n    if (object === null && names.length) object = undefined;\n\n    return (object === undefined ? defaultVal : object);\n  };\n\n  Dottie.exists = function(object, path) {\n    return Dottie.get(object, path) !== undefined;\n  };\n\n  // Set nested value\n  Dottie.set = function(object, path, value, options) {\n    var pieces = Array.isArray(path) ? path : path.split('.'), current = object, piece, length = pieces.length;\n\n    if (typeof current !== 'object') {\n        throw new Error('Parent is not an object.');\n    }\n\n    for (var index = 0; index < length; index++) {\n      piece = pieces[index];\n\n      // Create namespace (object) where none exists.\n      // If `force === true`, bruteforce the path without throwing errors.\n      if (!hasOwnProp.call(current, piece) || current[piece] === undefined || (typeof current[piece] !== 'object' && options && options.force === true)) {\n        current[piece] = {};\n      }\n\n      if (index == (length - 1)) {\n        // Set final value\n        current[piece] = value;\n      } else {\n        // We do not overwrite existing path pieces by default\n        if (typeof current[piece] !== 'object') {\n          throw new Error('Target key \"' + piece + '\" is not suitable for a nested value. (It is in use as non-object. Set `force` to `true` to override.)');\n        }\n\n        // Traverse next in path\n        current = current[piece];\n      }\n    }\n\n    // Is there any case when this is relevant? It's also the last line in the above for-loop\n    current[piece] = value;\n  };\n\n  // Set default nested value\n  Dottie['default'] = function(object, path, value) {\n    if (Dottie.get(object, path) === undefined) {\n      Dottie.set(object, path, value);\n    }\n  };\n\n  // Transform unnested object with .-seperated keys into a nested object.\n  Dottie.transform = function Dottie$transformfunction(object, options) {\n    if (Array.isArray(object)) {\n      return object.map(function(o) {\n        return Dottie.transform(o, options);\n      });\n    }\n\n    options = options || {};\n    options.delimiter = options.delimiter || '.';\n\n    var pieces\n      , piecesLength\n      , piece\n      , current\n      , transformed = {}\n      , key\n      , keys = Object.keys(object)\n      , length = keys.length\n      , i;\n\n    for (i = 0; i < length; i++) {\n      key = keys[i];\n\n      if (key.indexOf(options.delimiter) !== -1) {\n        pieces = key.split(options.delimiter);\n        piecesLength = pieces.length;\n        current = transformed;\n\n        for (var index = 0; index < piecesLength; index++) {\n          piece = pieces[index];\n          if (index != (piecesLength - 1) && !current.hasOwnProperty(piece)) {\n            current[piece] = {};\n          }\n\n          if (index == (piecesLength - 1)) {\n            current[piece] = object[key];\n          }\n\n          current = current[piece];\n          if (current === null) {\n            break;\n          }\n        }\n      } else {\n        transformed[key] = object[key];\n      }\n    }\n\n    return transformed;\n  };\n\n  Dottie.flatten = function(object, seperator) {\n    if (typeof seperator === \"undefined\") seperator = '.';\n    var flattened = {}\n      , current\n      , nested;\n\n    for (var key in object) {\n      if (hasOwnProp.call(object, key)) {\n        current = object[key];\n        if (Object.prototype.toString.call(current) === \"[object Object]\") {\n          nested = Dottie.flatten(current, seperator);\n\n          for (var _key in nested) {\n            flattened[key+seperator+_key] = nested[_key];\n          }\n        } else {\n          flattened[key] = current;\n        }\n      }\n    }\n\n    return flattened;\n  };\n\n  Dottie.paths = function(object, prefixes) {\n    var paths = [];\n    var value;\n    var key;\n\n    prefixes = prefixes || [];\n\n    if (typeof object === 'object') {\n      for (key in object) {\n        value = object[key];\n\n        if (typeof value === 'object' && value !== null) {\n          paths = paths.concat(Dottie.paths(value, prefixes.concat([key])));\n        } else {\n          paths.push(prefixes.concat(key).join('.'));\n        }\n      }\n    } else {\n      throw new Error('Paths was called with non-object argument.');\n    }\n\n    return paths;\n  };\n\n  if (typeof module !== 'undefined' && module.exports) {\n    exports = module.exports = Dottie;\n  } else {\n    root['Dottie'] = Dottie;\n    root['Dot'] = Dottie; //BC\n\n    if (typeof define === \"function\") {\n      define([], function () { return Dottie; });\n    }\n  }\n})();\n"],"mappings":"AAAA,CAAC,UAASA,SAAT,EAAoB;EACnB,IAAIC,IAAI,GAAG,IAAX,CADmB,CAGnB;;EACA,IAAIC,UAAU,GAAGC,MAAM,CAACC,SAAP,CAAiBC,cAAlC;;EAEA,IAAIC,eAAe,GAAG,UAAUC,KAAV,EAAiB;IACrC,IAAIC,MAAM,GAAG,IAAIC,KAAJ,CAAUF,KAAK,CAACG,MAAhB,CAAb;IACA,IAAIC,KAAK,GAAIJ,KAAK,CAACG,MAAnB;IACA,IAAIE,aAAa,GAAGD,KAAK,GAAG,CAA5B;;IAEA,OAAOA,KAAK,EAAZ,EAAgB;MACdH,MAAM,CAACI,aAAa,GAAGD,KAAjB,CAAN,GAAgCJ,KAAK,CAACI,KAAD,CAArC;IACD;;IAED,OAAOH,MAAP;EACD,CAVD;;EAYA,IAAIK,MAAM,GAAG,YAAW;IACtB,IAAIC,IAAI,GAAGL,KAAK,CAACL,SAAN,CAAgBW,KAAhB,CAAsBC,IAAtB,CAA2BC,SAA3B,CAAX;;IAEA,IAAIH,IAAI,CAACJ,MAAL,IAAe,CAAnB,EAAsB;MACpB,OAAOG,MAAM,CAACK,IAAP,CAAYC,KAAZ,CAAkB,IAAlB,EAAwBL,IAAxB,CAAP;IACD;;IACD,OAAOD,MAAM,CAACO,SAAP,CAAiBD,KAAjB,CAAuB,IAAvB,EAA6BL,IAA7B,CAAP;EACD,CAPD,CAlBmB,CA2BnB;;;EACAD,MAAM,CAACK,IAAP,GAAc,UAASG,IAAT,EAAeC,MAAf,EAAuB;IACnC,OAAOT,MAAM,CAACU,GAAP,CAAWD,MAAX,EAAmBD,IAAnB,CAAP;EACD,CAFD,CA5BmB,CAgCnB;;;EACAR,MAAM,CAACW,WAAP,GAAqB,IAArB;EACA,IAAIC,QAAQ,GAAG,EAAf,CAlCmB,CAoCnB;;EACAZ,MAAM,CAACU,GAAP,GAAa,UAASD,MAAT,EAAiBD,IAAjB,EAAuBK,UAAvB,EAAmC;IAC9C,IAAKJ,MAAM,KAAKtB,SAAZ,IAA2BsB,MAAM,KAAK,IAAtC,IAAgDD,IAAI,KAAKrB,SAAzD,IAAwEqB,IAAI,KAAK,IAArF,EAA4F;MACxF,OAAOK,UAAP;IACH;;IAED,IAAIC,KAAJ;;IAEA,IAAI,OAAON,IAAP,KAAgB,QAApB,EAA8B;MAC5B,IAAIR,MAAM,CAACW,WAAX,EAAwB;QACtB,IAAIC,QAAQ,CAACJ,IAAD,CAAZ,EAAoB;UAClBM,KAAK,GAAGF,QAAQ,CAACJ,IAAD,CAAR,CAAeN,KAAf,CAAqB,CAArB,CAAR;QACD,CAFD,MAEO;UACLY,KAAK,GAAGN,IAAI,CAACO,KAAL,CAAW,GAAX,EAAgBC,OAAhB,EAAR;UACAJ,QAAQ,CAACJ,IAAD,CAAR,GAAiBM,KAAK,CAACZ,KAAN,CAAY,CAAZ,CAAjB;QACD;MACF,CAPD,MAOO;QACLY,KAAK,GAAGN,IAAI,CAACO,KAAL,CAAW,GAAX,EAAgBC,OAAhB,EAAR;MACD;IACF,CAXD,MAWO,IAAIpB,KAAK,CAACqB,OAAN,CAAcT,IAAd,CAAJ,EAAyB;MAC9BM,KAAK,GAAGrB,eAAe,CAACe,IAAD,CAAvB;IACD;;IAED,OAAOM,KAAK,CAACjB,MAAN,IAAgB,CAACY,MAAM,GAAGA,MAAM,CAACK,KAAK,CAACI,GAAN,EAAD,CAAhB,MAAmC/B,SAAnD,IAAgEsB,MAAM,KAAK,IAAlF,CAAuF,CAtBzC,CAwB9C;;;IACA,IAAIA,MAAM,KAAK,IAAX,IAAmBK,KAAK,CAACjB,MAA7B,EAAqCY,MAAM,GAAGtB,SAAT;IAErC,OAAQsB,MAAM,KAAKtB,SAAX,GAAuB0B,UAAvB,GAAoCJ,MAA5C;EACD,CA5BD;;EA8BAT,MAAM,CAACmB,MAAP,GAAgB,UAASV,MAAT,EAAiBD,IAAjB,EAAuB;IACrC,OAAOR,MAAM,CAACU,GAAP,CAAWD,MAAX,EAAmBD,IAAnB,MAA6BrB,SAApC;EACD,CAFD,CAnEmB,CAuEnB;;;EACAa,MAAM,CAACoB,GAAP,GAAa,UAASX,MAAT,EAAiBD,IAAjB,EAAuBa,KAAvB,EAA8BC,OAA9B,EAAuC;IAClD,IAAIC,MAAM,GAAG3B,KAAK,CAACqB,OAAN,CAAcT,IAAd,IAAsBA,IAAtB,GAA6BA,IAAI,CAACO,KAAL,CAAW,GAAX,CAA1C;IAAA,IAA2DS,OAAO,GAAGf,MAArE;IAAA,IAA6EgB,KAA7E;IAAA,IAAoF5B,MAAM,GAAG0B,MAAM,CAAC1B,MAApG;;IAEA,IAAI,OAAO2B,OAAP,KAAmB,QAAvB,EAAiC;MAC7B,MAAM,IAAIE,KAAJ,CAAU,0BAAV,CAAN;IACH;;IAED,KAAK,IAAI5B,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGD,MAA5B,EAAoCC,KAAK,EAAzC,EAA6C;MAC3C2B,KAAK,GAAGF,MAAM,CAACzB,KAAD,CAAd,CAD2C,CAG3C;MACA;;MACA,IAAI,CAACT,UAAU,CAACc,IAAX,CAAgBqB,OAAhB,EAAyBC,KAAzB,CAAD,IAAoCD,OAAO,CAACC,KAAD,CAAP,KAAmBtC,SAAvD,IAAqE,OAAOqC,OAAO,CAACC,KAAD,CAAd,KAA0B,QAA1B,IAAsCH,OAAtC,IAAiDA,OAAO,CAACK,KAAR,KAAkB,IAA5I,EAAmJ;QACjJH,OAAO,CAACC,KAAD,CAAP,GAAiB,EAAjB;MACD;;MAED,IAAI3B,KAAK,IAAKD,MAAM,GAAG,CAAvB,EAA2B;QACzB;QACA2B,OAAO,CAACC,KAAD,CAAP,GAAiBJ,KAAjB;MACD,CAHD,MAGO;QACL;QACA,IAAI,OAAOG,OAAO,CAACC,KAAD,CAAd,KAA0B,QAA9B,EAAwC;UACtC,MAAM,IAAIC,KAAJ,CAAU,iBAAiBD,KAAjB,GAAyB,wGAAnC,CAAN;QACD,CAJI,CAML;;;QACAD,OAAO,GAAGA,OAAO,CAACC,KAAD,CAAjB;MACD;IACF,CA5BiD,CA8BlD;;;IACAD,OAAO,CAACC,KAAD,CAAP,GAAiBJ,KAAjB;EACD,CAhCD,CAxEmB,CA0GnB;;;EACArB,MAAM,CAAC,SAAD,CAAN,GAAoB,UAASS,MAAT,EAAiBD,IAAjB,EAAuBa,KAAvB,EAA8B;IAChD,IAAIrB,MAAM,CAACU,GAAP,CAAWD,MAAX,EAAmBD,IAAnB,MAA6BrB,SAAjC,EAA4C;MAC1Ca,MAAM,CAACoB,GAAP,CAAWX,MAAX,EAAmBD,IAAnB,EAAyBa,KAAzB;IACD;EACF,CAJD,CA3GmB,CAiHnB;;;EACArB,MAAM,CAACO,SAAP,GAAmB,SAASqB,wBAAT,CAAkCnB,MAAlC,EAA0Ca,OAA1C,EAAmD;IACpE,IAAI1B,KAAK,CAACqB,OAAN,CAAcR,MAAd,CAAJ,EAA2B;MACzB,OAAOA,MAAM,CAACoB,GAAP,CAAW,UAASC,CAAT,EAAY;QAC5B,OAAO9B,MAAM,CAACO,SAAP,CAAiBuB,CAAjB,EAAoBR,OAApB,CAAP;MACD,CAFM,CAAP;IAGD;;IAEDA,OAAO,GAAGA,OAAO,IAAI,EAArB;IACAA,OAAO,CAACS,SAAR,GAAoBT,OAAO,CAACS,SAAR,IAAqB,GAAzC;IAEA,IAAIR,MAAJ;IAAA,IACIS,YADJ;IAAA,IAEIP,KAFJ;IAAA,IAGID,OAHJ;IAAA,IAIIS,WAAW,GAAG,EAJlB;IAAA,IAKIC,GALJ;IAAA,IAMIC,IAAI,GAAG7C,MAAM,CAAC6C,IAAP,CAAY1B,MAAZ,CANX;IAAA,IAOIZ,MAAM,GAAGsC,IAAI,CAACtC,MAPlB;IAAA,IAQIuC,CARJ;;IAUA,KAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGvC,MAAhB,EAAwBuC,CAAC,EAAzB,EAA6B;MAC3BF,GAAG,GAAGC,IAAI,CAACC,CAAD,CAAV;;MAEA,IAAIF,GAAG,CAACG,OAAJ,CAAYf,OAAO,CAACS,SAApB,MAAmC,CAAC,CAAxC,EAA2C;QACzCR,MAAM,GAAGW,GAAG,CAACnB,KAAJ,CAAUO,OAAO,CAACS,SAAlB,CAAT;QACAC,YAAY,GAAGT,MAAM,CAAC1B,MAAtB;QACA2B,OAAO,GAAGS,WAAV;;QAEA,KAAK,IAAInC,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGkC,YAA5B,EAA0ClC,KAAK,EAA/C,EAAmD;UACjD2B,KAAK,GAAGF,MAAM,CAACzB,KAAD,CAAd;;UACA,IAAIA,KAAK,IAAKkC,YAAY,GAAG,CAAzB,IAA+B,CAACR,OAAO,CAAChC,cAAR,CAAuBiC,KAAvB,CAApC,EAAmE;YACjED,OAAO,CAACC,KAAD,CAAP,GAAiB,EAAjB;UACD;;UAED,IAAI3B,KAAK,IAAKkC,YAAY,GAAG,CAA7B,EAAiC;YAC/BR,OAAO,CAACC,KAAD,CAAP,GAAiBhB,MAAM,CAACyB,GAAD,CAAvB;UACD;;UAEDV,OAAO,GAAGA,OAAO,CAACC,KAAD,CAAjB;;UACA,IAAID,OAAO,KAAK,IAAhB,EAAsB;YACpB;UACD;QACF;MACF,CApBD,MAoBO;QACLS,WAAW,CAACC,GAAD,CAAX,GAAmBzB,MAAM,CAACyB,GAAD,CAAzB;MACD;IACF;;IAED,OAAOD,WAAP;EACD,CAjDD;;EAmDAjC,MAAM,CAACsC,OAAP,GAAiB,UAAS7B,MAAT,EAAiB8B,SAAjB,EAA4B;IAC3C,IAAI,OAAOA,SAAP,KAAqB,WAAzB,EAAsCA,SAAS,GAAG,GAAZ;IACtC,IAAIC,SAAS,GAAG,EAAhB;IAAA,IACIhB,OADJ;IAAA,IAEIiB,MAFJ;;IAIA,KAAK,IAAIP,GAAT,IAAgBzB,MAAhB,EAAwB;MACtB,IAAIpB,UAAU,CAACc,IAAX,CAAgBM,MAAhB,EAAwByB,GAAxB,CAAJ,EAAkC;QAChCV,OAAO,GAAGf,MAAM,CAACyB,GAAD,CAAhB;;QACA,IAAI5C,MAAM,CAACC,SAAP,CAAiBmD,QAAjB,CAA0BvC,IAA1B,CAA+BqB,OAA/B,MAA4C,iBAAhD,EAAmE;UACjEiB,MAAM,GAAGzC,MAAM,CAACsC,OAAP,CAAed,OAAf,EAAwBe,SAAxB,CAAT;;UAEA,KAAK,IAAII,IAAT,IAAiBF,MAAjB,EAAyB;YACvBD,SAAS,CAACN,GAAG,GAACK,SAAJ,GAAcI,IAAf,CAAT,GAAgCF,MAAM,CAACE,IAAD,CAAtC;UACD;QACF,CAND,MAMO;UACLH,SAAS,CAACN,GAAD,CAAT,GAAiBV,OAAjB;QACD;MACF;IACF;;IAED,OAAOgB,SAAP;EACD,CAtBD;;EAwBAxC,MAAM,CAAC4C,KAAP,GAAe,UAASnC,MAAT,EAAiBoC,QAAjB,EAA2B;IACxC,IAAID,KAAK,GAAG,EAAZ;IACA,IAAIvB,KAAJ;IACA,IAAIa,GAAJ;IAEAW,QAAQ,GAAGA,QAAQ,IAAI,EAAvB;;IAEA,IAAI,OAAOpC,MAAP,KAAkB,QAAtB,EAAgC;MAC9B,KAAKyB,GAAL,IAAYzB,MAAZ,EAAoB;QAClBY,KAAK,GAAGZ,MAAM,CAACyB,GAAD,CAAd;;QAEA,IAAI,OAAOb,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAA3C,EAAiD;UAC/CuB,KAAK,GAAGA,KAAK,CAACE,MAAN,CAAa9C,MAAM,CAAC4C,KAAP,CAAavB,KAAb,EAAoBwB,QAAQ,CAACC,MAAT,CAAgB,CAACZ,GAAD,CAAhB,CAApB,CAAb,CAAR;QACD,CAFD,MAEO;UACLU,KAAK,CAACG,IAAN,CAAWF,QAAQ,CAACC,MAAT,CAAgBZ,GAAhB,EAAqBc,IAArB,CAA0B,GAA1B,CAAX;QACD;MACF;IACF,CAVD,MAUO;MACL,MAAM,IAAItB,KAAJ,CAAU,4CAAV,CAAN;IACD;;IAED,OAAOkB,KAAP;EACD,CAtBD;;EAwBA,IAAI,OAAOK,MAAP,KAAkB,WAAlB,IAAiCA,MAAM,CAACC,OAA5C,EAAqD;IACnDA,OAAO,GAAGD,MAAM,CAACC,OAAP,GAAiBlD,MAA3B;EACD,CAFD,MAEO;IACLZ,IAAI,CAAC,QAAD,CAAJ,GAAiBY,MAAjB;IACAZ,IAAI,CAAC,KAAD,CAAJ,GAAcY,MAAd,CAFK,CAEiB;;IAEtB,IAAI,OAAOmD,MAAP,KAAkB,UAAtB,EAAkC;MAChCA,MAAM,CAAC,EAAD,EAAK,YAAY;QAAE,OAAOnD,MAAP;MAAgB,CAAnC,CAAN;IACD;EACF;AACF,CA/ND"},"metadata":{},"sourceType":"script"}