{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\n\nfunction stringifyRangeBound(bound) {\n  if (bound === null) {\n    return \"\";\n  }\n\n  if (bound === Infinity || bound === -Infinity) {\n    return bound.toString().toLowerCase();\n  }\n\n  return JSON.stringify(bound);\n}\n\nfunction parseRangeBound(bound, parseType) {\n  if (!bound) {\n    return null;\n  }\n\n  if (bound === \"infinity\") {\n    return Infinity;\n  }\n\n  if (bound === \"-infinity\") {\n    return -Infinity;\n  }\n\n  return parseType(bound);\n}\n\nfunction stringify(data) {\n  if (data === null) return null;\n  if (!Array.isArray(data)) throw new Error(\"range must be an array\");\n  if (!data.length) return \"empty\";\n  if (data.length !== 2) throw new Error(\"range array length must be 0 (empty) or 2 (lower and upper bounds)\");\n\n  if (Object.prototype.hasOwnProperty.call(data, \"inclusive\")) {\n    if (data.inclusive === false) data.inclusive = [false, false];else if (!data.inclusive) data.inclusive = [true, false];else if (data.inclusive === true) data.inclusive = [true, true];\n  } else {\n    data.inclusive = [true, false];\n  }\n\n  _.each(data, (value, index) => {\n    if (_.isObject(value)) {\n      if (Object.prototype.hasOwnProperty.call(value, \"inclusive\")) data.inclusive[index] = !!value.inclusive;\n      if (Object.prototype.hasOwnProperty.call(value, \"value\")) data[index] = value.value;\n    }\n  });\n\n  const lowerBound = stringifyRangeBound(data[0]);\n  const upperBound = stringifyRangeBound(data[1]);\n  return `${(data.inclusive[0] ? \"[\" : \"(\") + lowerBound},${upperBound}${data.inclusive[1] ? \"]\" : \")\"}`;\n}\n\nexports.stringify = stringify;\n\nfunction parse(value, parser) {\n  if (value === null) return null;\n\n  if (value === \"empty\") {\n    return [];\n  }\n\n  let result = value.substring(1, value.length - 1).split(\",\", 2);\n  if (result.length !== 2) return value;\n  result = result.map((item, index) => {\n    return {\n      value: parseRangeBound(item, parser),\n      inclusive: index === 0 ? value[0] === \"[\" : value[value.length - 1] === \"]\"\n    };\n  });\n  return result;\n}\n\nexports.parse = parse;","map":{"version":3,"mappings":"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","names":["_","require","bound","Infinity","toString","toLowerCase","JSON","stringify","parseType","data","Array","isArray","Error","length","Object","prototype","hasOwnProperty","call","inclusive","each","value","index","isObject","lowerBound","stringifyRangeBound","upperBound","exports","parser","result","substring","split","map","item","parseRangeBound","parse"],"sources":["/Users/aurele/node_modules/sequelize/src/dialects/postgres/range.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\n\nfunction stringifyRangeBound(bound) {\n  if (bound === null) {\n    return '' ;\n  }\n  if (bound === Infinity || bound === -Infinity) {\n    return bound.toString().toLowerCase();\n  }\n  return JSON.stringify(bound);\n}\n\nfunction parseRangeBound(bound, parseType) {\n  if (!bound) {\n    return null;\n  }\n  if (bound === 'infinity') {\n    return Infinity;\n  }\n  if (bound === '-infinity') {\n    return -Infinity;\n  }\n  return parseType(bound);\n\n}\n\nfunction stringify(data) {\n  if (data === null) return null;\n\n  if (!Array.isArray(data)) throw new Error('range must be an array');\n  if (!data.length) return 'empty';\n  if (data.length !== 2) throw new Error('range array length must be 0 (empty) or 2 (lower and upper bounds)');\n\n  if (Object.prototype.hasOwnProperty.call(data, 'inclusive')) {\n    if (data.inclusive === false) data.inclusive = [false, false];\n    else if (!data.inclusive) data.inclusive = [true, false];\n    else if (data.inclusive === true) data.inclusive = [true, true];\n  } else {\n    data.inclusive = [true, false];\n  }\n\n  _.each(data, (value, index) => {\n    if (_.isObject(value)) {\n      if (Object.prototype.hasOwnProperty.call(value, 'inclusive')) data.inclusive[index] = !!value.inclusive;\n      if (Object.prototype.hasOwnProperty.call(value, 'value')) data[index] = value.value;\n    }\n  });\n\n  const lowerBound = stringifyRangeBound(data[0]);\n  const upperBound = stringifyRangeBound(data[1]);\n\n  return `${(data.inclusive[0] ? '[' : '(') + lowerBound},${upperBound}${data.inclusive[1] ? ']' : ')'}`;\n}\nexports.stringify = stringify;\n\nfunction parse(value, parser) {\n  if (value === null) return null;\n  if (value === 'empty') {\n    return [];\n  }\n\n  let result = value\n    .substring(1, value.length - 1)\n    .split(',', 2);\n\n  if (result.length !== 2) return value;\n\n  result = result.map((item, index) => {\n    return {\n      value: parseRangeBound(item, parser),\n      inclusive: index === 0 ? value[0] === '[' : value[value.length - 1] === ']'\n    };\n  });\n\n  return result;\n}\nexports.parse = parse;\n"]},"metadata":{},"sourceType":"script"}