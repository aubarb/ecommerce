{"ast":null,"code":"'use strict'; // Tar can encode large and negative numbers using a leading byte of\n// 0xff for negative, and 0x80 for positive.\n\nconst encode = (num, buf) => {\n  if (!Number.isSafeInteger(num)) {\n    // The number is so large that javascript cannot represent it with integer\n    // precision.\n    throw Error('cannot encode number outside of javascript safe integer range');\n  } else if (num < 0) {\n    encodeNegative(num, buf);\n  } else {\n    encodePositive(num, buf);\n  }\n\n  return buf;\n};\n\nconst encodePositive = (num, buf) => {\n  buf[0] = 0x80;\n\n  for (var i = buf.length; i > 1; i--) {\n    buf[i - 1] = num & 0xff;\n    num = Math.floor(num / 0x100);\n  }\n};\n\nconst encodeNegative = (num, buf) => {\n  buf[0] = 0xff;\n  var flipped = false;\n  num = num * -1;\n\n  for (var i = buf.length; i > 1; i--) {\n    var byte = num & 0xff;\n    num = Math.floor(num / 0x100);\n\n    if (flipped) {\n      buf[i - 1] = onesComp(byte);\n    } else if (byte === 0) {\n      buf[i - 1] = 0;\n    } else {\n      flipped = true;\n      buf[i - 1] = twosComp(byte);\n    }\n  }\n};\n\nconst parse = buf => {\n  const pre = buf[0];\n  const value = pre === 0x80 ? pos(buf.slice(1, buf.length)) : pre === 0xff ? twos(buf) : null;\n\n  if (value === null) {\n    throw Error('invalid base256 encoding');\n  }\n\n  if (!Number.isSafeInteger(value)) {\n    // The number is so large that javascript cannot represent it with integer\n    // precision.\n    throw Error('parsed number outside of javascript safe integer range');\n  }\n\n  return value;\n};\n\nconst twos = buf => {\n  var len = buf.length;\n  var sum = 0;\n  var flipped = false;\n\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i];\n    var f;\n\n    if (flipped) {\n      f = onesComp(byte);\n    } else if (byte === 0) {\n      f = byte;\n    } else {\n      flipped = true;\n      f = twosComp(byte);\n    }\n\n    if (f !== 0) {\n      sum -= f * Math.pow(256, len - i - 1);\n    }\n  }\n\n  return sum;\n};\n\nconst pos = buf => {\n  var len = buf.length;\n  var sum = 0;\n\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i];\n\n    if (byte !== 0) {\n      sum += byte * Math.pow(256, len - i - 1);\n    }\n  }\n\n  return sum;\n};\n\nconst onesComp = byte => (0xff ^ byte) & 0xff;\n\nconst twosComp = byte => (0xff ^ byte) + 1 & 0xff;\n\nmodule.exports = {\n  encode,\n  parse\n};","map":{"version":3,"names":["encode","num","buf","Number","isSafeInteger","Error","encodeNegative","encodePositive","i","length","Math","floor","flipped","byte","onesComp","twosComp","parse","pre","value","pos","slice","twos","len","sum","f","pow","module","exports"],"sources":["/Users/aurele/Desktop/E-Commerce App/views/node_modules/tar/lib/large-numbers.js"],"sourcesContent":["'use strict'\n// Tar can encode large and negative numbers using a leading byte of\n// 0xff for negative, and 0x80 for positive.\n\nconst encode = (num, buf) => {\n  if (!Number.isSafeInteger(num)) {\n  // The number is so large that javascript cannot represent it with integer\n  // precision.\n    throw Error('cannot encode number outside of javascript safe integer range')\n  } else if (num < 0) {\n    encodeNegative(num, buf)\n  } else {\n    encodePositive(num, buf)\n  }\n  return buf\n}\n\nconst encodePositive = (num, buf) => {\n  buf[0] = 0x80\n\n  for (var i = buf.length; i > 1; i--) {\n    buf[i - 1] = num & 0xff\n    num = Math.floor(num / 0x100)\n  }\n}\n\nconst encodeNegative = (num, buf) => {\n  buf[0] = 0xff\n  var flipped = false\n  num = num * -1\n  for (var i = buf.length; i > 1; i--) {\n    var byte = num & 0xff\n    num = Math.floor(num / 0x100)\n    if (flipped) {\n      buf[i - 1] = onesComp(byte)\n    } else if (byte === 0) {\n      buf[i - 1] = 0\n    } else {\n      flipped = true\n      buf[i - 1] = twosComp(byte)\n    }\n  }\n}\n\nconst parse = (buf) => {\n  const pre = buf[0]\n  const value = pre === 0x80 ? pos(buf.slice(1, buf.length))\n    : pre === 0xff ? twos(buf)\n    : null\n  if (value === null) {\n    throw Error('invalid base256 encoding')\n  }\n\n  if (!Number.isSafeInteger(value)) {\n  // The number is so large that javascript cannot represent it with integer\n  // precision.\n    throw Error('parsed number outside of javascript safe integer range')\n  }\n\n  return value\n}\n\nconst twos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  var flipped = false\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    var f\n    if (flipped) {\n      f = onesComp(byte)\n    } else if (byte === 0) {\n      f = byte\n    } else {\n      flipped = true\n      f = twosComp(byte)\n    }\n    if (f !== 0) {\n      sum -= f * Math.pow(256, len - i - 1)\n    }\n  }\n  return sum\n}\n\nconst pos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    if (byte !== 0) {\n      sum += byte * Math.pow(256, len - i - 1)\n    }\n  }\n  return sum\n}\n\nconst onesComp = byte => (0xff ^ byte) & 0xff\n\nconst twosComp = byte => ((0xff ^ byte) + 1) & 0xff\n\nmodule.exports = {\n  encode,\n  parse,\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}