{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nconst _ = require(\"lodash\");\n\nconst Utils = require(\"../../utils\");\n\nconst AbstractQueryGenerator = require(\"../abstract/query-generator\");\n\nconst util = require(\"util\");\n\nconst Op = require(\"../../operators\");\n\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nconst FOREIGN_KEY_FIELDS = [\"CONSTRAINT_NAME as constraint_name\", \"CONSTRAINT_NAME as constraintName\", \"CONSTRAINT_SCHEMA as constraintSchema\", \"CONSTRAINT_SCHEMA as constraintCatalog\", \"TABLE_NAME as tableName\", \"TABLE_SCHEMA as tableSchema\", \"TABLE_SCHEMA as tableCatalog\", \"COLUMN_NAME as columnName\", \"REFERENCED_TABLE_SCHEMA as referencedTableSchema\", \"REFERENCED_TABLE_SCHEMA as referencedTableCatalog\", \"REFERENCED_TABLE_NAME as referencedTableName\", \"REFERENCED_COLUMN_NAME as referencedColumnName\"].join(\",\");\nconst typeWithoutDefault = /* @__PURE__ */new Set([\"BLOB\", \"TEXT\", \"GEOMETRY\", \"JSON\"]);\n\nclass MySQLQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n    this.OperatorMap = __spreadProps(__spreadValues({}, this.OperatorMap), {\n      [Op.regexp]: \"REGEXP\",\n      [Op.notRegexp]: \"NOT REGEXP\"\n    });\n  }\n\n  createDatabaseQuery(databaseName, options) {\n    options = __spreadValues({\n      charset: null,\n      collate: null\n    }, options);\n    return Utils.joinSQLFragments([\"CREATE DATABASE IF NOT EXISTS\", this.quoteIdentifier(databaseName), options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`, options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`, \";\"]);\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName)};`;\n  }\n\n  createSchema() {\n    return \"SHOW TABLES\";\n  }\n\n  showSchemasQuery() {\n    return \"SHOW TABLES\";\n  }\n\n  versionQuery() {\n    return \"SELECT VERSION() as `version`\";\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = __spreadValues({\n      engine: \"InnoDB\",\n      charset: null,\n      rowFormat: null\n    }, options);\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n\n    for (const attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n      const dataType = attributes[attr];\n      let match;\n\n      if (dataType.includes(\"PRIMARY KEY\")) {\n        primaryKeys.push(attr);\n\n        if (dataType.includes(\"REFERENCES\")) {\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace(\"PRIMARY KEY\", \"\")}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace(\"PRIMARY KEY\", \"\")}`);\n        }\n      } else if (dataType.includes(\"REFERENCES\")) {\n        match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attributesClause = attrStr.join(\", \");\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(\", \");\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== \"string\") {\n            indexName = `uniq_${tableName}_${columns.fields.join(\"_\")}`;\n          }\n\n          attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map(field => this.quoteIdentifier(field)).join(\", \")})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pkString})`;\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n\n    return Utils.joinSQLFragments([\"CREATE TABLE IF NOT EXISTS\", table, `(${attributesClause})`, `ENGINE=${options.engine}`, options.comment && typeof options.comment === \"string\" && `COMMENT ${this.escape(options.comment)}`, options.charset && `DEFAULT CHARSET=${options.charset}`, options.collate && `COLLATE ${options.collate}`, options.initialAutoIncrement && `AUTO_INCREMENT=${options.initialAutoIncrement}`, options.rowFormat && `ROW_FORMAT=${options.rowFormat}`, \";\"]);\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(this.addSchema({\n      tableName,\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter\n    }));\n    return `SHOW FULL COLUMNS FROM ${table};`;\n  }\n\n  showTablesQuery(database) {\n    let query = \"SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'\";\n\n    if (database) {\n      query += ` AND TABLE_SCHEMA = ${this.escape(database)}`;\n    } else {\n      query += \" AND TABLE_SCHEMA NOT IN ('MYSQL', 'INFORMATION_SCHEMA', 'PERFORMANCE_SCHEMA', 'SYS', 'mysql', 'information_schema', 'performance_schema', 'sys')\";\n    }\n\n    return `${query};`;\n  }\n\n  tableExistsQuery(table) {\n    const tableName = this.escape(this.quoteTable(table).slice(1, -1));\n    return `SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = ${tableName} AND TABLE_SCHEMA = ${this.escape(this.sequelize.config.database)}`;\n  }\n\n  addColumnQuery(table, key, dataType) {\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(table), \"ADD\", this.quoteIdentifier(key), this.attributeToSQL(dataType, {\n      context: \"addColumn\",\n      tableName: table,\n      foreignKey: key\n    }), \";\"]);\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"DROP\", this.quoteIdentifier(attributeName), \";\"]);\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [];\n    const constraintString = [];\n\n    for (const attributeName in attributes) {\n      let definition = attributes[attributeName];\n\n      if (definition.includes(\"REFERENCES\")) {\n        const attrName = this.quoteIdentifier(attributeName);\n        definition = definition.replace(/.+?(?=REFERENCES)/, \"\");\n        constraintString.push(`FOREIGN KEY (${attrName}) ${definition}`);\n      } else {\n        attrString.push(`\\`${attributeName}\\` \\`${attributeName}\\` ${definition}`);\n      }\n    }\n\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), attrString.length && `CHANGE ${attrString.join(\", \")}`, constraintString.length && `ADD ${constraintString.join(\", \")}`, \";\"]);\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push(`\\`${attrBefore}\\` \\`${attrName}\\` ${definition}`);\n    }\n\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"CHANGE\", attrString.join(\", \"), \";\"]);\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition => `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);\n        return conditions.join(\" AND \");\n      }\n\n      if (smth.path) {\n        let str;\n\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          const paths = _.toPath(smth.path);\n\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (smth.value) {\n          str += util.format(\" = %s\", this.escape(smth.value));\n        }\n\n        return str;\n      }\n    } else if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = \"datetime\";\n      } else if (smth.json && /boolean/i.test(smth.type)) {\n        smth.type = \"char\";\n      } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {\n        smth.type = \"decimal\";\n      } else if (/text/i.test(smth.type)) {\n        smth.type = \"char\";\n      }\n    }\n\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  }\n\n  _toJSONValue(value) {\n    if (typeof value === \"boolean\") {\n      return value.toString();\n    }\n\n    if (value === null) {\n      return \"null\";\n    }\n\n    return value;\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE ${this.quoteTable(tableName)}`;\n  }\n\n  deleteQuery(tableName, where) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let model = arguments.length > 3 ? arguments[3] : undefined;\n    let limit = \"\";\n    let query = `DELETE FROM ${this.quoteTable(tableName)}`;\n\n    if (options.limit) {\n      limit = ` LIMIT ${this.escape(options.limit)}`;\n    }\n\n    where = this.getWhereConditions(where, null, model, options);\n\n    if (where) {\n      query += ` WHERE ${where}`;\n    }\n\n    return query + limit;\n  }\n\n  showIndexesQuery(tableName, options) {\n    return Utils.joinSQLFragments([`SHOW INDEX FROM ${this.quoteTable(tableName)}`, options && options.database && `FROM \\`${options.database}\\``]);\n  }\n\n  showConstraintsQuery(table, constraintName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n    return Utils.joinSQLFragments([\"SELECT CONSTRAINT_CATALOG AS constraintCatalog,\", \"CONSTRAINT_NAME AS constraintName,\", \"CONSTRAINT_SCHEMA AS constraintSchema,\", \"CONSTRAINT_TYPE AS constraintType,\", \"TABLE_NAME AS tableName,\", \"TABLE_SCHEMA AS tableSchema\", \"from INFORMATION_SCHEMA.TABLE_CONSTRAINTS\", `WHERE table_name='${tableName}'`, constraintName && `AND constraint_name = '${constraintName}'`, schemaName && `AND TABLE_SCHEMA = '${schemaName}'`, \";\"]);\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n\n    return Utils.joinSQLFragments([\"DROP INDEX\", this.quoteIdentifier(indexName), \"ON\", this.quoteTable(tableName)]);\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    const attributeString = attribute.type.toString({\n      escape: this.escape.bind(this)\n    });\n    let template = attributeString;\n\n    if (attribute.allowNull === false) {\n      template += \" NOT NULL\";\n    }\n\n    if (attribute.autoIncrement) {\n      template += \" auto_increment\";\n    }\n\n    if (!typeWithoutDefault.has(attributeString) && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (attribute.unique === true) {\n      template += \" UNIQUE\";\n    }\n\n    if (attribute.primaryKey) {\n      template += \" PRIMARY KEY\";\n    }\n\n    if (attribute.comment) {\n      template += ` COMMENT ${this.escape(attribute.comment)}`;\n    }\n\n    if (attribute.first) {\n      template += \" FIRST\";\n    }\n\n    if (attribute.after) {\n      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;\n    }\n\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      if (options && options.context === \"addColumn\" && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\n        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier(\"id\")})`;\n      }\n\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== \"string\") {\n      return false;\n    }\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf(\"(\");\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n\n        if (capturedToken === \"(\") {\n          openingBrackets++;\n        } else if (capturedToken === \")\") {\n          closingBrackets++;\n        } else if (capturedToken === \";\") {\n          hasInvalidToken = true;\n          break;\n        }\n\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    return hasJsonFunction;\n  }\n\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments([\"SELECT\", FOREIGN_KEY_FIELDS, `FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}'`, `AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}'`, \"AND REFERENCED_TABLE_NAME IS NOT NULL\", \";\"]);\n  }\n\n  getForeignKeyQuery(table, columnName) {\n    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : \"\";\n    const quotedTableName = wrapSingleQuote(table.tableName || table);\n    const quotedColumnName = wrapSingleQuote(columnName);\n    return Utils.joinSQLFragments([\"SELECT\", FOREIGN_KEY_FIELDS, \"FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE\", \"WHERE (\", [`REFERENCED_TABLE_NAME = ${quotedTableName}`, table.schema && `AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}`, `AND REFERENCED_COLUMN_NAME = ${quotedColumnName}`], \") OR (\", [`TABLE_NAME = ${quotedTableName}`, table.schema && `AND TABLE_SCHEMA = ${quotedSchemaName}`, `AND COLUMN_NAME = ${quotedColumnName}`, \"AND REFERENCED_TABLE_NAME IS NOT NULL\"], \")\"]);\n  }\n\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"DROP FOREIGN KEY\", this.quoteIdentifier(foreignKey), \";\"]);\n  }\n\n  quoteIdentifier(identifier, force) {\n    return Utils.addTicks(Utils.removeTicks(identifier, \"`\"), \"`\");\n  }\n\n}\n\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, \"'\");\n}\n\nmodule.exports = MySQLQueryGenerator;","map":{"version":3,"mappings":"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","names":["_","require","Utils","AbstractQueryGenerator","util","Op","JSON_FUNCTION_REGEX","JSON_OPERATOR_REGEX","TOKEN_CAPTURE_REGEX","FOREIGN_KEY_FIELDS","join","typeWithoutDefault","Set","constructor","options","OperatorMap","__spreadProps","regexp","notRegexp","createDatabaseQuery","databaseName","__spreadValues","charset","collate","joinSQLFragments","quoteIdentifier","escape","dropDatabaseQuery","createSchema","showSchemasQuery","versionQuery","createTableQuery","tableName","attributes","engine","rowFormat","primaryKeys","foreignKeys","attrStr","attr","Object","prototype","hasOwnProperty","call","dataType","match","includes","push","replace","table","quoteTable","attributesClause","pkString","map","pk","uniqueKeys","each","columns","indexName","customIndex","fields","field","length","fkey","comment","initialAutoIncrement","describeTableQuery","schema","schemaDelimiter","addSchema","_schema","_schemaDelimiter","showTablesQuery","database","query","tableExistsQuery","slice","sequelize","config","addColumnQuery","key","attributeToSQL","context","foreignKey","removeColumnQuery","attributeName","changeColumnQuery","attrString","constraintString","definition","attrName","renameColumnQuery","attrBefore","handleSequelizeMethod","smth","factory","prepend","Json","conditions","parseConditionObject","condition","jsonPathExtractionQuery","path","tail","value","str","_checkValidJsonStatement","paths","toPath","column","shift","format","Cast","test","type","json","_toJSONValue","toString","truncateTableQuery","deleteQuery","where","model","limit","getWhereConditions","showIndexesQuery","showConstraintsQuery","constraintName","schemaName","removeIndexQuery","indexNameOrAttributes","underscore","attribute","isPlainObject","attributeString","bind","template","allowNull","autoIncrement","has","_binary","defaultValueSchemable","defaultValue","unique","primaryKey","first","after","withoutForeignKeyConstraints","references","fkName","onDelete","toUpperCase","onUpdate","attributesToSQL","result","stmt","currentIndex","openingBrackets","closingBrackets","hasJsonFunction","hasInvalidToken","string","substr","functionMatches","exec","indexOf","operatorMatches","tokenMatches","capturedToken","Error","getForeignKeysQuery","getForeignKeyQuery","columnName","quotedSchemaName","wrapSingleQuote","quotedTableName","quotedColumnName","dropForeignKeyQuery","identifier","force","addTicks","removeTicks","module","exports","MySQLQueryGenerator"],"sources":["/Users/aurele/node_modules/sequelize/src/dialects/mysql/query-generator.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\nconst util = require('util');\nconst Op = require('../../operators');\n\n\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nconst FOREIGN_KEY_FIELDS = [\n  'CONSTRAINT_NAME as constraint_name',\n  'CONSTRAINT_NAME as constraintName',\n  'CONSTRAINT_SCHEMA as constraintSchema',\n  'CONSTRAINT_SCHEMA as constraintCatalog',\n  'TABLE_NAME as tableName',\n  'TABLE_SCHEMA as tableSchema',\n  'TABLE_SCHEMA as tableCatalog',\n  'COLUMN_NAME as columnName',\n  'REFERENCED_TABLE_SCHEMA as referencedTableSchema',\n  'REFERENCED_TABLE_SCHEMA as referencedTableCatalog',\n  'REFERENCED_TABLE_NAME as referencedTableName',\n  'REFERENCED_COLUMN_NAME as referencedColumnName'\n].join(',');\n\nconst typeWithoutDefault = new Set(['BLOB', 'TEXT', 'GEOMETRY', 'JSON']);\n\nclass MySQLQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n\n    this.OperatorMap = {\n      ...this.OperatorMap,\n      [Op.regexp]: 'REGEXP',\n      [Op.notRegexp]: 'NOT REGEXP'\n    };\n  }\n\n  createDatabaseQuery(databaseName, options) {\n    options = {\n      charset: null,\n      collate: null,\n      ...options\n    };\n\n    return Utils.joinSQLFragments([\n      'CREATE DATABASE IF NOT EXISTS',\n      this.quoteIdentifier(databaseName),\n      options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`,\n      options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`,\n      ';'\n    ]);\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName)};`;\n  }\n\n  createSchema() {\n    return 'SHOW TABLES';\n  }\n\n  showSchemasQuery() {\n    return 'SHOW TABLES';\n  }\n\n  versionQuery() {\n    return 'SELECT VERSION() as `version`';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = {\n      engine: 'InnoDB',\n      charset: null,\n      rowFormat: null,\n      ...options\n    };\n\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n\n    for (const attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n      const dataType = attributes[attr];\n      let match;\n\n      if (dataType.includes('PRIMARY KEY')) {\n        primaryKeys.push(attr);\n\n        if (dataType.includes('REFERENCES')) {\n          // MySQL doesn't support inline REFERENCES declarations: move to the end\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);\n        }\n      } else if (dataType.includes('REFERENCES')) {\n        // MySQL doesn't support inline REFERENCES declarations: move to the end\n        match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attributesClause = attrStr.join(', ');\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== 'string') {\n            indexName = `uniq_${tableName}_${columns.fields.join('_')}`;\n          }\n          attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pkString})`;\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n\n    return Utils.joinSQLFragments([\n      'CREATE TABLE IF NOT EXISTS',\n      table,\n      `(${attributesClause})`,\n      `ENGINE=${options.engine}`,\n      options.comment && typeof options.comment === 'string' && `COMMENT ${this.escape(options.comment)}`,\n      options.charset && `DEFAULT CHARSET=${options.charset}`,\n      options.collate && `COLLATE ${options.collate}`,\n      options.initialAutoIncrement && `AUTO_INCREMENT=${options.initialAutoIncrement}`,\n      options.rowFormat && `ROW_FORMAT=${options.rowFormat}`,\n      ';'\n    ]);\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(\n      this.addSchema({\n        tableName,\n        _schema: schema,\n        _schemaDelimiter: schemaDelimiter\n      })\n    );\n\n    return `SHOW FULL COLUMNS FROM ${table};`;\n  }\n\n  showTablesQuery(database) {\n    let query = 'SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = \\'BASE TABLE\\'';\n    if (database) {\n      query += ` AND TABLE_SCHEMA = ${this.escape(database)}`;\n    } else {\n      query += ' AND TABLE_SCHEMA NOT IN (\\'MYSQL\\', \\'INFORMATION_SCHEMA\\', \\'PERFORMANCE_SCHEMA\\', \\'SYS\\', \\'mysql\\', \\'information_schema\\', \\'performance_schema\\', \\'sys\\')';\n    }\n    return `${query};`;\n  }\n\n  tableExistsQuery(table) {\n    // remove first & last `, then escape as SQL string\n    const tableName = this.escape(this.quoteTable(table).slice(1, -1));\n\n    return `SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = ${tableName} AND TABLE_SCHEMA = ${this.escape(this.sequelize.config.database)}`;\n  }\n\n  addColumnQuery(table, key, dataType) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(table),\n      'ADD',\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, {\n        context: 'addColumn',\n        tableName: table,\n        foreignKey: key\n      }),\n      ';'\n    ]);\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP',\n      this.quoteIdentifier(attributeName),\n      ';'\n    ]);\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [];\n    const constraintString = [];\n\n    for (const attributeName in attributes) {\n      let definition = attributes[attributeName];\n      if (definition.includes('REFERENCES')) {\n        const attrName = this.quoteIdentifier(attributeName);\n        definition = definition.replace(/.+?(?=REFERENCES)/, '');\n        constraintString.push(`FOREIGN KEY (${attrName}) ${definition}`);\n      } else {\n        attrString.push(`\\`${attributeName}\\` \\`${attributeName}\\` ${definition}`);\n      }\n    }\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      attrString.length && `CHANGE ${attrString.join(', ')}`,\n      constraintString.length && `ADD ${constraintString.join(', ')}`,\n      ';'\n    ]);\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push(`\\`${attrBefore}\\` \\`${attrName}\\` ${definition}`);\n    }\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'CHANGE',\n      attrString.join(', '),\n      ';'\n    ]);\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition =>\n          `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`\n        );\n\n        return conditions.join(' AND ');\n      }\n      if (smth.path) {\n        let str;\n\n        // Allow specifying conditions using the sqlite json functions\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json property accessors\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    } else if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = 'datetime';\n      } else if (smth.json && /boolean/i.test(smth.type)) {\n        // true or false cannot be casted as booleans within a JSON structure\n        smth.type = 'char';\n      } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {\n        smth.type = 'decimal';\n      } else if (/text/i.test(smth.type)) {\n        smth.type = 'char';\n      }\n    }\n\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  }\n\n  _toJSONValue(value) {\n    // true/false are stored as strings in mysql\n    if (typeof value === 'boolean') {\n      return value.toString();\n    }\n    // null is stored as a string in mysql\n    if (value === null) {\n      return 'null';\n    }\n    return value;\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE ${this.quoteTable(tableName)}`;\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    let limit = '';\n    let query = `DELETE FROM ${this.quoteTable(tableName)}`;\n\n    if (options.limit) {\n      limit = ` LIMIT ${this.escape(options.limit)}`;\n    }\n\n    where = this.getWhereConditions(where, null, model, options);\n\n    if (where) {\n      query += ` WHERE ${where}`;\n    }\n\n    return query + limit;\n  }\n\n  showIndexesQuery(tableName, options) {\n    return Utils.joinSQLFragments([\n      `SHOW INDEX FROM ${this.quoteTable(tableName)}`,\n      options && options.database && `FROM \\`${options.database}\\``\n    ]);\n  }\n\n  showConstraintsQuery(table, constraintName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n\n    return Utils.joinSQLFragments([\n      'SELECT CONSTRAINT_CATALOG AS constraintCatalog,',\n      'CONSTRAINT_NAME AS constraintName,',\n      'CONSTRAINT_SCHEMA AS constraintSchema,',\n      'CONSTRAINT_TYPE AS constraintType,',\n      'TABLE_NAME AS tableName,',\n      'TABLE_SCHEMA AS tableSchema',\n      'from INFORMATION_SCHEMA.TABLE_CONSTRAINTS',\n      `WHERE table_name='${tableName}'`,\n      constraintName && `AND constraint_name = '${constraintName}'`,\n      schemaName && `AND TABLE_SCHEMA = '${schemaName}'`,\n      ';'\n    ]);\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return Utils.joinSQLFragments([\n      'DROP INDEX',\n      this.quoteIdentifier(indexName),\n      'ON',\n      this.quoteTable(tableName)\n    ]);\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    const attributeString = attribute.type.toString({ escape: this.escape.bind(this) });\n    let template = attributeString;\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' auto_increment';\n    }\n\n    // BLOB/TEXT/GEOMETRY/JSON cannot have a default value\n    if (!typeWithoutDefault.has(attributeString)\n      && attribute.type._binary !== true\n      && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if (attribute.comment) {\n      template += ` COMMENT ${this.escape(attribute.comment)}`;\n    }\n\n    if (attribute.first) {\n      template += ' FIRST';\n    }\n    if (attribute.after) {\n      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;\n    }\n\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      if (options && options.context === 'addColumn' && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\n\n        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier('id')})`;\n      }\n\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   * @private\n   */\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {object} table  The table.\n   * @param  {string} schemaName The name of the schema.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments([\n      'SELECT',\n      FOREIGN_KEY_FIELDS,\n      `FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}'`,\n      `AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}'`,\n      'AND REFERENCED_TABLE_NAME IS NOT NULL',\n      ';'\n    ]);\n  }\n\n  /**\n   * Generates an SQL query that returns the foreign key constraint of a given column.\n   *\n   * @param  {object} table  The table.\n   * @param  {string} columnName The name of the column.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeyQuery(table, columnName) {\n    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : '';\n    const quotedTableName = wrapSingleQuote(table.tableName || table);\n    const quotedColumnName = wrapSingleQuote(columnName);\n\n    return Utils.joinSQLFragments([\n      'SELECT',\n      FOREIGN_KEY_FIELDS,\n      'FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE',\n      'WHERE (',\n      [\n        `REFERENCED_TABLE_NAME = ${quotedTableName}`,\n        table.schema && `AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}`,\n        `AND REFERENCED_COLUMN_NAME = ${quotedColumnName}`\n      ],\n      ') OR (',\n      [\n        `TABLE_NAME = ${quotedTableName}`,\n        table.schema && `AND TABLE_SCHEMA = ${quotedSchemaName}`,\n        `AND COLUMN_NAME = ${quotedColumnName}`,\n        'AND REFERENCED_TABLE_NAME IS NOT NULL'\n      ],\n      ')'\n    ]);\n  }\n\n  /**\n   * Generates an SQL query that removes a foreign key from a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @param  {string} foreignKey The name of the foreign key constraint.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP FOREIGN KEY',\n      this.quoteIdentifier(foreignKey),\n      ';'\n    ]);\n  }\n\n  /**\n   * Quote identifier in sql clause\n   *\n   * @param {string} identifier\n   * @param {boolean} force\n   *\n   * @returns {string}\n   */\n  quoteIdentifier(identifier, force) {\n    return Utils.addTicks(Utils.removeTicks(identifier, '`'), '`');\n  }\n}\n\n// private methods\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, '\\'');\n}\n\nmodule.exports = MySQLQueryGenerator;\n"]},"metadata":{},"sourceType":"script"}