{"ast":null,"code":"'use strict';\n\nconst MiniPass = require('minipass');\n\nconst normPath = require('./normalize-windows-path.js');\n\nconst SLURP = Symbol('slurp');\nmodule.exports = class ReadEntry extends MiniPass {\n  constructor(header, ex, gex) {\n    super(); // read entries always start life paused.  this is to avoid the\n    // situation where Minipass's auto-ending empty streams results\n    // in an entry ending before we're ready for it.\n\n    this.pause();\n    this.extended = ex;\n    this.globalExtended = gex;\n    this.header = header;\n    this.startBlockSize = 512 * Math.ceil(header.size / 512);\n    this.blockRemain = this.startBlockSize;\n    this.remain = header.size;\n    this.type = header.type;\n    this.meta = false;\n    this.ignore = false;\n\n    switch (this.type) {\n      case 'File':\n      case 'OldFile':\n      case 'Link':\n      case 'SymbolicLink':\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'Directory':\n      case 'FIFO':\n      case 'ContiguousFile':\n      case 'GNUDumpDir':\n        break;\n\n      case 'NextFileHasLongLinkpath':\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n      case 'GlobalExtendedHeader':\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this.meta = true;\n        break;\n      // NOTE: gnutar and bsdtar treat unrecognized types as 'File'\n      // it may be worth doing the same, but with a warning.\n\n      default:\n        this.ignore = true;\n    }\n\n    this.path = normPath(header.path);\n    this.mode = header.mode;\n\n    if (this.mode) {\n      this.mode = this.mode & 0o7777;\n    }\n\n    this.uid = header.uid;\n    this.gid = header.gid;\n    this.uname = header.uname;\n    this.gname = header.gname;\n    this.size = header.size;\n    this.mtime = header.mtime;\n    this.atime = header.atime;\n    this.ctime = header.ctime;\n    this.linkpath = normPath(header.linkpath);\n    this.uname = header.uname;\n    this.gname = header.gname;\n\n    if (ex) {\n      this[SLURP](ex);\n    }\n\n    if (gex) {\n      this[SLURP](gex, true);\n    }\n  }\n\n  write(data) {\n    const writeLen = data.length;\n\n    if (writeLen > this.blockRemain) {\n      throw new Error('writing more to entry than is appropriate');\n    }\n\n    const r = this.remain;\n    const br = this.blockRemain;\n    this.remain = Math.max(0, r - writeLen);\n    this.blockRemain = Math.max(0, br - writeLen);\n\n    if (this.ignore) {\n      return true;\n    }\n\n    if (r >= writeLen) {\n      return super.write(data);\n    } // r < writeLen\n\n\n    return super.write(data.slice(0, r));\n  }\n\n  [SLURP](ex, global) {\n    for (const k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined && !(global && k === 'path')) {\n        this[k] = k === 'path' || k === 'linkpath' ? normPath(ex[k]) : ex[k];\n      }\n    }\n  }\n\n};","map":{"version":3,"names":["MiniPass","require","normPath","SLURP","Symbol","module","exports","ReadEntry","constructor","header","ex","gex","pause","extended","globalExtended","startBlockSize","Math","ceil","size","blockRemain","remain","type","meta","ignore","path","mode","uid","gid","uname","gname","mtime","atime","ctime","linkpath","write","data","writeLen","length","Error","r","br","max","slice","global","k","undefined"],"sources":["/Users/aurele/Desktop/E-Commerce App/views/node_modules/tar/lib/read-entry.js"],"sourcesContent":["'use strict'\nconst MiniPass = require('minipass')\nconst normPath = require('./normalize-windows-path.js')\n\nconst SLURP = Symbol('slurp')\nmodule.exports = class ReadEntry extends MiniPass {\n  constructor (header, ex, gex) {\n    super()\n    // read entries always start life paused.  this is to avoid the\n    // situation where Minipass's auto-ending empty streams results\n    // in an entry ending before we're ready for it.\n    this.pause()\n    this.extended = ex\n    this.globalExtended = gex\n    this.header = header\n    this.startBlockSize = 512 * Math.ceil(header.size / 512)\n    this.blockRemain = this.startBlockSize\n    this.remain = header.size\n    this.type = header.type\n    this.meta = false\n    this.ignore = false\n    switch (this.type) {\n      case 'File':\n      case 'OldFile':\n      case 'Link':\n      case 'SymbolicLink':\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'Directory':\n      case 'FIFO':\n      case 'ContiguousFile':\n      case 'GNUDumpDir':\n        break\n\n      case 'NextFileHasLongLinkpath':\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n      case 'GlobalExtendedHeader':\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this.meta = true\n        break\n\n      // NOTE: gnutar and bsdtar treat unrecognized types as 'File'\n      // it may be worth doing the same, but with a warning.\n      default:\n        this.ignore = true\n    }\n\n    this.path = normPath(header.path)\n    this.mode = header.mode\n    if (this.mode) {\n      this.mode = this.mode & 0o7777\n    }\n    this.uid = header.uid\n    this.gid = header.gid\n    this.uname = header.uname\n    this.gname = header.gname\n    this.size = header.size\n    this.mtime = header.mtime\n    this.atime = header.atime\n    this.ctime = header.ctime\n    this.linkpath = normPath(header.linkpath)\n    this.uname = header.uname\n    this.gname = header.gname\n\n    if (ex) {\n      this[SLURP](ex)\n    }\n    if (gex) {\n      this[SLURP](gex, true)\n    }\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain) {\n      throw new Error('writing more to entry than is appropriate')\n    }\n\n    const r = this.remain\n    const br = this.blockRemain\n    this.remain = Math.max(0, r - writeLen)\n    this.blockRemain = Math.max(0, br - writeLen)\n    if (this.ignore) {\n      return true\n    }\n\n    if (r >= writeLen) {\n      return super.write(data)\n    }\n\n    // r < writeLen\n    return super.write(data.slice(0, r))\n  }\n\n  [SLURP] (ex, global) {\n    for (const k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined &&\n          !(global && k === 'path')) {\n        this[k] = k === 'path' || k === 'linkpath' ? normPath(ex[k]) : ex[k]\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}