{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __markAsModule = target => __defProp(target, \"__esModule\", {\n  value: true\n});\n\nvar __export = (target, all) => {\n  __markAsModule(target);\n\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n\n__export(exports, {\n  OracleQueryGenerator: () => OracleQueryGenerator\n});\n\nconst Utils = require(\"../../utils\");\n\nconst DataTypes = require(\"../../data-types\");\n\nconst AbstractQueryGenerator = require(\"../abstract/query-generator\");\n\nconst _ = require(\"lodash\");\n\nconst util = require(\"util\");\n\nconst Transaction = require(\"../../transaction\");\n\nconst ORACLE_RESERVED_WORDS = [\"ACCESS\", \"ADD\", \"ALL\", \"ALTER\", \"AND\", \"ANY\", \"ARRAYLEN\", \"AS\", \"ASC\", \"AUDIT\", \"BETWEEN\", \"BY\", \"CHAR\", \"CHECK\", \"CLUSTER\", \"COLUMN\", \"COMMENT\", \"COMPRESS\", \"CONNECT\", \"CREATE\", \"CURRENT\", \"DATE\", \"DECIMAL\", \"DEFAULT\", \"DELETE\", \"DESC\", \"DISTINCT\", \"DROP\", \"ELSE\", \"EXCLUSIVE\", \"EXISTS\", \"FILE\", \"FLOAT\", \"FOR\", \"FROM\", \"GRANT\", \"GROUP\", \"HAVING\", \"IDENTIFIED\", \"IMMEDIATE\", \"IN\", \"INCREMENT\", \"INDEX\", \"INITIAL\", \"INSERT\", \"INTEGER\", \"INTERSECT\", \"INTO\", \"IS\", \"LEVEL\", \"LIKE\", \"LOCK\", \"LONG\", \"MAXEXTENTS\", \"MINUS\", \"MODE\", \"MODIFY\", \"NOAUDIT\", \"NOCOMPRESS\", \"NOT\", \"NOTFOUND\", \"NOWAIT\", \"NULL\", \"NUMBER\", \"OF\", \"OFFLINE\", \"ON\", \"ONLINE\", \"OPTION\", \"OR\", \"ORDER\", \"PCTFREE\", \"PRIOR\", \"PRIVILEGES\", \"PUBLIC\", \"RAW\", \"RENAME\", \"RESOURCE\", \"REVOKE\", \"ROW\", \"ROWID\", \"ROWLABEL\", \"ROWNUM\", \"ROWS\", \"SELECT\", \"SESSION\", \"SET\", \"SHARE\", \"SIZE\", \"SMALLINT\", \"SQLBUF\", \"START\", \"SUCCESSFUL\", \"SYNONYM\", \"SYSDATE\", \"TABLE\", \"THEN\", \"TO\", \"TRIGGER\", \"UID\", \"UNION\", \"UNIQUE\", \"UPDATE\", \"USER\", \"VALIDATE\", \"VALUES\", \"VARCHAR\", \"VARCHAR2\", \"VIEW\", \"WHENEVER\", \"WHERE\", \"WITH\"];\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n\nclass OracleQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n  }\n\n  getCatalogName(value) {\n    if (value) {\n      if (this.options.quoteIdentifiers === false) {\n        const quotedValue = this.quoteIdentifier(value);\n\n        if (quotedValue === value) {\n          value = value.toUpperCase();\n        }\n      }\n    }\n\n    return value;\n  }\n\n  getSchemaNameAndTableName(table) {\n    const tableName = this.getCatalogName(table.tableName || table);\n    const schemaName = this.getCatalogName(table.schema);\n    return [tableName, schemaName];\n  }\n\n  createSchema(schema) {\n    const quotedSchema = this.quoteIdentifier(schema);\n    return [\"DECLARE\", \"USER_FOUND BOOLEAN := FALSE;\", \"BEGIN\", \" BEGIN\", \"   EXECUTE IMMEDIATE \", this.escape(`CREATE USER ${quotedSchema} IDENTIFIED BY 12345 DEFAULT TABLESPACE USERS`), \";\", \"   EXCEPTION WHEN OTHERS THEN\", \"     IF SQLCODE != -1920 THEN\", \"       RAISE;\", \"     ELSE\", \"       USER_FOUND := TRUE;\", \"     END IF;\", \" END;\", \" IF NOT USER_FOUND THEN\", \"    EXECUTE IMMEDIATE \", this.escape(`GRANT \"CONNECT\" TO ${quotedSchema}`), \";\", \"    EXECUTE IMMEDIATE \", this.escape(`GRANT CREATE TABLE TO ${quotedSchema}`), \";\", \"    EXECUTE IMMEDIATE \", this.escape(`GRANT CREATE VIEW TO ${quotedSchema}`), \";\", \"    EXECUTE IMMEDIATE \", this.escape(`GRANT CREATE ANY TRIGGER TO ${quotedSchema}`), \";\", \"    EXECUTE IMMEDIATE \", this.escape(`GRANT CREATE ANY PROCEDURE TO ${quotedSchema}`), \";\", \"    EXECUTE IMMEDIATE \", this.escape(`GRANT CREATE SEQUENCE TO ${quotedSchema}`), \";\", \"    EXECUTE IMMEDIATE \", this.escape(`GRANT CREATE SYNONYM TO ${quotedSchema}`), \";\", \"    EXECUTE IMMEDIATE \", this.escape(`ALTER USER ${quotedSchema} QUOTA UNLIMITED ON USERS`), \";\", \" END IF;\", \"END;\"].join(\" \");\n  }\n\n  showSchemasQuery() {\n    return `SELECT USERNAME AS \"schema_name\" FROM ALL_USERS WHERE COMMON = ('NO') AND USERNAME != user`;\n  }\n\n  dropSchema(schema) {\n    return [\"BEGIN\", \"EXECUTE IMMEDIATE \", this.escape(`DROP USER ${this.quoteTable(schema)} CASCADE`), \";\", \"EXCEPTION WHEN OTHERS THEN\", \"  IF SQLCODE != -1918 THEN\", \"    RAISE;\", \"  END IF;\", \"END;\"].join(\" \");\n  }\n\n  versionQuery() {\n    return \"SELECT VERSION_FULL FROM PRODUCT_COMPONENT_VERSION WHERE PRODUCT LIKE 'Oracle%'\";\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    const primaryKeys = [],\n          foreignKeys = Object.create(null),\n          attrStr = [],\n          checkStr = [];\n    const values = {\n      table: this.quoteTable(tableName)\n    };\n\n    for (let attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n      const dataType = attributes[attr];\n      attr = this.quoteIdentifier(attr);\n\n      if (dataType.includes(\"PRIMARY KEY\")) {\n        primaryKeys.push(attr);\n\n        if (dataType.includes(\"REFERENCES\")) {\n          const match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${attr} ${match[1].replace(/PRIMARY KEY/, \"\")}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${attr} ${dataType.replace(/PRIMARY KEY/, \"\").trim()}`);\n        }\n      } else if (dataType.includes(\"REFERENCES\")) {\n        const match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${attr} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${attr} ${dataType}`);\n      }\n    }\n\n    values[\"attributes\"] = attrStr.join(\", \");\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(\", \");\n\n    if (pkString.length > 0) {\n      values.attributes += `,PRIMARY KEY (${pkString})`;\n    }\n\n    for (const fkey in foreignKeys) {\n      if (!Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) continue;\n\n      if (foreignKeys[fkey].indexOf(\"ON DELETE NO ACTION\") > -1) {\n        foreignKeys[fkey] = foreignKeys[fkey].replace(\"ON DELETE NO ACTION\", \"\");\n      }\n\n      values.attributes += `,FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n    }\n\n    if (checkStr.length > 0) {\n      values.attributes += `, ${checkStr.join(\", \")}`;\n    }\n\n    if (options && options.indexes && options.indexes.length > 0) {\n      const idxToDelete = [];\n      options.indexes.forEach((index, idx) => {\n        if (\"unique\" in index && (index.unique === true || index.unique.length > 0 && index.unique !== false)) {\n          const fields = index.fields.map(field => {\n            if (typeof field === \"string\") {\n              return field;\n            }\n\n            return field.attribute;\n          });\n          let canContinue = true;\n\n          if (options.uniqueKeys) {\n            const keys = Object.keys(options.uniqueKeys);\n\n            for (let fieldIdx = 0; fieldIdx < keys.length; fieldIdx++) {\n              const currUnique = options.uniqueKeys[keys[fieldIdx]];\n\n              if (currUnique.fields.length === fields.length) {\n                for (let i = 0; i < currUnique.fields.length; i++) {\n                  const field = currUnique.fields[i];\n\n                  if (_.includes(fields, field)) {\n                    canContinue = false;\n                  } else {\n                    canContinue = true;\n                    break;\n                  }\n                }\n              }\n            }\n\n            if (canContinue) {\n              const indexName = \"name\" in index ? index.name : \"\";\n              const constraintToAdd = {\n                name: indexName,\n                fields\n              };\n\n              if (!(\"uniqueKeys\" in options)) {\n                options.uniqueKeys = {};\n              }\n\n              options.uniqueKeys[indexName] = constraintToAdd;\n              idxToDelete.push(idx);\n            } else {\n              idxToDelete.push(idx);\n            }\n          }\n        }\n      });\n      idxToDelete.forEach(idx => {\n        options.indexes.splice(idx, 1);\n      });\n    }\n\n    if (options && !!options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        let canBeUniq = false;\n        primaryKeys.forEach(primaryKey => {\n          primaryKey = primaryKey.replace(/\"/g, \"\");\n\n          if (!_.includes(columns.fields, primaryKey)) {\n            canBeUniq = true;\n          }\n        });\n        columns.fields.forEach(field => {\n          let currField = \"\";\n\n          if (!_.isString(field)) {\n            currField = field.attribute.replace(/[.,\"\\s]/g, \"\");\n          } else {\n            currField = field.replace(/[.,\"\\s]/g, \"\");\n          }\n\n          if (currField in attributes) {\n            if (attributes[currField].toUpperCase().indexOf(\"UNIQUE\") > -1 && canBeUniq) {\n              const attrToReplace = attributes[currField].replace(\"UNIQUE\", \"\");\n              values.attributes = values.attributes.replace(attributes[currField], attrToReplace);\n            }\n          }\n        });\n\n        if (canBeUniq) {\n          const index = options.uniqueKeys[columns.name];\n          delete options.uniqueKeys[columns.name];\n          indexName = indexName.replace(/[.,\\s]/g, \"\");\n          columns.name = indexName;\n          options.uniqueKeys[indexName] = index;\n\n          if (indexName.length === 0) {\n            values.attributes += `,UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(\", \")})`;\n          } else {\n            values.attributes += `, CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(\", \")})`;\n          }\n        }\n      });\n    }\n\n    const query = Utils.joinSQLFragments([\"CREATE TABLE\", values.table, `(${values.attributes})`]);\n    return Utils.joinSQLFragments([\"BEGIN\", \"EXECUTE IMMEDIATE\", `${this.escape(query)};`, \"EXCEPTION WHEN OTHERS THEN\", \"IF SQLCODE != -955 THEN\", \"RAISE;\", \"END IF;\", \"END;\"]);\n  }\n\n  tableExistsQuery(table) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    return `SELECT TABLE_NAME FROM ALL_TABLES WHERE TABLE_NAME = ${this.escape(tableName)} AND OWNER = ${table.schema ? this.escape(schemaName) : \"USER\"}`;\n  }\n\n  describeTableQuery(tableName, schema) {\n    const currTableName = this.getCatalogName(tableName.tableName || tableName);\n    schema = this.getCatalogName(schema);\n    return [\"SELECT atc.COLUMN_NAME, atc.DATA_TYPE, atc.DATA_LENGTH, atc.CHAR_LENGTH, atc.DEFAULT_LENGTH, atc.NULLABLE, ucc.constraint_type \", \"FROM all_tab_columns atc \", \"LEFT OUTER JOIN \", \"(SELECT acc.column_name, acc.table_name, ac.constraint_type FROM all_cons_columns acc INNER JOIN all_constraints ac ON acc.constraint_name = ac.constraint_name) ucc \", \"ON (atc.table_name = ucc.table_name AND atc.COLUMN_NAME = ucc.COLUMN_NAME) \", schema ? `WHERE (atc.OWNER = ${this.escape(schema)}) ` : \"WHERE atc.OWNER = USER \", `AND (atc.TABLE_NAME = ${this.escape(currTableName)})`, \"ORDER BY atc.COLUMN_NAME, CONSTRAINT_TYPE DESC\"].join(\"\");\n  }\n\n  renameTableQuery(before, after) {\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(before), \"RENAME TO\", this.quoteTable(after)]);\n  }\n\n  showConstraintsQuery(table) {\n    const tableName = this.getCatalogName(table.tableName || table);\n    return `SELECT CONSTRAINT_NAME constraint_name FROM user_cons_columns WHERE table_name = ${this.escape(tableName)}`;\n  }\n\n  showTablesQuery() {\n    return `SELECT owner as table_schema, table_name, 0 as lvl FROM all_tables where OWNER IN(SELECT USERNAME AS \"schema_name\" FROM ALL_USERS WHERE ORACLE_MAINTAINED = 'N')`;\n  }\n\n  dropTableQuery(tableName) {\n    return Utils.joinSQLFragments([\"BEGIN \", \"EXECUTE IMMEDIATE 'DROP TABLE\", this.quoteTable(tableName), \"CASCADE CONSTRAINTS PURGE';\", \"EXCEPTION WHEN OTHERS THEN\", \" IF SQLCODE != -942 THEN\", \"   RAISE;\", \" END IF;\", \"END;\"]);\n  }\n\n  addIndexQuery(tableName, attributes, options, rawTablename) {\n    if (typeof tableName !== \"string\" && attributes.name) {\n      attributes.name = `${tableName.schema}.${attributes.name}`;\n    }\n\n    return super.addIndexQuery(tableName, attributes, options, rawTablename);\n  }\n\n  addConstraintQuery(tableName, options) {\n    options = options || {};\n    const constraintSnippet = this.getConstraintSnippet(tableName, options);\n    tableName = this.quoteTable(tableName);\n    return `ALTER TABLE ${tableName} ADD ${constraintSnippet};`;\n  }\n\n  addColumnQuery(table, key, dataType) {\n    dataType.field = key;\n    const attribute = Utils.joinSQLFragments([this.quoteIdentifier(key), this.attributeToSQL(dataType, {\n      attributeName: key,\n      context: \"addColumn\"\n    })]);\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(table), \"ADD\", attribute]);\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"DROP COLUMN\", this.quoteIdentifier(attributeName), \";\"]);\n  }\n\n  _alterForeignKeyConstraint(definition, table, attributeName) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const attributeNameConstant = this.escape(this.getCatalogName(attributeName));\n    const schemaNameConstant = table.schema ? this.escape(this.getCatalogName(schemaName)) : \"USER\";\n    const tableNameConstant = this.escape(this.getCatalogName(tableName));\n    const getConsNameQuery = [\"SELECT constraint_name INTO cons_name\", \"FROM (\", \"  SELECT DISTINCT cc.owner, cc.table_name, cc.constraint_name, cc.column_name AS cons_columns\", \"  FROM all_cons_columns cc, all_constraints c\", \"  WHERE cc.owner = c.owner\", \"  AND cc.table_name = c.table_name\", \"  AND cc.constraint_name = c.constraint_name\", \"  AND c.constraint_type = 'R'\", \"  GROUP BY cc.owner, cc.table_name, cc.constraint_name, cc.column_name\", \")\", \"WHERE owner =\", schemaNameConstant, \"AND table_name =\", tableNameConstant, \"AND cons_columns =\", attributeNameConstant, \";\"].join(\" \");\n    const secondQuery = Utils.joinSQLFragments([`ALTER TABLE ${this.quoteIdentifier(tableName)}`, \"ADD FOREIGN KEY\", `(${this.quoteIdentifier(attributeName)})`, definition.replace(/.+?(?=REFERENCES)/, \"\")]);\n    return [\"BEGIN\", getConsNameQuery, \"EXCEPTION\", \"WHEN NO_DATA_FOUND THEN\", \" CONS_NAME := NULL;\", \"END;\", \"IF CONS_NAME IS NOT NULL THEN\", ` EXECUTE IMMEDIATE 'ALTER TABLE ${this.quoteTable(table)} DROP CONSTRAINT \"'||CONS_NAME||'\"';`, \"END IF;\", `EXECUTE IMMEDIATE ${this.escape(secondQuery)};`].join(\" \");\n  }\n\n  _modifyQuery(definition, table, attributeName) {\n    const query = Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(table), \"MODIFY\", this.quoteIdentifier(attributeName), definition]);\n    const secondQuery = query.replace(\"NOT NULL\", \"\").replace(\"NULL\", \"\");\n    return [\"BEGIN\", `EXECUTE IMMEDIATE ${this.escape(query)};`, \"EXCEPTION\", \"WHEN OTHERS THEN\", \" IF SQLCODE = -1442 OR SQLCODE = -1451 THEN\", `   EXECUTE IMMEDIATE ${this.escape(secondQuery)};`, \" ELSE\", \"   RAISE;\", \" END IF;\", \"END;\"].join(\" \");\n  }\n\n  changeColumnQuery(table, attributes) {\n    const sql = [\"DECLARE\", \"CONS_NAME VARCHAR2(200);\", \"BEGIN\"];\n\n    for (const attributeName in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attributeName)) continue;\n      const definition = attributes[attributeName];\n\n      if (definition.match(/REFERENCES/)) {\n        sql.push(this._alterForeignKeyConstraint(definition, table, attributeName));\n      } else {\n        sql.push(this._modifyQuery(definition, table, attributeName));\n      }\n    }\n\n    sql.push(\"END;\");\n    return sql.join(\" \");\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const newName = Object.keys(attributes)[0];\n    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${this.quoteIdentifier(attrBefore)} TO ${this.quoteIdentifier(newName)}`;\n  }\n\n  populateInsertQueryReturnIntoBinds(returningModelAttributes, returnTypes, inbindLength, returnAttributes, options) {\n    const oracledb = this.sequelize.connectionManager.lib;\n    const outBindAttributes = Object.create(null);\n    const outbind = [];\n    const outbindParam = this.bindParam(outbind, inbindLength);\n    returningModelAttributes.forEach((element, index) => {\n      if (element.startsWith('\"')) {\n        element = element.substring(1, element.length - 1);\n      }\n\n      outBindAttributes[element] = Object.assign(returnTypes[index]._getBindDef(oracledb), {\n        dir: oracledb.BIND_OUT\n      });\n      const returnAttribute = `${this.format(void 0, void 0, {\n        context: \"INSERT\"\n      }, outbindParam)}`;\n      returnAttributes.push(returnAttribute);\n    });\n    options.outBindAttributes = outBindAttributes;\n  }\n\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    const rawAttributes = model.rawAttributes;\n    const updateQuery = this.updateQuery(tableName, updateValues, where, options, rawAttributes);\n    options.bind = updateQuery.bind;\n    const insertQuery = this.insertQuery(tableName, insertValues, rawAttributes, options);\n    const sql = [\"DECLARE \", \"BEGIN \", updateQuery.query ? [updateQuery.query, \"; \", \" IF ( SQL%ROWCOUNT = 0 ) THEN \", insertQuery.query, \" :isUpdate := 0; \", \"ELSE \", \" :isUpdate := 1; \", \" END IF; \"].join(\"\") : [insertQuery.query, \" :isUpdate := 0; \", \"EXCEPTION WHEN OTHERS THEN\", \" IF SQLCODE != -1 THEN\", \"   RAISE;\", \" END IF;\"].join(\"\"), \"END;\"];\n    const query = sql.join(\"\");\n    const result = {\n      query\n    };\n\n    if (options.bindParam !== false) {\n      result.bind = updateQuery.bind || insertQuery.bind;\n    }\n\n    return result;\n  }\n\n  bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {\n    options = options || {};\n    options.executeMany = true;\n    fieldMappedAttributes = fieldMappedAttributes || {};\n    const tuples = [];\n    const allColumns = {};\n    const inBindBindDefMap = {};\n    const outBindBindDefMap = {};\n    const oracledb = this.sequelize.connectionManager.lib;\n\n    for (const fieldValueHash of fieldValueHashes) {\n      _.forOwn(fieldValueHash, (value, key) => {\n        allColumns[key] = fieldMappedAttributes[key] && fieldMappedAttributes[key].autoIncrement === true && value === null;\n      });\n    }\n\n    let inBindPosition;\n\n    for (const fieldValueHash of fieldValueHashes) {\n      const tuple = [];\n      const inbindParam = options.bindParam === void 0 ? this.bindParam(tuple) : options.bindParam;\n      const tempBindPositions = Object.keys(allColumns).map(key => {\n        if (allColumns[key] === true) {\n          if (fieldValueHash[key] !== null) {\n            throw Error(\"For an auto-increment column either all row must be null or non-null, a mix of null and non-null is not allowed!\");\n          }\n\n          return \"DEFAULT\";\n        }\n\n        return this.format(fieldValueHash[key], fieldMappedAttributes[key], {\n          context: \"INSERT\"\n        }, inbindParam);\n      });\n\n      if (!inBindPosition) {\n        inBindPosition = tempBindPositions;\n      }\n\n      tuples.push(tuple);\n    }\n\n    const returnColumn = [];\n    const returnColumnBindPositions = [];\n    const insertColumns = [];\n\n    for (const key of Object.keys(allColumns)) {\n      if (fieldMappedAttributes[key]) {\n        const bindDef = fieldMappedAttributes[key].type._getBindDef(oracledb);\n\n        if (allColumns[key]) {\n          bindDef.dir = oracledb.BIND_OUT;\n          outBindBindDefMap[key] = bindDef;\n          returnColumn.push(this.quoteIdentifier(key));\n          returnColumnBindPositions.push(`:${tuples[0].length + returnColumn.length}`);\n        } else {\n          bindDef.dir = oracledb.BIND_IN;\n          inBindBindDefMap[key] = bindDef;\n        }\n      }\n\n      insertColumns.push(this.quoteIdentifier(key));\n    }\n\n    let query = Utils.joinSQLFragments([\"INSERT\", \"INTO\", this.quoteTable(tableName), `(${insertColumns.join(\",\")})`, \"VALUES\", `(${inBindPosition})`]);\n\n    if (returnColumn.length > 0) {\n      options.outBindAttributes = outBindBindDefMap;\n      query = Utils.joinSQLFragments([query, \"RETURNING\", `${returnColumn.join(\",\")}`, \"INTO\", `${returnColumnBindPositions}`]);\n    }\n\n    const result = {\n      query\n    };\n    result.bind = tuples;\n    options.inbindAttributes = inBindBindDefMap;\n    return result;\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;\n  }\n\n  deleteQuery(tableName, where, options, model) {\n    options = options || {};\n    const table = tableName;\n    where = this.getWhereConditions(where, null, model, options);\n    let queryTmpl;\n\n    if (options.limit) {\n      const whereTmpl = where ? ` AND ${where}` : \"\";\n      queryTmpl = `DELETE FROM ${this.quoteTable(table)} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(table)} WHERE rownum <= ${this.escape(options.limit)}${whereTmpl})`;\n    } else {\n      const whereTmpl = where ? ` WHERE ${where}` : \"\";\n      queryTmpl = `DELETE FROM ${this.quoteTable(table)}${whereTmpl}`;\n    }\n\n    return queryTmpl;\n  }\n\n  showIndexesQuery(table) {\n    const [tableName, owner] = this.getSchemaNameAndTableName(table);\n    const sql = [\"SELECT i.index_name,i.table_name, i.column_name, u.uniqueness, i.descend, c.constraint_type \", \"FROM all_ind_columns i \", \"INNER JOIN all_indexes u \", \"ON (u.table_name = i.table_name AND u.index_name = i.index_name) \", \"LEFT OUTER JOIN all_constraints c \", \"ON (c.table_name = i.table_name AND c.index_name = i.index_name) \", `WHERE i.table_name = ${this.escape(tableName)}`, \" AND u.table_owner = \", owner ? this.escape(owner) : \"USER\", \" ORDER BY index_name, column_position\"];\n    return sql.join(\"\");\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n\n    return `DROP INDEX ${this.quoteIdentifier(indexName)}`;\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    attribute.onUpdate = \"\";\n\n    if (attribute.references) {\n      if (attribute.Model && attribute.Model.tableName === attribute.references.model) {\n        this.sequelize.log(\"Oracle does not support self referencial constraints, we will remove it but we recommend restructuring your query\");\n        attribute.onDelete = \"\";\n      }\n    }\n\n    let template;\n\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;\n      template = attribute.type.toSql();\n      template += ` CHECK (${this.quoteIdentifier(options.attributeName)} IN(${_.map(attribute.values, value => {\n        return this.escape(value);\n      }).join(\", \")}))`;\n      return template;\n    }\n\n    if (attribute.type instanceof DataTypes.JSON) {\n      template = attribute.type.toSql();\n      template += ` CHECK (${this.quoteIdentifier(options.attributeName)} IS JSON)`;\n      return template;\n    }\n\n    if (attribute.type instanceof DataTypes.BOOLEAN) {\n      template = attribute.type.toSql();\n      template += ` CHECK (${this.quoteIdentifier(options.attributeName)} IN('1', '0'))`;\n      return template;\n    }\n\n    if (attribute.autoIncrement) {\n      template = \" NUMBER(*,0) GENERATED BY DEFAULT ON NULL AS IDENTITY\";\n    } else if (attribute.type && attribute.type.key === DataTypes.DOUBLE.key) {\n      template = attribute.type.toSql();\n    } else if (attribute.type) {\n      let unsignedTemplate = \"\";\n\n      if (attribute.type._unsigned) {\n        attribute.type._unsigned = false;\n        unsignedTemplate += ` check(${this.quoteIdentifier(attribute.field)} >= 0)`;\n      }\n\n      template = attribute.type.toString();\n      template += unsignedTemplate;\n    } else {\n      template = \"\";\n    }\n\n    if (attribute.type && attribute.type !== \"TEXT\" && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (!attribute.autoIncrement) {\n      if (attribute.allowNull === false) {\n        template += \" NOT NULL\";\n      } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {\n        template += \" NULL\";\n      }\n    }\n\n    if (attribute.unique === true && !attribute.primaryKey) {\n      template += \" UNIQUE\";\n    }\n\n    if (attribute.primaryKey) {\n      template += \" PRIMARY KEY\";\n    }\n\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier(\"id\")})`;\n      }\n\n      if (attribute.onDelete && attribute.onDelete.toUpperCase() !== \"NO ACTION\") {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      const attributeName = attribute.field || key;\n      result[attributeName] = this.attributeToSQL(attribute, __spreadValues({\n        attributeName\n      }, options));\n    }\n\n    return result;\n  }\n\n  createTrigger() {\n    throwMethodUndefined(\"createTrigger\");\n  }\n\n  dropTrigger() {\n    throwMethodUndefined(\"dropTrigger\");\n  }\n\n  renameTrigger() {\n    throwMethodUndefined(\"renameTrigger\");\n  }\n\n  createFunction() {\n    throwMethodUndefined(\"createFunction\");\n  }\n\n  dropFunction() {\n    throwMethodUndefined(\"dropFunction\");\n  }\n\n  renameFunction() {\n    throwMethodUndefined(\"renameFunction\");\n  }\n\n  getConstraintsOnColumn(table, column) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    column = this.getCatalogName(column);\n    const sql = [\"SELECT CONSTRAINT_NAME FROM user_cons_columns WHERE TABLE_NAME = \", this.escape(tableName), \" and OWNER = \", table.schema ? this.escape(schemaName) : \"USER\", \" and COLUMN_NAME = \", this.escape(column), \" AND POSITION IS NOT NULL ORDER BY POSITION\"].join(\"\");\n    return sql;\n  }\n\n  getForeignKeysQuery(table) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const sql = ['SELECT DISTINCT  a.table_name \"tableName\", a.constraint_name \"constraintName\", a.owner \"owner\",  a.column_name \"columnName\",', ' b.table_name \"referencedTableName\", b.column_name \"referencedColumnName\"', \" FROM all_cons_columns a\", \" JOIN all_constraints c ON a.owner = c.owner AND a.constraint_name = c.constraint_name\", \" JOIN all_cons_columns b ON c.owner = b.owner AND c.r_constraint_name = b.constraint_name\", \" WHERE c.constraint_type  = 'R'\", \" AND a.table_name = \", this.escape(tableName), \" AND a.owner = \", table.schema ? this.escape(schemaName) : \"USER\", \" ORDER BY a.table_name, a.constraint_name\"].join(\"\");\n    return sql;\n  }\n\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return this.dropConstraintQuery(tableName, foreignKey);\n  }\n\n  getPrimaryKeyConstraintQuery(table) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const sql = [\"SELECT cols.column_name, atc.identity_column \", \"FROM all_constraints cons, all_cons_columns cols \", \"INNER JOIN all_tab_columns atc ON(atc.table_name = cols.table_name AND atc.COLUMN_NAME = cols.COLUMN_NAME )\", \"WHERE cols.table_name = \", this.escape(tableName), \"AND cols.owner = \", table.schema ? this.escape(schemaName) : \"USER \", \"AND cons.constraint_type = 'P' \", \"AND cons.constraint_name = cols.constraint_name \", \"AND cons.owner = cols.owner \", \"ORDER BY cols.table_name, cols.position\"].join(\"\");\n    return sql;\n  }\n\n  dropConstraintQuery(tableName, constraintName) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${constraintName}`;\n  }\n\n  setIsolationLevelQuery(value, options) {\n    if (options.parent) {\n      return;\n    }\n\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return \"SET TRANSACTION ISOLATION LEVEL READ COMMITTED;\";\n\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        return \"SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;\";\n\n      default:\n        throw new Error(`isolation level \"${value}\" is not supported`);\n    }\n  }\n\n  getAliasToken() {\n    return \"\";\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)}`;\n    }\n\n    return \"BEGIN TRANSACTION\";\n  }\n\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n\n    return \"COMMIT TRANSACTION\";\n  }\n\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TO SAVEPOINT ${this.quoteIdentifier(transaction.name)}`;\n    }\n\n    return \"ROLLBACK TRANSACTION\";\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    let str;\n\n    if (smth instanceof Utils.Json) {\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition => `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);\n        return conditions.join(\" AND \");\n      }\n\n      if (smth.path) {\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          const paths = _.toPath(smth.path);\n\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (smth.value) {\n          str += util.format(\" = %s\", this.escape(smth.value));\n        }\n\n        return str;\n      }\n    }\n\n    if (smth instanceof Utils.Cast) {\n      if (smth.val instanceof Utils.SequelizeMethod) {\n        str = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);\n\n        if (smth.type === \"boolean\") {\n          str = `(CASE WHEN ${str}='true' THEN 1 ELSE 0 END)`;\n          return `CAST(${str} AS NUMBER)`;\n        }\n\n        if (smth.type === \"timestamptz\" && /json_value\\(/.test(str)) {\n          str = str.slice(0, -1);\n          return `${str} RETURNING TIMESTAMP WITH TIME ZONE)`;\n        }\n      }\n    }\n\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  }\n\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== \"string\") {\n      return false;\n    }\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf(\"(\");\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n\n        if (capturedToken === \"(\") {\n          openingBrackets++;\n        } else if (capturedToken === \")\") {\n          closingBrackets++;\n        } else if (capturedToken === \";\") {\n          hasInvalidToken = true;\n          break;\n        }\n\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    return hasJsonFunction;\n  }\n\n  jsonPathExtractionQuery(column, path) {\n    let paths = _.toPath(path);\n\n    const quotedColumn = this.isIdentifierQuoted(column) ? column : this.quoteIdentifier(column);\n    paths = paths.map(subPath => {\n      return /\\D/.test(subPath) ? Utils.addTicks(subPath, '\"') : subPath;\n    });\n    const pathStr = this.escape([\"$\"].concat(paths).join(\".\").replace(/\\.(\\d+)(?:(?=\\.)|$)/g, (__, digit) => `[${digit}]`));\n    return `json_value(${quotedColumn},${pathStr})`;\n  }\n\n  addLimitAndOffset(options, model) {\n    let fragment = \"\";\n    const offset = options.offset || 0,\n          isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n    let orders = {};\n\n    if (options.order) {\n      orders = this.getQueryOrders(options, model, isSubQuery);\n    }\n\n    if (options.limit || options.offset) {\n      if (!orders.mainQueryOrder || !orders.mainQueryOrder.length || isSubQuery && (!orders.subQueryOrder || !orders.subQueryOrder.length)) {\n        const tablePkFragment = `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(model.primaryKeyField)}`;\n        fragment += ` ORDER BY ${tablePkFragment}`;\n      }\n\n      if (options.offset || options.limit) {\n        fragment += ` OFFSET ${this.escape(offset)} ROWS`;\n      }\n\n      if (options.limit) {\n        fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n      }\n    }\n\n    return fragment;\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n\n  quoteIdentifier(identifier) {\n    let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const optForceQuote = force;\n    const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;\n    const rawIdentifier = Utils.removeTicks(identifier, '\"');\n    const regExp = /^(([\\w][\\w\\d_]*))$/g;\n\n    if (optForceQuote !== true && optQuoteIdentifiers === false && regExp.test(rawIdentifier) && !ORACLE_RESERVED_WORDS.includes(rawIdentifier.toUpperCase())) {\n      return rawIdentifier;\n    }\n\n    return Utils.addTicks(rawIdentifier, '\"');\n  }\n\n  bindParam(bind) {\n    let posOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return value => {\n      bind.push(value);\n      return `:${bind.length + posOffset}`;\n    };\n  }\n\n  authTestQuery() {\n    return \"SELECT 1+1 AS result FROM DUAL\";\n  }\n\n}\n\nfunction throwMethodUndefined(methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n}","map":{"version":3,"mappings":"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","names":["__export","OracleQueryGenerator","Utils","require","DataTypes","AbstractQueryGenerator","_","util","Transaction","ORACLE_RESERVED_WORDS","JSON_FUNCTION_REGEX","JSON_OPERATOR_REGEX","TOKEN_CAPTURE_REGEX","constructor","options","getCatalogName","value","quoteIdentifiers","quotedValue","quoteIdentifier","toUpperCase","getSchemaNameAndTableName","table","tableName","schemaName","schema","createSchema","quotedSchema","escape","join","showSchemasQuery","dropSchema","quoteTable","versionQuery","createTableQuery","attributes","primaryKeys","foreignKeys","Object","create","attrStr","checkStr","values","attr","prototype","hasOwnProperty","call","dataType","includes","push","match","replace","trim","pkString","map","pk","length","fkey","indexOf","indexes","idxToDelete","forEach","index","idx","unique","fields","field","attribute","canContinue","uniqueKeys","keys","fieldIdx","currUnique","i","indexName","name","constraintToAdd","splice","each","columns","canBeUniq","primaryKey","currField","isString","attrToReplace","query","joinSQLFragments","tableExistsQuery","describeTableQuery","currTableName","renameTableQuery","before","after","showConstraintsQuery","showTablesQuery","dropTableQuery","addIndexQuery","rawTablename","addConstraintQuery","constraintSnippet","getConstraintSnippet","addColumnQuery","key","attributeToSQL","attributeName","context","removeColumnQuery","_alterForeignKeyConstraint","definition","attributeNameConstant","schemaNameConstant","tableNameConstant","getConsNameQuery","secondQuery","_modifyQuery","changeColumnQuery","sql","renameColumnQuery","attrBefore","newName","populateInsertQueryReturnIntoBinds","returningModelAttributes","returnTypes","inbindLength","returnAttributes","oracledb","sequelize","connectionManager","lib","outBindAttributes","outbind","outbindParam","bindParam","element","startsWith","substring","assign","_getBindDef","dir","BIND_OUT","returnAttribute","format","upsertQuery","insertValues","updateValues","where","model","rawAttributes","updateQuery","bind","insertQuery","result","bulkInsertQuery","fieldValueHashes","fieldMappedAttributes","executeMany","tuples","allColumns","inBindBindDefMap","outBindBindDefMap","fieldValueHash","forOwn","autoIncrement","inBindPosition","tuple","inbindParam","tempBindPositions","Error","returnColumn","returnColumnBindPositions","insertColumns","bindDef","type","BIND_IN","inbindAttributes","truncateTableQuery","deleteQuery","getWhereConditions","queryTmpl","limit","whereTmpl","showIndexesQuery","owner","removeIndexQuery","indexNameOrAttributes","underscore","isPlainObject","onUpdate","references","Model","log","onDelete","template","ENUM","toSql","JSON","BOOLEAN","DOUBLE","unsignedTemplate","_unsigned","toString","_binary","defaultValueSchemable","defaultValue","allowNull","withoutForeignKeyConstraints","attributesToSQL","__spreadValues","createTrigger","throwMethodUndefined","dropTrigger","renameTrigger","createFunction","dropFunction","renameFunction","getConstraintsOnColumn","column","getForeignKeysQuery","dropForeignKeyQuery","foreignKey","dropConstraintQuery","getPrimaryKeyConstraintQuery","constraintName","setIsolationLevelQuery","parent","ISOLATION_LEVELS","READ_UNCOMMITTED","READ_COMMITTED","REPEATABLE_READ","getAliasToken","startTransactionQuery","transaction","commitTransactionQuery","rollbackTransactionQuery","handleSequelizeMethod","smth","factory","prepend","str","Json","conditions","parseConditionObject","condition","jsonPathExtractionQuery","path","tail","_checkValidJsonStatement","paths","toPath","shift","Cast","val","SequelizeMethod","test","slice","stmt","currentIndex","openingBrackets","closingBrackets","hasJsonFunction","hasInvalidToken","string","substr","functionMatches","exec","operatorMatches","tokenMatches","capturedToken","quotedColumn","isIdentifierQuoted","subPath","addTicks","pathStr","concat","__","digit","addLimitAndOffset","fragment","offset","isSubQuery","hasIncludeWhere","hasIncludeRequired","hasMultiAssociation","orders","order","getQueryOrders","mainQueryOrder","subQueryOrder","tablePkFragment","tableAs","primaryKeyField","booleanValue","identifier","force","optForceQuote","optQuoteIdentifiers","rawIdentifier","removeTicks","regExp","posOffset","authTestQuery","methodName"],"sources":["/Users/aurele/node_modules/sequelize/src/dialects/oracle/query-generator.js"],"sourcesContent":["// Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved\n\n'use strict';\n\nconst Utils = require('../../utils');\nconst DataTypes = require('../../data-types');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\nconst _ = require('lodash');\nconst util = require('util');\nconst Transaction = require('../../transaction');\n\n/**\n * list of reserved words in Oracle DB 21c\n * source: https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-7B72E154-677A-4342-A1EA-C74C1EA928E6\n *\n * @private\n */\nconst ORACLE_RESERVED_WORDS = ['ACCESS', 'ADD', 'ALL', 'ALTER', 'AND', 'ANY', 'ARRAYLEN', 'AS', 'ASC', 'AUDIT', 'BETWEEN', 'BY', 'CHAR', 'CHECK', 'CLUSTER', 'COLUMN', 'COMMENT', 'COMPRESS', 'CONNECT', 'CREATE', 'CURRENT', 'DATE', 'DECIMAL', 'DEFAULT', 'DELETE', 'DESC', 'DISTINCT', 'DROP', 'ELSE', 'EXCLUSIVE', 'EXISTS', 'FILE', 'FLOAT', 'FOR', 'FROM', 'GRANT', 'GROUP', 'HAVING', 'IDENTIFIED', 'IMMEDIATE', 'IN', 'INCREMENT', 'INDEX', 'INITIAL', 'INSERT', 'INTEGER', 'INTERSECT', 'INTO', 'IS', 'LEVEL', 'LIKE', 'LOCK', 'LONG', 'MAXEXTENTS', 'MINUS', 'MODE', 'MODIFY', 'NOAUDIT', 'NOCOMPRESS', 'NOT', 'NOTFOUND', 'NOWAIT', 'NULL', 'NUMBER', 'OF', 'OFFLINE', 'ON', 'ONLINE', 'OPTION', 'OR', 'ORDER', 'PCTFREE', 'PRIOR', 'PRIVILEGES', 'PUBLIC', 'RAW', 'RENAME', 'RESOURCE', 'REVOKE', 'ROW', 'ROWID', 'ROWLABEL', 'ROWNUM', 'ROWS', 'SELECT', 'SESSION', 'SET', 'SHARE', 'SIZE', 'SMALLINT', 'SQLBUF', 'START', 'SUCCESSFUL', 'SYNONYM', 'SYSDATE', 'TABLE', 'THEN', 'TO', 'TRIGGER', 'UID', 'UNION', 'UNIQUE', 'UPDATE', 'USER', 'VALIDATE', 'VALUES', 'VARCHAR', 'VARCHAR2', 'VIEW', 'WHENEVER', 'WHERE', 'WITH'];\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n\nexport class OracleQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n  }\n\n  /**\n   * Returns the value as it is stored in the Oracle DB\n   *\n   * @param {string} value\n   */\n  getCatalogName(value) {\n    if (value) {\n      if (this.options.quoteIdentifiers === false) {\n        const quotedValue = this.quoteIdentifier(value);\n        if (quotedValue === value) {\n          value = value.toUpperCase();\n        }\n      }\n    }\n    return value;\n  }\n\n  /**\n   * Returns the tableName and schemaName as it is stored the Oracle DB\n   *\n   * @param {object|string} table\n   */\n  getSchemaNameAndTableName(table) {\n    const tableName = this.getCatalogName(table.tableName || table);\n    const schemaName = this.getCatalogName(table.schema);\n    return [tableName, schemaName];\n  }\n\n  createSchema(schema) {\n    const quotedSchema = this.quoteIdentifier(schema);\n    return [\n      'DECLARE',\n      'USER_FOUND BOOLEAN := FALSE;',\n      'BEGIN',\n      ' BEGIN',\n      '   EXECUTE IMMEDIATE ',\n      this.escape(`CREATE USER ${quotedSchema} IDENTIFIED BY 12345 DEFAULT TABLESPACE USERS`),\n      ';',\n      '   EXCEPTION WHEN OTHERS THEN',\n      '     IF SQLCODE != -1920 THEN',\n      '       RAISE;',\n      '     ELSE',\n      '       USER_FOUND := TRUE;',\n      '     END IF;',\n      ' END;',\n      ' IF NOT USER_FOUND THEN',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`GRANT \"CONNECT\" TO ${quotedSchema}`),\n      ';',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`GRANT CREATE TABLE TO ${quotedSchema}`),\n      ';',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`GRANT CREATE VIEW TO ${quotedSchema}`),\n      ';',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`GRANT CREATE ANY TRIGGER TO ${quotedSchema}`),\n      ';',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`GRANT CREATE ANY PROCEDURE TO ${quotedSchema}`),\n      ';',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`GRANT CREATE SEQUENCE TO ${quotedSchema}`),\n      ';',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`GRANT CREATE SYNONYM TO ${quotedSchema}`),\n      ';',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`ALTER USER ${quotedSchema} QUOTA UNLIMITED ON USERS`),\n      ';',\n      ' END IF;',\n      'END;'\n    ].join(' ');\n  }\n\n  showSchemasQuery() {\n    return 'SELECT USERNAME AS \"schema_name\" FROM ALL_USERS WHERE COMMON = (\\'NO\\') AND USERNAME != user';\n  }\n\n  dropSchema(schema) {\n    return [\n      'BEGIN',\n      'EXECUTE IMMEDIATE ',\n      this.escape(`DROP USER ${this.quoteTable(schema)} CASCADE`),\n      ';',\n      'EXCEPTION WHEN OTHERS THEN',\n      '  IF SQLCODE != -1918 THEN',\n      '    RAISE;',\n      '  END IF;',\n      'END;'\n    ].join(' ');\n  }\n\n  versionQuery() {\n    return \"SELECT VERSION_FULL FROM PRODUCT_COMPONENT_VERSION WHERE PRODUCT LIKE 'Oracle%'\";\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    const primaryKeys = [],\n      foreignKeys = Object.create(null),\n      attrStr = [],\n      checkStr = [];\n\n    const values = {\n      table: this.quoteTable(tableName)\n    };\n\n    // Starting by dealing with all attributes\n    for (let attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n      const dataType = attributes[attr];\n      attr = this.quoteIdentifier(attr);\n\n      // ORACLE doesn't support inline REFERENCES declarations: move to the end\n      if (dataType.includes('PRIMARY KEY')) {\n        // Primary key\n        primaryKeys.push(attr);\n        if (dataType.includes('REFERENCES')) {\n          const match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${attr} ${match[1].replace(/PRIMARY KEY/, '')}`);\n\n          // match[2] already has foreignKeys in correct format so we don't need to replace\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${attr} ${dataType.replace(/PRIMARY KEY/, '').trim()}`);\n        }\n      } else if (dataType.includes('REFERENCES')) {\n        // Foreign key\n        const match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${attr} ${match[1]}`);\n\n        // match[2] already has foreignKeys in correct format so we don't need to replace\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${attr} ${dataType}`);\n      }\n    }\n\n    values['attributes'] = attrStr.join(', ');\n\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (pkString.length > 0) {\n      values.attributes += `,PRIMARY KEY (${pkString})`;\n    }\n\n    // Dealing with FKs\n    for (const fkey in foreignKeys) {\n      if (!Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) continue; \n      // Oracle default response for FK, doesn't support if defined\n      if (foreignKeys[fkey].indexOf('ON DELETE NO ACTION') > -1) {\n        foreignKeys[fkey] = foreignKeys[fkey].replace('ON DELETE NO ACTION', '');\n      }\n      values.attributes += `,FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n    }\n\n    if (checkStr.length > 0) {\n      values.attributes += `, ${checkStr.join(', ')}`;\n    }\n\n    // Specific case for unique indexes with Oracle, we have to set the constraint on the column, if not, no FK will be possible (ORA-02270: no matching unique or primary key for this column-list)\n    if (options && options.indexes && options.indexes.length > 0) {\n      const idxToDelete = [];\n      options.indexes.forEach((index, idx) => {\n        if ('unique' in index && (index.unique === true || index.unique.length > 0 && index.unique !== false)) {\n          // If unique index, transform to unique constraint on column\n          const fields = index.fields.map(field => {\n            if (typeof field === 'string') {\n              return field;\n            } \n            return field.attribute;\n            \n          });\n\n          // Now we have to be sure that the constraint isn't already declared in uniqueKeys\n          let canContinue = true;\n          if (options.uniqueKeys) {\n            const keys = Object.keys(options.uniqueKeys);\n\n            for (let fieldIdx = 0; fieldIdx < keys.length; fieldIdx++) {\n              const currUnique = options.uniqueKeys[keys[fieldIdx]];\n\n              if (currUnique.fields.length === fields.length) {\n                // lengths are the same, possible same constraint\n                for (let i = 0; i < currUnique.fields.length; i++) {\n                  const field = currUnique.fields[i];\n\n                  if (_.includes(fields, field)) {\n                    canContinue = false;\n                  } else {\n                    // We have at least one different column, even if we found the same columns previously, we let the constraint be created\n                    canContinue = true;\n                    break;\n                  }\n                }\n              }\n            }\n\n            if (canContinue) {\n              const indexName = 'name' in index ? index.name : '';\n              const constraintToAdd = {\n                name: indexName,\n                fields\n              };\n              if (!('uniqueKeys' in options)) {\n                options.uniqueKeys = {};\n              }\n\n              options.uniqueKeys[indexName] = constraintToAdd;\n              idxToDelete.push(idx);\n            } else {\n              // The constraint already exists, we remove it from the list\n              idxToDelete.push(idx);\n            }\n          }\n        }\n      });\n      idxToDelete.forEach(idx => {\n        options.indexes.splice(idx, 1);\n      });\n    }\n\n    if (options && !!options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        let canBeUniq = false;\n\n        // Check if we can create the unique key\n        primaryKeys.forEach(primaryKey => {\n          // We can create an unique constraint if it's not on the primary key AND if it doesn't have unique in its definition\n          // We replace quotes in primary key with ''\n          // Primary key would be a list with double quotes in it so we remove the double quotes\n          primaryKey = primaryKey.replace(/\"/g, '');\n\n          // We check if the unique indexes are already a part of primary key or not\n          // If it is not then we set canbeuniq to true and add a unique constraint to these fields.\n          // Else we can ignore unique constraint on these\n          if (!_.includes(columns.fields, primaryKey)) {\n            canBeUniq = true;\n          }\n        });\n\n        columns.fields.forEach(field => {\n          let currField = '';\n          if (!_.isString(field)) {\n            currField = field.attribute.replace(/[.,\"\\s]/g, '');\n          } else {\n            currField = field.replace(/[.,\"\\s]/g, '');\n          }\n          if (currField in attributes) {\n            // If canBeUniq is false we need not replace the UNIQUE for the attribute\n            // So we replace UNIQUE with '' only if there exists a primary key\n            if (attributes[currField].toUpperCase().indexOf('UNIQUE') > -1 && canBeUniq) {\n              // We generate the attribute without UNIQUE\n              const attrToReplace = attributes[currField].replace('UNIQUE', '');\n              // We replace in the final string\n              values.attributes = values.attributes.replace(attributes[currField], attrToReplace);\n            }\n          }\n        });\n\n        // Oracle cannot have an unique AND a primary key on the same fields, prior to the primary key\n        if (canBeUniq) {\n          const index = options.uniqueKeys[columns.name];\n          delete options.uniqueKeys[columns.name];\n          indexName = indexName.replace(/[.,\\s]/g, '');\n          columns.name = indexName;\n          options.uniqueKeys[indexName] = index;\n\n          // Autogenerate Constraint name, if no indexName is given\n          if (indexName.length === 0) {\n            values.attributes += `,UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ') })`;\n          } else {\n            values.attributes +=\n              `, CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ') })`;\n          }\n        }\n      });\n    }\n\n    // we replace single quotes by two quotes in order for the execute statement to work\n    const query = Utils.joinSQLFragments([\n      'CREATE TABLE',\n      values.table,\n      `(${values.attributes})`\n    ]);\n\n    return Utils.joinSQLFragments([\n      'BEGIN',\n      'EXECUTE IMMEDIATE',\n      `${this.escape(query)};`,\n      'EXCEPTION WHEN OTHERS THEN',\n      'IF SQLCODE != -955 THEN',\n      'RAISE;',\n      'END IF;',\n      'END;'\n    ]);\n  }\n\n  tableExistsQuery(table) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    return `SELECT TABLE_NAME FROM ALL_TABLES WHERE TABLE_NAME = ${this.escape(tableName)} AND OWNER = ${table.schema ? this.escape(schemaName) : 'USER'}`;\n  }\n  \n  describeTableQuery(tableName, schema) {\n    const currTableName = this.getCatalogName(tableName.tableName || tableName);\n    schema = this.getCatalogName(schema);\n    // name, type, datalength (except number / nvarchar), datalength varchar, datalength number, nullable, default value, primary ?\n    return [\n      'SELECT atc.COLUMN_NAME, atc.DATA_TYPE, atc.DATA_LENGTH, atc.CHAR_LENGTH, atc.DEFAULT_LENGTH, atc.NULLABLE, ucc.constraint_type ',\n      'FROM all_tab_columns atc ',\n      'LEFT OUTER JOIN ',\n      '(SELECT acc.column_name, acc.table_name, ac.constraint_type FROM all_cons_columns acc INNER JOIN all_constraints ac ON acc.constraint_name = ac.constraint_name) ucc ',\n      'ON (atc.table_name = ucc.table_name AND atc.COLUMN_NAME = ucc.COLUMN_NAME) ',\n      schema\n        ? `WHERE (atc.OWNER = ${this.escape(schema)}) `\n        : 'WHERE atc.OWNER = USER ',\n      `AND (atc.TABLE_NAME = ${this.escape(currTableName)})`,\n      'ORDER BY atc.COLUMN_NAME, CONSTRAINT_TYPE DESC'\n    ].join('');\n  }\n\n  renameTableQuery(before, after) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(before),\n      'RENAME TO',\n      this.quoteTable(after)\n    ]);\n  }\n\n  showConstraintsQuery(table) {\n    const tableName = this.getCatalogName(table.tableName || table);\n    return `SELECT CONSTRAINT_NAME constraint_name FROM user_cons_columns WHERE table_name = ${this.escape(tableName)}`;\n  }\n\n  showTablesQuery() {\n    return 'SELECT owner as table_schema, table_name, 0 as lvl FROM all_tables where OWNER IN(SELECT USERNAME AS \"schema_name\" FROM ALL_USERS WHERE ORACLE_MAINTAINED = \\'N\\')';\n  }\n\n  dropTableQuery(tableName) {\n    return Utils.joinSQLFragments([\n      'BEGIN ',\n      'EXECUTE IMMEDIATE \\'DROP TABLE',\n      this.quoteTable(tableName),\n      'CASCADE CONSTRAINTS PURGE\\';',\n      'EXCEPTION WHEN OTHERS THEN',\n      ' IF SQLCODE != -942 THEN',\n      '   RAISE;',\n      ' END IF;',\n      'END;'\n    ]);\n  }\n\n  /*\n    Modifying the indexname so that it is prefixed with the schema name\n    otherwise Oracle tries to add the index to the USER schema\n   @overide\n  */\n  addIndexQuery(tableName, attributes, options, rawTablename) {\n    if (typeof tableName !== 'string' && attributes.name) {\n      attributes.name = `${tableName.schema}.${attributes.name}`;\n    }\n    return super.addIndexQuery(tableName, attributes, options, rawTablename);\n  }\n\n  addConstraintQuery(tableName, options) {\n    options = options || {};\n\n    const constraintSnippet = this.getConstraintSnippet(tableName, options);\n\n    tableName = this.quoteTable(tableName);\n    return `ALTER TABLE ${tableName} ADD ${constraintSnippet};`;\n  }\n\n  addColumnQuery(table, key, dataType) {\n    dataType.field = key;\n\n    const attribute = Utils.joinSQLFragments([\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, {\n        attributeName: key,\n        context: 'addColumn'\n      })\n    ]);\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(table),\n      'ADD',\n      attribute\n    ]);\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP COLUMN',\n      this.quoteIdentifier(attributeName),\n      ';'\n    ]);\n  }\n\n  /**\n   * Function to add new foreign key to the attribute \n   * Block for add and drop foreign key constraint query\n   * taking the assumption that there is a single column foreign key reference always\n   * i.e. we always do - FOREIGN KEY (a) reference B(a) during createTable queryGenerator\n   * so there would be one and only one match for a constraint name for each column\n   * and every foreign keyed column would have a different constraint name\n   * Since sequelize doesn't support multiple column foreign key, added complexity to\n   * add the feature isn't needed\n   *\n   * @param {string} definition The operation that needs to be performed on the attribute\n   * @param {string|object} table The table that needs to be altered\n   * @param {string} attributeName The name of the attribute which would get altered\n   */\n  _alterForeignKeyConstraint(definition, table, attributeName) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const attributeNameConstant = this.escape(this.getCatalogName(attributeName));\n    const schemaNameConstant = table.schema ? this.escape(this.getCatalogName(schemaName)) : 'USER';\n    const tableNameConstant = this.escape(this.getCatalogName(tableName));\n    const getConsNameQuery = [\n      'SELECT constraint_name INTO cons_name',\n      'FROM (',\n      '  SELECT DISTINCT cc.owner, cc.table_name, cc.constraint_name, cc.column_name AS cons_columns',\n      '  FROM all_cons_columns cc, all_constraints c',\n      '  WHERE cc.owner = c.owner',\n      '  AND cc.table_name = c.table_name',\n      '  AND cc.constraint_name = c.constraint_name',\n      '  AND c.constraint_type = \\'R\\'',\n      '  GROUP BY cc.owner, cc.table_name, cc.constraint_name, cc.column_name',\n      ')',\n      'WHERE owner =',\n      schemaNameConstant,\n      'AND table_name =',\n      tableNameConstant,\n      'AND cons_columns =',\n      attributeNameConstant,\n      ';'\n    ].join(' ');\n    const secondQuery = Utils.joinSQLFragments([\n      `ALTER TABLE ${this.quoteIdentifier(tableName)}`,\n      'ADD FOREIGN KEY',\n      `(${this.quoteIdentifier(attributeName)})`,\n      definition.replace(/.+?(?=REFERENCES)/, '')\n    ]);\n    return [\n      'BEGIN',\n      getConsNameQuery,\n      'EXCEPTION',\n      'WHEN NO_DATA_FOUND THEN',\n      ' CONS_NAME := NULL;',\n      'END;',\n      'IF CONS_NAME IS NOT NULL THEN',\n      ` EXECUTE IMMEDIATE 'ALTER TABLE ${this.quoteTable(table)} DROP CONSTRAINT \"'||CONS_NAME||'\"';`,\n      'END IF;',\n      `EXECUTE IMMEDIATE ${this.escape(secondQuery)};`\n    ].join(' ');\n  }\n\n  /**\n   * Function to alter table modify\n   *\n   * @param {string} definition The operation that needs to be performed on the attribute\n   * @param {object|string} table The table that needs to be altered\n   * @param {string} attributeName The name of the attribute which would get altered\n   */\n  _modifyQuery(definition, table, attributeName) {\n    const query = Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(table),\n      'MODIFY',\n      this.quoteIdentifier(attributeName),\n      definition\n    ]);\n    const secondQuery = query.replace('NOT NULL', '').replace('NULL', '');\n    return [\n      'BEGIN',\n      `EXECUTE IMMEDIATE ${this.escape(query)};`,\n      'EXCEPTION',\n      'WHEN OTHERS THEN',\n      ' IF SQLCODE = -1442 OR SQLCODE = -1451 THEN',\n      // We execute the statement without the NULL / NOT NULL clause if the first statement failed due to this\n      `   EXECUTE IMMEDIATE ${this.escape(secondQuery)};`,\n      ' ELSE',\n      '   RAISE;',\n      ' END IF;',\n      'END;'\n    ].join(' ');\n  }\n\n  changeColumnQuery(table, attributes) {\n    const sql = [\n      'DECLARE',\n      'CONS_NAME VARCHAR2(200);',\n      'BEGIN'\n    ];\n    for (const attributeName in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attributeName)) continue;\n      const definition = attributes[attributeName];\n      if (definition.match(/REFERENCES/)) {\n        sql.push(this._alterForeignKeyConstraint(definition, table, attributeName));\n      } else {\n        // Building the modify query\n        sql.push(this._modifyQuery(definition, table, attributeName));\n      }\n    }\n    sql.push('END;');\n    return sql.join(' ');\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const newName = Object.keys(attributes)[0];\n    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${this.quoteIdentifier(attrBefore)} TO ${this.quoteIdentifier(newName)}`;\n  }\n\n  /**\n   * Populates the returnAttributes array with outbind bindByPosition values\n   * and also the options.outBindAttributes map with bindDef for outbind of InsertQuery\n   *\n   * @param {Array} returningModelAttributes\n   * @param {Array} returnTypes\n   * @param {number} inbindLength\n   * @param {object} returnAttributes\n   * @param {object} options\n   *\n   * @private\n   */\n  populateInsertQueryReturnIntoBinds(returningModelAttributes, returnTypes, inbindLength, returnAttributes, options) {\n    const oracledb = this.sequelize.connectionManager.lib;\n    const outBindAttributes = Object.create(null);\n    const outbind = [];\n    const outbindParam = this.bindParam(outbind, inbindLength);\n    returningModelAttributes.forEach((element, index) => {\n      // generateReturnValues function quotes identifier based on the quoteIdentifier option\n      // If the identifier starts with a quote we remove it else we use it as is\n      if (element.startsWith('\"')) {\n        element = element.substring(1, element.length - 1);\n      }\n      outBindAttributes[element] = Object.assign(returnTypes[index]._getBindDef(oracledb), { dir: oracledb.BIND_OUT });\n      const returnAttribute = `${this.format(undefined, undefined, { context: 'INSERT' }, outbindParam)}`;\n      returnAttributes.push(returnAttribute);\n    });\n    options.outBindAttributes = outBindAttributes;\n  }\n\n  /**\n   * Override of upsertQuery, Oracle specific\n   * Using PL/SQL for finding the row\n   *\n   * @param {object|string} tableName\n   * @param {Array} insertValues\n   * @param {Array} updateValues\n   * @param {Array} where\n   * @param {object} model\n   * @param {object} options\n   */\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    const rawAttributes = model.rawAttributes;\n    const updateQuery = this.updateQuery(tableName, updateValues, where, options, rawAttributes);\n    // This bind is passed so that the insert query starts appending to this same bind array\n    options.bind = updateQuery.bind;\n    const insertQuery = this.insertQuery(tableName, insertValues, rawAttributes, options);\n\n    const sql = [\n      'DECLARE ',\n      'BEGIN ',\n      updateQuery.query ? [ \n        updateQuery.query,\n        '; ',\n        ' IF ( SQL%ROWCOUNT = 0 ) THEN ',\n        insertQuery.query,\n        ' :isUpdate := 0; ',\n        'ELSE ',\n        ' :isUpdate := 1; ',\n        ' END IF; '\n      ].join('') : [\n        insertQuery.query,\n        ' :isUpdate := 0; ',\n        // If there is a conflict on insert we ignore\n        'EXCEPTION WHEN OTHERS THEN',\n        ' IF SQLCODE != -1 THEN',\n        '   RAISE;',\n        ' END IF;'\n      ].join(''),\n      'END;'\n    ];\n\n    const query = sql.join('');\n    const result = { query };\n    \n    if (options.bindParam !== false) {\n      result.bind = updateQuery.bind || insertQuery.bind;\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns an insert into command for multiple values.\n   *\n   * @param {string} tableName\n   * @param {object} fieldValueHashes\n   * @param {object} options\n   * @param {object} fieldMappedAttributes\n   *\n   * @private\n   */\n  bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {\n    options = options || {};\n    options.executeMany = true;\n    fieldMappedAttributes = fieldMappedAttributes || {};\n\n    const tuples = [];\n    const allColumns = {};\n    const inBindBindDefMap = {};\n    const outBindBindDefMap = {};\n    const oracledb = this.sequelize.connectionManager.lib;\n\n    // Generating the allColumns map\n    // The data is provided as an array of objects. \n    // Each object may contain differing numbers of attributes. \n    // A set of the attribute names that are used in all objects must be determined. \n    // The allColumns map contains the column names and indicates whether the value is generated or not\n    // We set allColumns[key] to true if the field is an\n    // auto-increment field and the value given is null and fieldMappedAttributes[key]\n    // is valid for the specific column else it is set to false\n    for (const fieldValueHash of fieldValueHashes) {\n      _.forOwn(fieldValueHash, (value, key) => {\n        allColumns[key] = fieldMappedAttributes[key] && fieldMappedAttributes[key].autoIncrement === true && value === null;\n      });\n    }\n\n    // Building the inbind parameter\n    // A list that would have inbind positions like [:1, :2, :3...] to be used in generating sql string\n    let inBindPosition;\n    // Iterating over each row of the fieldValueHashes\n    for (const fieldValueHash of fieldValueHashes) {\n      // Has each column for a row after coverting it to appropriate format using this.format function\n      // like ['Mick', 'Broadstone', 2022-02-16T05:24:18.949Z, 2022-02-16T05:24:18.949Z],\n      const tuple = [];\n      // A function expression for this.bindParam/options.bindparam function\n      // This function is passed to this.format function which inserts column values to the tuple list\n      // using _bindParam/_stringify function in data-type.js file\n      const inbindParam = options.bindParam === undefined ? this.bindParam(tuple) : options.bindParam;\n      // We are iterating over each col\n      // and pushing the given values to tuple list using this.format function\n      // and also simultaneously generating the bindPosition\n      // tempBindPostions has the inbind positions\n      const tempBindPositions = Object.keys(allColumns).map(key => {\n        if (allColumns[key] === true) {\n          // We had set allAttributes[key] to true since at least one row for an auto increment column was null\n          // If we get any other row that has this specific column as non-null we must raise an error\n          // Since for an auto-increment column, either all row has to be null or all row has to be a non-null\n          if (fieldValueHash[key] !== null) {\n            throw Error('For an auto-increment column either all row must be null or non-null, a mix of null and non-null is not allowed!');\n          }\n          // Return DEFAULT for auto-increment column and if all values for the column is null in each row\n          return 'DEFAULT';\n        }\n        // Sanitizes the values given by the user and pushes it to the tuple list using inBindParam function and\n        // also generates the inbind position for the sql string for example (:1, :2, :3.....) which is a by product of the push\n        return this.format(fieldValueHash[key], fieldMappedAttributes[key], { context: 'INSERT' }, inbindParam);\n      });\n\n      // Even though the bind variable positions are calculated for each row we only retain the values for the first row \n      // since the values will be identical\n      if (!inBindPosition) {\n        inBindPosition = tempBindPositions;\n      }\n      // Adding the row to the array of rows that will be supplied to executeMany()\n      tuples.push(tuple);\n    }\n\n    // The columns that we are expecting to be returned from the DB like [\"id1\", \"id2\"...]\n    const returnColumn = [];\n    // The outbind positions for the returning columns like [:3, :4, :5....]\n    const returnColumnBindPositions = [];\n    // Has the columns name in which data would be inserted like [\"id\", \"name\".....]\n    const insertColumns = [];\n    // Iterating over the allColumns keys to get the bindDef for inbind and outbinds\n    // and also to get the list of insert and return column after applying this.quoteIdentifier\n    for (const key of Object.keys(allColumns)) {\n      // If fieldMappenAttributes[attr] is defined we generate the bindDef \n      // and return clause else we can skip it\n      if (fieldMappedAttributes[key]) {\n        // BindDef for the specific column\n        const bindDef = fieldMappedAttributes[key].type._getBindDef(oracledb);\n        if (allColumns[key]) {\n          // Binddef for outbinds\n          bindDef.dir = oracledb.BIND_OUT;\n          outBindBindDefMap[key] = bindDef;\n\n          // Building the outbind parameter list\n          // ReturnColumn has the column name for example \"id\", \"usedId\", quoting depends on quoteIdentifier option\n          returnColumn.push(this.quoteIdentifier(key));\n          // Pushing the outbind index to the returnColumnPositions to generate (:3, :4, :5)\n          // The start offset depend on the tuple length (bind array size of a particular row)\n          // the outbind position starts after the position where inbind position ends\n          returnColumnBindPositions.push(`:${tuples[0].length + returnColumn.length}`);\n        } else {\n          // Binddef for inbinds\n          bindDef.dir = oracledb.BIND_IN;\n          inBindBindDefMap[key] = bindDef;\n        }\n      }\n      // Quoting and pushing each insert column based on quoteIdentifier option\n      insertColumns.push(this.quoteIdentifier(key));\n    }\n   \n    // Generating the sql query\n    let query = Utils.joinSQLFragments([\n      'INSERT',\n      'INTO',\n      // Table name for the table in which data needs to inserted\n      this.quoteTable(tableName),\n      // Columns names for the columns of the table (example \"a\", \"b\", \"c\" - quoting depends on the quoteidentifier option)\n      `(${insertColumns.join(',')})`,\n      'VALUES',\n      // InBind position for the insert query (for example :1, :2, :3....)\n      `(${inBindPosition})`\n    ]);\n\n    // If returnColumn.length is > 0\n    // then the returning into clause is needed\n    if (returnColumn.length > 0) {\n      options.outBindAttributes = outBindBindDefMap;\n      query = Utils.joinSQLFragments([\n        query,\n        'RETURNING',\n        // List of return column (for example \"id\", \"userId\"....)\n        `${returnColumn.join(',')}`,\n        'INTO',\n        // List of outbindPosition (for example :4, :5, :6....)\n        // Start offset depends on where inbindPosition end\n        `${returnColumnBindPositions}`\n      ]);\n    }\n\n    // Binding the bind variable to result\n    const result = { query };\n    // Binding the bindParam to result\n    // Tuple has each row for the insert query\n    result.bind = tuples;\n    // Setting options.inbindAttribute\n    options.inbindAttributes = inBindBindDefMap;\n    return result;\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;\n  }\n\n  deleteQuery(tableName, where, options, model) {\n    options = options || {};\n\n    const table = tableName;\n\n    where = this.getWhereConditions(where, null, model, options);\n    let queryTmpl;\n    // delete with limit <l> and optional condition <e> on Oracle: DELETE FROM <t> WHERE rowid in (SELECT rowid FROM <t> WHERE <e> AND rownum <= <l>)\n    // Note that the condition <e> has to be in the subquery; otherwise, the subquery would select <l> arbitrary rows.\n    if (options.limit) {\n      const whereTmpl = where ? ` AND ${where}` : '';\n      queryTmpl =\n        `DELETE FROM ${this.quoteTable(table)} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(table)} WHERE rownum <= ${this.escape(options.limit)}${ \n          whereTmpl \n        })`;\n    } else {\n      const whereTmpl = where ? ` WHERE ${where}` : '';\n      queryTmpl = `DELETE FROM ${this.quoteTable(table)}${whereTmpl}`;\n    }\n    return queryTmpl;\n  }\n\n  showIndexesQuery(table) {\n    const [tableName, owner] = this.getSchemaNameAndTableName(table);\n    const sql = [\n      'SELECT i.index_name,i.table_name, i.column_name, u.uniqueness, i.descend, c.constraint_type ',\n      'FROM all_ind_columns i ',\n      'INNER JOIN all_indexes u ',\n      'ON (u.table_name = i.table_name AND u.index_name = i.index_name) ',\n      'LEFT OUTER JOIN all_constraints c ',\n      'ON (c.table_name = i.table_name AND c.index_name = i.index_name) ',\n      `WHERE i.table_name = ${this.escape(tableName)}`,\n      ' AND u.table_owner = ',\n      owner ? this.escape(owner) : 'USER',\n      ' ORDER BY index_name, column_position'\n    ];\n\n    return sql.join('');\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName }_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX ${this.quoteIdentifier(indexName)}`;\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    // TODO: Address on update cascade issue whether to throw error or ignore.\n    // Add this to documentation when merging to sequelize-main\n    // ON UPDATE CASCADE IS NOT SUPPORTED BY ORACLE.\n    attribute.onUpdate = '';\n\n    // handle self referential constraints\n    if (attribute.references) {\n      if (attribute.Model && attribute.Model.tableName === attribute.references.model) {\n        this.sequelize.log(\n          'Oracle does not support self referencial constraints, ' +\n            'we will remove it but we recommend restructuring your query'\n        );\n        attribute.onDelete = '';\n      }\n    }\n\n    let template;\n\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;\n\n      // enums are a special case\n      template = attribute.type.toSql();\n      template +=\n        ` CHECK (${this.quoteIdentifier(options.attributeName)} IN(${ \n          _.map(attribute.values, value => {\n            return this.escape(value);\n          }).join(', ') \n        }))`;\n      return template;\n    } \n    if (attribute.type instanceof DataTypes.JSON) {\n      template = attribute.type.toSql();\n      template += ` CHECK (${this.quoteIdentifier(options.attributeName)} IS JSON)`;\n      return template;\n    } \n    if (attribute.type instanceof DataTypes.BOOLEAN) {\n      template = attribute.type.toSql();\n      template +=\n        ` CHECK (${this.quoteIdentifier(options.attributeName)} IN('1', '0'))`;\n      return template;\n    } \n    if (attribute.autoIncrement) {\n      template = ' NUMBER(*,0) GENERATED BY DEFAULT ON NULL AS IDENTITY';\n    } else if (attribute.type && attribute.type.key === DataTypes.DOUBLE.key) {\n      template = attribute.type.toSql();\n    } else if (attribute.type) {\n      // setting it to false because oracle doesn't support unsigned int so put a check to make it behave like unsigned int\n      let unsignedTemplate = '';\n      if (attribute.type._unsigned) {\n        attribute.type._unsigned = false;\n        unsignedTemplate += ` check(${this.quoteIdentifier(attribute.field)} >= 0)`;\n      }\n      template = attribute.type.toString();\n      template += unsignedTemplate;\n    } else {\n      template = '';\n    }\n    \n\n    // Blobs/texts cannot have a defaultValue\n    if (\n      attribute.type &&\n      attribute.type !== 'TEXT' &&\n      attribute.type._binary !== true &&\n      Utils.defaultValueSchemable(attribute.defaultValue)\n    ) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (!attribute.autoIncrement) {\n      // If autoincrement, not null is setted automatically\n      if (attribute.allowNull === false) {\n        template += ' NOT NULL';\n      } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {\n        template += ' NULL';\n      }\n    }\n\n    if (attribute.unique === true && !attribute.primaryKey) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key) })`;\n      } else {\n        template += ` (${this.quoteIdentifier('id') })`;\n      }\n\n      if (attribute.onDelete && attribute.onDelete.toUpperCase() !== 'NO ACTION') {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n    }\n\n    return template;\n  }\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      const attributeName = attribute.field || key;\n      result[attributeName] = this.attributeToSQL(attribute, { attributeName, ...options });\n    }\n\n    return result;\n  }\n\n  createTrigger() {\n    throwMethodUndefined('createTrigger');\n  }\n\n  dropTrigger() {\n    throwMethodUndefined('dropTrigger');\n  }\n\n  renameTrigger() {\n    throwMethodUndefined('renameTrigger');\n  }\n\n  createFunction() {\n    throwMethodUndefined('createFunction');\n  }\n\n  dropFunction() {\n    throwMethodUndefined('dropFunction');\n  }\n\n  renameFunction() {\n    throwMethodUndefined('renameFunction');\n  }\n\n  getConstraintsOnColumn(table, column) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    column = this.getCatalogName(column);\n    const sql = [\n      'SELECT CONSTRAINT_NAME FROM user_cons_columns WHERE TABLE_NAME = ',\n      this.escape(tableName),\n      ' and OWNER = ',\n      table.schema ? this.escape(schemaName) : 'USER',\n      ' and COLUMN_NAME = ',\n      this.escape(column),\n      ' AND POSITION IS NOT NULL ORDER BY POSITION'\n    ].join('');\n\n    return sql;\n  }\n\n  getForeignKeysQuery(table) {\n    // We don't call quoteTable as we don't want the schema in the table name, Oracle seperates it on another field\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const sql = [\n      'SELECT DISTINCT  a.table_name \"tableName\", a.constraint_name \"constraintName\", a.owner \"owner\",  a.column_name \"columnName\",', \n      ' b.table_name \"referencedTableName\", b.column_name \"referencedColumnName\"',\n      ' FROM all_cons_columns a',\n      ' JOIN all_constraints c ON a.owner = c.owner AND a.constraint_name = c.constraint_name',\n      ' JOIN all_cons_columns b ON c.owner = b.owner AND c.r_constraint_name = b.constraint_name',\n      \" WHERE c.constraint_type  = 'R'\",\n      ' AND a.table_name = ',\n      this.escape(tableName),\n      ' AND a.owner = ',\n      table.schema ? this.escape(schemaName) : 'USER',\n      ' ORDER BY a.table_name, a.constraint_name'\n    ].join('');\n\n    return sql;\n  }\n\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return this.dropConstraintQuery(tableName, foreignKey);\n  }\n\n  getPrimaryKeyConstraintQuery(table) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const sql = [\n      'SELECT cols.column_name, atc.identity_column ',\n      'FROM all_constraints cons, all_cons_columns cols ',\n      'INNER JOIN all_tab_columns atc ON(atc.table_name = cols.table_name AND atc.COLUMN_NAME = cols.COLUMN_NAME )',\n      'WHERE cols.table_name = ',\n      this.escape(tableName),\n      'AND cols.owner = ',\n      table.schema ? this.escape(schemaName) : 'USER ',\n      \"AND cons.constraint_type = 'P' \",\n      'AND cons.constraint_name = cols.constraint_name ',\n      'AND cons.owner = cols.owner ',\n      'ORDER BY cols.table_name, cols.position'\n    ].join('');\n\n    return sql;\n  }\n\n  dropConstraintQuery(tableName, constraintName) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${constraintName}`;\n  }\n\n  setIsolationLevelQuery(value, options) {\n    if (options.parent) {\n      return;\n    }\n\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return 'SET TRANSACTION ISOLATION LEVEL READ COMMITTED;';\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        // Serializable mode is equal to Snapshot Isolation (SI) \n        // defined in ANSI std.\n        return 'SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;';\n      default:\n        throw new Error(`isolation level \"${value}\" is not supported`);\n    }\n  }\n\n  getAliasToken() {\n    return '';\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)}`;\n    }\n\n    return 'BEGIN TRANSACTION';\n  }\n\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n\n    return 'COMMIT TRANSACTION';\n  }\n\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TO SAVEPOINT ${this.quoteIdentifier(transaction.name)}`;\n    }\n\n    return 'ROLLBACK TRANSACTION';\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    let str;\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition =>\n          `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`\n        );\n\n        return conditions.join(' AND ');\n      }\n      if (smth.path) {\n\n        // Allow specifying conditions using the sqlite json functions\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json property accessors\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    }\n    if (smth instanceof Utils.Cast) {\n      if (smth.val instanceof Utils.SequelizeMethod) {\n        str = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);\n        if (smth.type === 'boolean') {\n          str = `(CASE WHEN ${str}='true' THEN 1 ELSE 0 END)`;\n          return `CAST(${str} AS NUMBER)`;\n        } if (smth.type === 'timestamptz' && /json_value\\(/.test(str)) {\n          str = str.slice(0, -1);\n          return `${str} RETURNING TIMESTAMP WITH TIME ZONE)`;\n        }\n      }\n    }\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  }\n\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  }\n\n  jsonPathExtractionQuery(column, path) {\n    let paths = _.toPath(path);\n    const quotedColumn = this.isIdentifierQuoted(column) ? column : this.quoteIdentifier(column);\n\n    paths = paths.map(subPath => {\n      return /\\D/.test(subPath) ? Utils.addTicks(subPath, '\"') : subPath;\n    });\n\n    const pathStr = this.escape(['$'].concat(paths).join('.').replace(/\\.(\\d+)(?:(?=\\.)|$)/g, (__, digit) => `[${digit}]`));\n\n    return `json_value(${quotedColumn},${pathStr})`;\n  }\n\n  addLimitAndOffset(options, model) {\n    let fragment = '';\n    const offset = options.offset || 0,\n      isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n\n    let orders = {};\n    if (options.order) {\n      orders = this.getQueryOrders(options, model, isSubQuery);\n    }\n\n    if (options.limit || options.offset) {\n      // Add needed order by clause only when it is not provided\n      if (!orders.mainQueryOrder || !orders.mainQueryOrder.length || isSubQuery && (!orders.subQueryOrder || !orders.subQueryOrder.length)) {\n        const tablePkFragment = `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(model.primaryKeyField)}`;\n        fragment += ` ORDER BY ${tablePkFragment}`;\n      }\n\n      if (options.offset || options.limit) {\n        fragment += ` OFFSET ${this.escape(offset)} ROWS`;\n      }\n\n      if (options.limit) {\n        fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n      }\n    }\n\n    return fragment;\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n\n  quoteIdentifier(identifier, force = false) {\n    const optForceQuote = force;\n    const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;\n    const rawIdentifier = Utils.removeTicks(identifier, '\"');\n    const regExp = /^(([\\w][\\w\\d_]*))$/g;\n\n    if (\n      optForceQuote !== true &&\n      optQuoteIdentifiers === false &&\n      regExp.test(rawIdentifier) &&\n      !ORACLE_RESERVED_WORDS.includes(rawIdentifier.toUpperCase())\n    ) {\n      // In Oracle, if tables, attributes or alias are created double-quoted,\n      // they are always case sensitive. If they contain any lowercase\n      // characters, they must always be double-quoted otherwise it\n      // would get uppercased by the DB.\n      // Here, we strip quotes if we don't want case sensitivity.\n      return rawIdentifier;\n    }\n    return Utils.addTicks(rawIdentifier, '\"');\n  }\n\n  /**\n * It causes bindbyPosition like :1, :2, :3\n * We pass the val parameter so that the outBind indexes\n * starts after the inBind indexes end\n *\n * @param {Array} bind\n * @param {number} posOffset\n */\n  bindParam(bind, posOffset = 0) {\n    return value => {\n      bind.push(value);\n      return `:${bind.length + posOffset}`;\n    };\n  }\n\n  /**\n   * Returns the authenticate test query string\n   */\n  authTestQuery() {\n    return 'SELECT 1+1 AS result FROM DUAL';\n  }\n}\n\n/* istanbul ignore next */\nfunction throwMethodUndefined(methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n}\n"]},"metadata":{},"sourceType":"script"}