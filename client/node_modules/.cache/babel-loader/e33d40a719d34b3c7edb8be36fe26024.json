{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nconst _ = require(\"lodash\");\n\nconst Utils = require(\"./utils\");\n\nconst sequelizeError = require(\"./errors\");\n\nconst DataTypes = require(\"./data-types\");\n\nconst BelongsTo = require(\"./associations/belongs-to\");\n\nconst validator = require(\"./utils/validator-extras\").validator;\n\nconst {\n  promisify\n} = require(\"util\");\n\nclass InstanceValidator {\n  constructor(modelInstance, options) {\n    options = __spreadValues({\n      hooks: true\n    }, options);\n\n    if (options.fields && !options.skip) {\n      options.skip = _.difference(Object.keys(modelInstance.constructor.rawAttributes), options.fields);\n    } else {\n      options.skip = options.skip || [];\n    }\n\n    this.options = options;\n    this.modelInstance = modelInstance;\n    this.validator = validator;\n    this.errors = [];\n    this.inProgress = false;\n  }\n\n  async _validate() {\n    if (this.inProgress) throw new Error(\"Validations already in progress.\");\n    this.inProgress = true;\n    await Promise.all([this._perAttributeValidators(), this._customValidators()]);\n\n    if (this.errors.length) {\n      throw new sequelizeError.ValidationError(null, this.errors);\n    }\n  }\n\n  async validate() {\n    return await (this.options.hooks ? this._validateAndRunHooks() : this._validate());\n  }\n\n  async _validateAndRunHooks() {\n    const runHooks = this.modelInstance.constructor.runHooks.bind(this.modelInstance.constructor);\n    await runHooks(\"beforeValidate\", this.modelInstance, this.options);\n\n    try {\n      await this._validate();\n    } catch (error) {\n      const newError = await runHooks(\"validationFailed\", this.modelInstance, this.options, error);\n      throw newError || error;\n    }\n\n    await runHooks(\"afterValidate\", this.modelInstance, this.options);\n    return this.modelInstance;\n  }\n\n  async _perAttributeValidators() {\n    const validators = [];\n\n    _.forIn(this.modelInstance.rawAttributes, (rawAttribute, field) => {\n      if (this.options.skip.includes(field)) {\n        return;\n      }\n\n      const value = this.modelInstance.dataValues[field];\n\n      if (value instanceof Utils.SequelizeMethod) {\n        return;\n      }\n\n      if (!rawAttribute._autoGenerated && !rawAttribute.autoIncrement) {\n        this._validateSchema(rawAttribute, field, value);\n      }\n\n      if (Object.prototype.hasOwnProperty.call(this.modelInstance.validators, field)) {\n        validators.push(this._singleAttrValidate(value, field, rawAttribute.allowNull));\n      }\n    });\n\n    return await Promise.all(validators);\n  }\n\n  async _customValidators() {\n    const validators = [];\n\n    _.each(this.modelInstance.constructor.options.validate, (validator2, validatorType) => {\n      if (this.options.skip.includes(validatorType)) {\n        return;\n      }\n\n      const valprom = this._invokeCustomValidator(validator2, validatorType).catch(() => {});\n\n      validators.push(valprom);\n    });\n\n    return await Promise.all(validators);\n  }\n\n  async _singleAttrValidate(value, field, allowNull) {\n    if ((value === null || value === void 0) && !allowNull) {\n      return;\n    }\n\n    const validators = [];\n\n    _.forIn(this.modelInstance.validators[field], (test, validatorType) => {\n      if ([\"isUrl\", \"isURL\", \"isEmail\"].includes(validatorType)) {\n        if (typeof test === \"object\" && test !== null && test.msg) {\n          test = {\n            msg: test.msg\n          };\n        } else if (test === true) {\n          test = {};\n        }\n      }\n\n      if (typeof test === \"function\") {\n        validators.push(this._invokeCustomValidator(test, validatorType, true, value, field));\n        return;\n      }\n\n      if (value === null || value === void 0) {\n        return;\n      }\n\n      const validatorPromise = this._invokeBuiltinValidator(value, test, validatorType, field);\n\n      validatorPromise.catch(() => {});\n      validators.push(validatorPromise);\n    });\n\n    return Promise.all(validators.map(validator2 => validator2.catch(rejection => {\n      const isBuiltIn = !!rejection.validatorName;\n\n      this._pushError(isBuiltIn, field, rejection, value, rejection.validatorName, rejection.validatorArgs);\n    })));\n  }\n\n  async _invokeCustomValidator(validator2, validatorType, optAttrDefined, optValue, optField) {\n    let isAsync = false;\n    const validatorArity = validator2.length;\n    let asyncArity = 1;\n    let errorKey = validatorType;\n    let invokeArgs;\n\n    if (optAttrDefined) {\n      asyncArity = 2;\n      invokeArgs = optValue;\n      errorKey = optField;\n    }\n\n    if (validatorArity === asyncArity) {\n      isAsync = true;\n    }\n\n    if (isAsync) {\n      try {\n        if (optAttrDefined) {\n          return await promisify(validator2.bind(this.modelInstance, invokeArgs))();\n        }\n\n        return await promisify(validator2.bind(this.modelInstance))();\n      } catch (e) {\n        return this._pushError(false, errorKey, e, optValue, validatorType);\n      }\n    }\n\n    try {\n      return await validator2.call(this.modelInstance, invokeArgs);\n    } catch (e) {\n      return this._pushError(false, errorKey, e, optValue, validatorType);\n    }\n  }\n\n  async _invokeBuiltinValidator(value, test, validatorType, field) {\n    const valueString = String(value);\n\n    if (typeof validator[validatorType] !== \"function\") {\n      throw new Error(`Invalid validator function: ${validatorType}`);\n    }\n\n    const validatorArgs = this._extractValidatorArgs(test, validatorType, field);\n\n    if (!validator[validatorType](valueString, ...validatorArgs)) {\n      throw Object.assign(new Error(test.msg || `Validation ${validatorType} on ${field} failed`), {\n        validatorName: validatorType,\n        validatorArgs\n      });\n    }\n  }\n\n  _extractValidatorArgs(test, validatorType, field) {\n    let validatorArgs = test.args || test;\n    const isLocalizedValidator = typeof validatorArgs !== \"string\" && [\"isAlpha\", \"isAlphanumeric\", \"isMobilePhone\"].includes(validatorType);\n\n    if (!Array.isArray(validatorArgs)) {\n      if (validatorType === \"isImmutable\") {\n        validatorArgs = [validatorArgs, field, this.modelInstance];\n      } else if (isLocalizedValidator || validatorType === \"isIP\") {\n        validatorArgs = [];\n      } else {\n        validatorArgs = [validatorArgs];\n      }\n    } else {\n      validatorArgs = validatorArgs.slice(0);\n    }\n\n    return validatorArgs;\n  }\n\n  _validateSchema(rawAttribute, field, value) {\n    if (rawAttribute.allowNull === false && (value === null || value === void 0)) {\n      const association = Object.values(this.modelInstance.constructor.associations).find(association2 => association2 instanceof BelongsTo && association2.foreignKey === rawAttribute.fieldName);\n\n      if (!association || !this.modelInstance.get(association.associationAccessor)) {\n        const validators = this.modelInstance.validators[field];\n\n        const errMsg = _.get(validators, \"notNull.msg\", `${this.modelInstance.constructor.name}.${field} cannot be null`);\n\n        this.errors.push(new sequelizeError.ValidationErrorItem(errMsg, \"notNull Violation\", field, value, this.modelInstance, \"is_null\"));\n      }\n    }\n\n    if (rawAttribute.type instanceof DataTypes.STRING || rawAttribute.type instanceof DataTypes.TEXT || rawAttribute.type instanceof DataTypes.CITEXT) {\n      if (Array.isArray(value) || _.isObject(value) && !(value instanceof Utils.SequelizeMethod) && !Buffer.isBuffer(value)) {\n        this.errors.push(new sequelizeError.ValidationErrorItem(`${field} cannot be an array or an object`, \"string violation\", field, value, this.modelInstance, \"not_a_string\"));\n      }\n    }\n  }\n\n  _pushError(isBuiltin, errorKey, rawError, value, fnName, fnArgs) {\n    const message = rawError.message || rawError || \"Validation error\";\n    const error = new sequelizeError.ValidationErrorItem(message, \"Validation error\", errorKey, value, this.modelInstance, fnName, isBuiltin ? fnName : void 0, isBuiltin ? fnArgs : void 0);\n    error[InstanceValidator.RAW_KEY_NAME] = rawError;\n    this.errors.push(error);\n  }\n\n}\n\nInstanceValidator.RAW_KEY_NAME = \"original\";\nmodule.exports = InstanceValidator;\nmodule.exports.InstanceValidator = InstanceValidator;\nmodule.exports.default = InstanceValidator;","map":{"version":3,"mappings":"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","names":["_","require","Utils","sequelizeError","DataTypes","BelongsTo","validator","promisify","constructor","modelInstance","options","__spreadValues","hooks","fields","skip","difference","Object","keys","rawAttributes","errors","inProgress","Error","Promise","all","_perAttributeValidators","_customValidators","length","ValidationError","_validateAndRunHooks","_validate","runHooks","bind","error","newError","validators","forIn","rawAttribute","field","includes","value","dataValues","SequelizeMethod","_autoGenerated","autoIncrement","_validateSchema","prototype","hasOwnProperty","call","push","_singleAttrValidate","allowNull","each","validate","validator2","validatorType","valprom","_invokeCustomValidator","catch","test","msg","validatorPromise","_invokeBuiltinValidator","map","rejection","isBuiltIn","validatorName","_pushError","validatorArgs","optAttrDefined","optValue","optField","isAsync","validatorArity","asyncArity","errorKey","invokeArgs","e","valueString","String","_extractValidatorArgs","assign","args","isLocalizedValidator","Array","isArray","slice","association","values","associations","find","association2","foreignKey","fieldName","get","associationAccessor","errMsg","name","ValidationErrorItem","type","STRING","TEXT","CITEXT","isObject","Buffer","isBuffer","isBuiltin","rawError","fnName","fnArgs","message","InstanceValidator","RAW_KEY_NAME","module","exports","default"],"sources":["/Users/aurele/node_modules/sequelize/src/instance-validator.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('./utils');\nconst sequelizeError = require('./errors');\nconst DataTypes = require('./data-types');\nconst BelongsTo = require('./associations/belongs-to');\nconst validator = require('./utils/validator-extras').validator;\nconst { promisify } = require('util');\n\n/**\n * Instance Validator.\n *\n * @param {Instance} modelInstance The model instance.\n * @param {object} options A dictionary with options.\n *\n * @private\n */\nclass InstanceValidator {\n  constructor(modelInstance, options) {\n    options = {\n      // assign defined and default options\n      hooks: true,\n      ...options\n    };\n\n    if (options.fields && !options.skip) {\n      options.skip = _.difference(Object.keys(modelInstance.constructor.rawAttributes), options.fields);\n    } else {\n      options.skip = options.skip || [];\n    }\n\n    this.options = options;\n\n    this.modelInstance = modelInstance;\n\n    /**\n     * Exposes a reference to validator.js. This allows you to add custom validations using `validator.extend`\n     *\n     * @name validator\n     * @private\n     */\n    this.validator = validator;\n\n    /**\n     *  All errors will be stored here from the validations.\n     *\n     * @type {Array} Will contain keys that correspond to attributes which will\n     *   be Arrays of Errors.\n     * @private\n     */\n    this.errors = [];\n\n    /**\n     * @type {boolean} Indicates if validations are in progress\n     * @private\n     */\n    this.inProgress = false;\n  }\n\n  /**\n   * The main entry point for the Validation module, invoke to start the dance.\n   *\n   * @returns {Promise}\n   * @private\n   */\n  async _validate() {\n    if (this.inProgress) throw new Error('Validations already in progress.');\n\n    this.inProgress = true;\n\n    await Promise.all([\n      this._perAttributeValidators(),\n      this._customValidators()\n    ]);\n\n    if (this.errors.length) {\n      throw new sequelizeError.ValidationError(null, this.errors);\n    }\n  }\n\n  /**\n   * Invoke the Validation sequence and run validation hooks if defined\n   *   - Before Validation Model Hooks\n   *   - Validation\n   *   - On validation success: After Validation Model Hooks\n   *   - On validation failure: Validation Failed Model Hooks\n   *\n   * @returns {Promise}\n   * @private\n   */\n  async validate() {\n    return await (this.options.hooks ? this._validateAndRunHooks() : this._validate());\n  }\n\n  /**\n   * Invoke the Validation sequence and run hooks\n   *   - Before Validation Model Hooks\n   *   - Validation\n   *   - On validation success: After Validation Model Hooks\n   *   - On validation failure: Validation Failed Model Hooks\n   *\n   * @returns {Promise}\n   * @private\n   */\n  async _validateAndRunHooks() {\n    const runHooks = this.modelInstance.constructor.runHooks.bind(this.modelInstance.constructor);\n    await runHooks('beforeValidate', this.modelInstance, this.options);\n\n    try {\n      await this._validate();\n    } catch (error) {\n      const newError = await runHooks('validationFailed', this.modelInstance, this.options, error);\n      throw newError || error;\n    }\n\n    await runHooks('afterValidate', this.modelInstance, this.options);\n    return this.modelInstance;\n  }\n\n  /**\n   * Will run all the validators defined per attribute (built-in validators and custom validators)\n   *\n   * @returns {Promise<Array>}\n   * @private\n   */\n  async _perAttributeValidators() {\n    // promisify all attribute invocations\n    const validators = [];\n\n    _.forIn(this.modelInstance.rawAttributes, (rawAttribute, field) => {\n      if (this.options.skip.includes(field)) {\n        return;\n      }\n\n      const value = this.modelInstance.dataValues[field];\n\n      if (value instanceof Utils.SequelizeMethod) {\n        return;\n      }\n\n      if (!rawAttribute._autoGenerated && !rawAttribute.autoIncrement) {\n        // perform validations based on schema\n        this._validateSchema(rawAttribute, field, value);\n      }\n\n      if (Object.prototype.hasOwnProperty.call(this.modelInstance.validators, field)) {\n        validators.push(this._singleAttrValidate(value, field, rawAttribute.allowNull));\n      }\n    });\n\n    return await Promise.all(validators);\n  }\n\n  /**\n   * Will run all the custom validators defined in the model's options.\n   *\n   * @returns {Promise<Array>}\n   * @private\n   */\n  async _customValidators() {\n    const validators = [];\n    _.each(this.modelInstance.constructor.options.validate, (validator, validatorType) => {\n      if (this.options.skip.includes(validatorType)) {\n        return;\n      }\n\n      const valprom = this._invokeCustomValidator(validator, validatorType)\n        // errors are handled in settling, stub this\n        .catch(() => {});\n\n      validators.push(valprom);\n    });\n\n    return await Promise.all(validators);\n  }\n\n  /**\n   * Validate a single attribute with all the defined built-in validators and custom validators.\n   *\n   * @private\n   *\n   * @param {*} value Anything.\n   * @param {string} field The field name.\n   * @param {boolean} allowNull Whether or not the schema allows null values\n   *\n   * @returns {Promise} A promise, will always resolve, auto populates error on this.error local object.\n   */\n  async _singleAttrValidate(value, field, allowNull) {\n    // If value is null and allowNull is false, no validators should run (see #9143)\n    if ((value === null || value === undefined) && !allowNull) {\n      // The schema validator (_validateSchema) has already generated the validation error. Nothing to do here.\n      return;\n    }\n\n    // Promisify each validator\n    const validators = [];\n    _.forIn(this.modelInstance.validators[field], (test, validatorType) => {\n\n      if (['isUrl', 'isURL', 'isEmail'].includes(validatorType)) {\n        // Preserve backwards compat. Validator.js now expects the second param to isURL and isEmail to be an object\n        if (typeof test === 'object' && test !== null && test.msg) {\n          test = {\n            msg: test.msg\n          };\n        } else if (test === true) {\n          test = {};\n        }\n      }\n\n      // Custom validators should always run, except if value is null and allowNull is false (see #9143)\n      if (typeof test === 'function') {\n        validators.push(this._invokeCustomValidator(test, validatorType, true, value, field));\n        return;\n      }\n\n      // If value is null, built-in validators should not run (only custom validators have to run) (see #9134).\n      if (value === null || value === undefined) {\n        return;\n      }\n\n      const validatorPromise = this._invokeBuiltinValidator(value, test, validatorType, field);\n      // errors are handled in settling, stub this\n      validatorPromise.catch(() => {});\n      validators.push(validatorPromise);\n    });\n\n    return Promise\n      .all(validators.map(validator => validator.catch(rejection => {\n        const isBuiltIn = !!rejection.validatorName;\n        this._pushError(isBuiltIn, field, rejection, value, rejection.validatorName, rejection.validatorArgs);\n      })));\n  }\n\n  /**\n   * Prepare and invoke a custom validator.\n   *\n   * @private\n   *\n   * @param {Function} validator The custom validator.\n   * @param {string} validatorType the custom validator type (name).\n   * @param {boolean} optAttrDefined Set to true if custom validator was defined from the attribute\n   * @param {*} optValue value for attribute\n   * @param {string} optField field for attribute\n   *\n   * @returns {Promise} A promise.\n   */\n  async _invokeCustomValidator(validator, validatorType, optAttrDefined, optValue, optField) {\n    let isAsync = false;\n\n    const validatorArity = validator.length;\n    // check if validator is async and requires a callback\n    let asyncArity = 1;\n    let errorKey = validatorType;\n    let invokeArgs;\n    if (optAttrDefined) {\n      asyncArity = 2;\n      invokeArgs = optValue;\n      errorKey = optField;\n    }\n    if (validatorArity === asyncArity) {\n      isAsync = true;\n    }\n\n    if (isAsync) {\n      try {\n        if (optAttrDefined) {\n          return await promisify(validator.bind(this.modelInstance, invokeArgs))();\n        }\n        return await promisify(validator.bind(this.modelInstance))();\n      } catch (e) {\n        return this._pushError(false, errorKey, e, optValue, validatorType);\n      }\n    }\n\n    try {\n      return await validator.call(this.modelInstance, invokeArgs);\n    } catch (e) {\n      return this._pushError(false, errorKey, e, optValue, validatorType);\n    }\n  }\n\n  /**\n   * Prepare and invoke a build-in validator.\n   *\n   * @private\n   *\n   * @param {*} value Anything.\n   * @param {*} test The test case.\n   * @param {string} validatorType One of known to Sequelize validators.\n   * @param {string} field The field that is being validated\n   *\n   * @returns {object} An object with specific keys to invoke the validator.\n   */\n  async _invokeBuiltinValidator(value, test, validatorType, field) {\n    // Cast value as string to pass new Validator.js string requirement\n    const valueString = String(value);\n    // check if Validator knows that kind of validation test\n    if (typeof validator[validatorType] !== 'function') {\n      throw new Error(`Invalid validator function: ${validatorType}`);\n    }\n\n    const validatorArgs = this._extractValidatorArgs(test, validatorType, field);\n\n    if (!validator[validatorType](valueString, ...validatorArgs)) {\n      throw Object.assign(new Error(test.msg || `Validation ${validatorType} on ${field} failed`), { validatorName: validatorType, validatorArgs });\n    }\n  }\n\n  /**\n   * Will extract arguments for the validator.\n   *\n   * @param {*} test The test case.\n   * @param {string} validatorType One of known to Sequelize validators.\n   * @param {string} field The field that is being validated.\n   *\n   * @private\n   */\n  _extractValidatorArgs(test, validatorType, field) {\n    let validatorArgs = test.args || test;\n    const isLocalizedValidator = typeof validatorArgs !== 'string' && ['isAlpha', 'isAlphanumeric', 'isMobilePhone'].includes(validatorType);\n\n    if (!Array.isArray(validatorArgs)) {\n      if (validatorType === 'isImmutable') {\n        validatorArgs = [validatorArgs, field, this.modelInstance];\n      } else if (isLocalizedValidator || validatorType === 'isIP') {\n        validatorArgs = [];\n      } else {\n        validatorArgs = [validatorArgs];\n      }\n    } else {\n      validatorArgs = validatorArgs.slice(0);\n    }\n    return validatorArgs;\n  }\n\n  /**\n   * Will validate a single field against its schema definition (isnull).\n   *\n   * @param {object} rawAttribute As defined in the Schema.\n   * @param {string} field The field name.\n   * @param {*} value anything.\n   *\n   * @private\n   */\n  _validateSchema(rawAttribute, field, value) {\n    if (rawAttribute.allowNull === false && (value === null || value === undefined)) {\n      const association = Object.values(this.modelInstance.constructor.associations).find(association => association instanceof BelongsTo && association.foreignKey === rawAttribute.fieldName);\n      if (!association || !this.modelInstance.get(association.associationAccessor)) {\n        const validators = this.modelInstance.validators[field];\n        const errMsg = _.get(validators, 'notNull.msg', `${this.modelInstance.constructor.name}.${field} cannot be null`);\n\n        this.errors.push(new sequelizeError.ValidationErrorItem(\n          errMsg,\n          'notNull Violation', // sequelizeError.ValidationErrorItem.Origins.CORE,\n          field,\n          value,\n          this.modelInstance,\n          'is_null'\n        ));\n      }\n    }\n\n    if (rawAttribute.type instanceof DataTypes.STRING || rawAttribute.type instanceof DataTypes.TEXT || rawAttribute.type instanceof DataTypes.CITEXT) {\n      if (Array.isArray(value) || _.isObject(value) && !(value instanceof Utils.SequelizeMethod) && !Buffer.isBuffer(value)) {\n        this.errors.push(new sequelizeError.ValidationErrorItem(\n          `${field} cannot be an array or an object`,\n          'string violation', // sequelizeError.ValidationErrorItem.Origins.CORE,\n          field,\n          value,\n          this.modelInstance,\n          'not_a_string'\n        ));\n      }\n    }\n  }\n\n  /**\n   * Signs all errors retaining the original.\n   *\n   * @param {boolean}       isBuiltin   - Determines if error is from builtin validator.\n   * @param {string}        errorKey    - name of invalid attribute.\n   * @param {Error|string}  rawError    - The original error.\n   * @param {string|number} value       - The data that triggered the error.\n   * @param {string}        fnName      - Name of the validator, if any\n   * @param {Array}         fnArgs      - Arguments for the validator [function], if any\n   *\n   * @private\n   */\n  _pushError(isBuiltin, errorKey, rawError, value, fnName, fnArgs) {\n    const message = rawError.message || rawError || 'Validation error';\n    const error = new sequelizeError.ValidationErrorItem(\n      message,\n      'Validation error', // sequelizeError.ValidationErrorItem.Origins.FUNCTION,\n      errorKey,\n      value,\n      this.modelInstance,\n      fnName,\n      isBuiltin ? fnName : undefined,\n      isBuiltin ? fnArgs : undefined\n    );\n\n    error[InstanceValidator.RAW_KEY_NAME] = rawError;\n\n    this.errors.push(error);\n  }\n}\n/**\n * The error key for arguments as passed by custom validators\n *\n * @type {string}\n * @private\n */\nInstanceValidator.RAW_KEY_NAME = 'original';\n\nmodule.exports = InstanceValidator;\nmodule.exports.InstanceValidator = InstanceValidator;\nmodule.exports.default = InstanceValidator;\n"]},"metadata":{},"sourceType":"script"}