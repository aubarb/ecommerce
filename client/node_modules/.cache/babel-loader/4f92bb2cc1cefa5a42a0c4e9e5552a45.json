{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nconst _ = require(\"lodash\");\n\nconst Utils = require(\"../../utils\");\n\nconst DataTypes = require(\"../../data-types\");\n\nconst Transaction = require(\"../../transaction\");\n\nconst QueryTypes = require(\"../../query-types\");\n\nclass QueryInterface {\n  constructor(sequelize, queryGenerator) {\n    this.sequelize = sequelize;\n    this.queryGenerator = queryGenerator;\n  }\n\n  async createDatabase(database, options) {\n    options = options || {};\n    const sql = this.queryGenerator.createDatabaseQuery(database, options);\n    return await this.sequelize.query(sql, options);\n  }\n\n  async dropDatabase(database, options) {\n    options = options || {};\n    const sql = this.queryGenerator.dropDatabaseQuery(database);\n    return await this.sequelize.query(sql, options);\n  }\n\n  async createSchema(schema, options) {\n    options = options || {};\n    const sql = this.queryGenerator.createSchema(schema);\n    return await this.sequelize.query(sql, options);\n  }\n\n  async dropSchema(schema, options) {\n    options = options || {};\n    const sql = this.queryGenerator.dropSchema(schema);\n    return await this.sequelize.query(sql, options);\n  }\n\n  async dropAllSchemas(options) {\n    options = options || {};\n\n    if (!this.queryGenerator._dialect.supports.schemas) {\n      return this.sequelize.drop(options);\n    }\n\n    const schemas = await this.showAllSchemas(options);\n    return Promise.all(schemas.map(schemaName => this.dropSchema(schemaName, options)));\n  }\n\n  async showAllSchemas(options) {\n    options = __spreadProps(__spreadValues({}, options), {\n      raw: true,\n      type: this.sequelize.QueryTypes.SELECT\n    });\n    const showSchemasSql = this.queryGenerator.showSchemasQuery(options);\n    const schemaNames = await this.sequelize.query(showSchemasSql, options);\n    return _.flatten(schemaNames.map(value => value.schema_name ? value.schema_name : value));\n  }\n\n  async databaseVersion(options) {\n    return await this.sequelize.query(this.queryGenerator.versionQuery(), __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.VERSION\n    }));\n  }\n\n  async createTable(tableName, attributes, options, model) {\n    let sql = \"\";\n    options = __spreadValues({}, options);\n\n    if (options && options.uniqueKeys) {\n      _.forOwn(options.uniqueKeys, uniqueKey => {\n        if (uniqueKey.customIndex === void 0) {\n          uniqueKey.customIndex = true;\n        }\n      });\n    }\n\n    if (model) {\n      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n    }\n\n    attributes = _.mapValues(attributes, attribute => this.sequelize.normalizeAttribute(attribute));\n    await this.ensureEnums(tableName, attributes, options, model);\n\n    if (!tableName.schema && (options.schema || !!model && model._schema)) {\n      tableName = this.queryGenerator.addSchema({\n        tableName,\n        _schema: !!model && model._schema || options.schema\n      });\n    }\n\n    attributes = this.queryGenerator.attributesToSQL(attributes, {\n      table: tableName,\n      context: \"createTable\",\n      withoutForeignKeyConstraints: options.withoutForeignKeyConstraints\n    });\n    sql = this.queryGenerator.createTableQuery(tableName, attributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n\n  async tableExists(tableName, options) {\n    const sql = this.queryGenerator.tableExistsQuery(tableName);\n    const out = await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.SHOWTABLES\n    }));\n    return out.length === 1;\n  }\n\n  async dropTable(tableName, options) {\n    options = __spreadValues({}, options);\n    options.cascade = options.cascade || options.force || false;\n    const sql = this.queryGenerator.dropTableQuery(tableName, options);\n    await this.sequelize.query(sql, options);\n  }\n\n  async _dropAllTables(tableNames, skip, options) {\n    for (const tableName of tableNames) {\n      if (!skip.includes(tableName.tableName || tableName)) {\n        await this.dropTable(tableName, __spreadProps(__spreadValues({}, options), {\n          cascade: true\n        }));\n      }\n    }\n  }\n\n  async dropAllTables(options) {\n    options = options || {};\n    const skip = options.skip || [];\n    const tableNames = await this.showAllTables(options);\n    const foreignKeys = await this.getForeignKeysForTables(tableNames, options);\n\n    for (const tableName of tableNames) {\n      let normalizedTableName = tableName;\n\n      if (_.isObject(tableName)) {\n        normalizedTableName = `${tableName.schema}.${tableName.tableName}`;\n      }\n\n      for (const foreignKey of foreignKeys[normalizedTableName]) {\n        await this.sequelize.query(this.queryGenerator.dropForeignKeyQuery(tableName, foreignKey));\n      }\n    }\n\n    await this._dropAllTables(tableNames, skip, options);\n  }\n\n  async renameTable(before, after, options) {\n    options = options || {};\n    const sql = this.queryGenerator.renameTableQuery(before, after);\n    return await this.sequelize.query(sql, options);\n  }\n\n  async showAllTables(options) {\n    options = __spreadProps(__spreadValues({}, options), {\n      raw: true,\n      type: QueryTypes.SHOWTABLES\n    });\n    const showTablesSql = this.queryGenerator.showTablesQuery(this.sequelize.config.database);\n    const tableNames = await this.sequelize.query(showTablesSql, options);\n    return _.flatten(tableNames);\n  }\n\n  async describeTable(tableName, options) {\n    let schema = null;\n    let schemaDelimiter = null;\n\n    if (typeof options === \"string\") {\n      schema = options;\n    } else if (typeof options === \"object\" && options !== null) {\n      schema = options.schema || null;\n      schemaDelimiter = options.schemaDelimiter || null;\n    }\n\n    if (typeof tableName === \"object\" && tableName !== null) {\n      schema = tableName.schema;\n      tableName = tableName.tableName;\n    }\n\n    const sql = this.queryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);\n    options = __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.DESCRIBE\n    });\n\n    try {\n      const data = await this.sequelize.query(sql, options);\n\n      if (_.isEmpty(data)) {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n\n      return data;\n    } catch (e) {\n      if (e.original && e.original.code === \"ER_NO_SUCH_TABLE\") {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n\n      throw e;\n    }\n  }\n\n  async addColumn(table, key, attribute, options) {\n    if (!table || !key || !attribute) {\n      throw new Error(\"addColumn takes at least 3 arguments (table, attribute name, attribute definition)\");\n    }\n\n    options = options || {};\n    attribute = this.sequelize.normalizeAttribute(attribute);\n    return await this.sequelize.query(this.queryGenerator.addColumnQuery(table, key, attribute), options);\n  }\n\n  async removeColumn(tableName, attributeName, options) {\n    return this.sequelize.query(this.queryGenerator.removeColumnQuery(tableName, attributeName), options);\n  }\n\n  normalizeAttribute(dataTypeOrOptions) {\n    let attribute;\n\n    if (Object.values(DataTypes).includes(dataTypeOrOptions)) {\n      attribute = {\n        type: dataTypeOrOptions,\n        allowNull: true\n      };\n    } else {\n      attribute = dataTypeOrOptions;\n    }\n\n    return this.sequelize.normalizeAttribute(attribute);\n  }\n\n  quoteIdentifier(identifier2, force) {\n    return this.queryGenerator.quoteIdentifier(identifier2, force);\n  }\n\n  quoteIdentifiers(identifiers) {\n    return this.queryGenerator.quoteIdentifiers(identifiers);\n  }\n\n  async changeColumn(tableName, attributeName, dataTypeOrOptions, options) {\n    options = options || {};\n    const query = this.queryGenerator.attributesToSQL({\n      [attributeName]: this.normalizeAttribute(dataTypeOrOptions)\n    }, {\n      context: \"changeColumn\",\n      table: tableName\n    });\n    const sql = this.queryGenerator.changeColumnQuery(tableName, query);\n    return this.sequelize.query(sql, options);\n  }\n\n  async assertTableHasColumn(tableName, columnName, options) {\n    const description = await this.describeTable(tableName, options);\n\n    if (description[columnName]) {\n      return description;\n    }\n\n    throw new Error(`Table ${tableName} doesn't have the column ${columnName}`);\n  }\n\n  async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {\n    options = options || {};\n    const data = (await this.assertTableHasColumn(tableName, attrNameBefore, options))[attrNameBefore];\n    const _options = {};\n    _options[attrNameAfter] = {\n      attribute: attrNameAfter,\n      type: data.type,\n      allowNull: data.allowNull,\n      defaultValue: data.defaultValue\n    };\n\n    if (data.defaultValue === null && !data.allowNull) {\n      delete _options[attrNameAfter].defaultValue;\n    }\n\n    const sql = this.queryGenerator.renameColumnQuery(tableName, attrNameBefore, this.queryGenerator.attributesToSQL(_options));\n    return await this.sequelize.query(sql, options);\n  }\n\n  async addIndex(tableName, attributes, options, rawTablename) {\n    if (!Array.isArray(attributes)) {\n      rawTablename = options;\n      options = attributes;\n      attributes = options.fields;\n    }\n\n    if (!rawTablename) {\n      rawTablename = tableName;\n    }\n\n    options = Utils.cloneDeep(options);\n    options.fields = attributes;\n    const sql = this.queryGenerator.addIndexQuery(tableName, options, rawTablename);\n    return await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {\n      supportsSearchPath: false\n    }));\n  }\n\n  async showIndex(tableName, options) {\n    const sql = this.queryGenerator.showIndexesQuery(tableName, options);\n    return await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.SHOWINDEXES\n    }));\n  }\n\n  async getForeignKeysForTables(tableNames, options) {\n    if (tableNames.length === 0) {\n      return {};\n    }\n\n    options = __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.FOREIGNKEYS\n    });\n    const results = await Promise.all(tableNames.map(tableName => this.sequelize.query(this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database), options)));\n    const result = {};\n    tableNames.forEach((tableName, i) => {\n      if (_.isObject(tableName)) {\n        tableName = `${tableName.schema}.${tableName.tableName}`;\n      }\n\n      result[tableName] = Array.isArray(results[i]) ? results[i].map(r => r.constraint_name) : [results[i] && results[i].constraint_name];\n      result[tableName] = result[tableName].filter(_.identity);\n    });\n    return result;\n  }\n\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const queryOptions = __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.FOREIGNKEYS\n    });\n\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database);\n    return this.sequelize.query(query, queryOptions);\n  }\n\n  async removeIndex(tableName, indexNameOrAttributes, options) {\n    options = options || {};\n    const sql = this.queryGenerator.removeIndexQuery(tableName, indexNameOrAttributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n\n  async addConstraint(tableName, options) {\n    if (!options.fields) {\n      throw new Error(\"Fields must be specified through options.fields\");\n    }\n\n    if (!options.type) {\n      throw new Error(\"Constraint type must be specified through options.type\");\n    }\n\n    options = Utils.cloneDeep(options);\n    const sql = this.queryGenerator.addConstraintQuery(tableName, options);\n    return await this.sequelize.query(sql, options);\n  }\n\n  async showConstraint(tableName, constraintName, options) {\n    const sql = this.queryGenerator.showConstraintsQuery(tableName, constraintName);\n    return await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.SHOWCONSTRAINTS\n    }));\n  }\n\n  async removeConstraint(tableName, constraintName, options) {\n    return this.sequelize.query(this.queryGenerator.removeConstraintQuery(tableName, constraintName), options);\n  }\n\n  async insert(instance, tableName, values, options) {\n    options = Utils.cloneDeep(options);\n    options.hasTrigger = instance && instance.constructor.options.hasTrigger;\n    const sql = this.queryGenerator.insertQuery(tableName, values, instance && instance.constructor.rawAttributes, options);\n    options.type = QueryTypes.INSERT;\n    options.instance = instance;\n    const results = await this.sequelize.query(sql, options);\n    if (instance) results[0].isNewRecord = false;\n    return results;\n  }\n\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = __spreadValues({}, options);\n    const model = options.model;\n    options.type = QueryTypes.UPSERT;\n    options.updateOnDuplicate = Object.keys(updateValues);\n    options.upsertKeys = options.conflictFields || [];\n\n    if (options.upsertKeys.length === 0) {\n      const primaryKeys = Object.values(model.primaryKeys).map(item => item.field);\n      const uniqueKeys = Object.values(model.uniqueKeys).filter(c => c.fields.length > 0).map(c => c.fields);\n      const indexKeys = Object.values(model._indexes).filter(c => c.unique && c.fields.length > 0).map(c => c.fields);\n\n      for (const field of options.updateOnDuplicate) {\n        const uniqueKey = uniqueKeys.find(fields => fields.includes(field));\n\n        if (uniqueKey) {\n          options.upsertKeys = uniqueKey;\n          break;\n        }\n\n        const indexKey = indexKeys.find(fields => fields.includes(field));\n\n        if (indexKey) {\n          options.upsertKeys = indexKey;\n          break;\n        }\n      }\n\n      if (options.upsertKeys.length === 0 || _.intersection(options.updateOnDuplicate, primaryKeys).length) {\n        options.upsertKeys = primaryKeys;\n      }\n\n      options.upsertKeys = _.uniq(options.upsertKeys);\n    }\n\n    const sql = this.queryGenerator.insertQuery(tableName, insertValues, model.rawAttributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n\n  async bulkInsert(tableName, records, options, attributes) {\n    options = __spreadValues({}, options);\n    options.type = QueryTypes.INSERT;\n    const results = await this.sequelize.query(this.queryGenerator.bulkInsertQuery(tableName, records, options, attributes), options);\n    return results[0];\n  }\n\n  async update(instance, tableName, values, identifier2, options) {\n    options = __spreadValues({}, options);\n    options.hasTrigger = instance && instance.constructor.options.hasTrigger;\n    const sql = this.queryGenerator.updateQuery(tableName, values, identifier2, options, instance.constructor.rawAttributes);\n    options.type = QueryTypes.UPDATE;\n    options.instance = instance;\n    return await this.sequelize.query(sql, options);\n  }\n\n  async bulkUpdate(tableName, values, identifier2, options, attributes) {\n    options = Utils.cloneDeep(options);\n    if (typeof identifier2 === \"object\") identifier2 = Utils.cloneDeep(identifier2);\n    const sql = this.queryGenerator.updateQuery(tableName, values, identifier2, options, attributes);\n    const table = _.isObject(tableName) ? tableName : {\n      tableName\n    };\n    const model = options.model ? options.model : _.find(this.sequelize.modelManager.models, {\n      tableName: table.tableName\n    });\n    options.type = QueryTypes.BULKUPDATE;\n    options.model = model;\n    return await this.sequelize.query(sql, options);\n  }\n\n  async delete(instance, tableName, identifier2, options) {\n    const cascades = [];\n    const sql = this.queryGenerator.deleteQuery(tableName, identifier2, {}, instance.constructor);\n    options = __spreadValues({}, options);\n\n    if (!!instance.constructor && !!instance.constructor.associations) {\n      const keys = Object.keys(instance.constructor.associations);\n      const length = keys.length;\n      let association;\n\n      for (let i = 0; i < length; i++) {\n        association = instance.constructor.associations[keys[i]];\n\n        if (association.options && association.options.onDelete && association.options.onDelete.toLowerCase() === \"cascade\" && association.options.useHooks === true) {\n          cascades.push(association.accessors.get);\n        }\n      }\n    }\n\n    for (const cascade of cascades) {\n      let instances = await instance[cascade](options);\n      if (!instances) continue;\n      if (!Array.isArray(instances)) instances = [instances];\n\n      for (const _instance of instances) await _instance.destroy(options);\n    }\n\n    options.instance = instance;\n    return await this.sequelize.query(sql, options);\n  }\n\n  async bulkDelete(tableName, where, options, model) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, {\n      limit: null\n    });\n\n    if (options.truncate === true) {\n      return this.sequelize.query(this.queryGenerator.truncateTableQuery(tableName, options), options);\n    }\n\n    if (typeof identifier === \"object\") where = Utils.cloneDeep(where);\n    return await this.sequelize.query(this.queryGenerator.deleteQuery(tableName, where, options, model), options);\n  }\n\n  async select(model, tableName, optionsArg) {\n    const options = __spreadProps(__spreadValues({}, optionsArg), {\n      type: QueryTypes.SELECT,\n      model\n    });\n\n    return await this.sequelize.query(this.queryGenerator.selectQuery(tableName, options, model), options);\n  }\n\n  async increment(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    options = Utils.cloneDeep(options);\n    const sql = this.queryGenerator.arithmeticQuery(\"+\", tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);\n    options.type = QueryTypes.UPDATE;\n    options.model = model;\n    return await this.sequelize.query(sql, options);\n  }\n\n  async decrement(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    options = Utils.cloneDeep(options);\n    const sql = this.queryGenerator.arithmeticQuery(\"-\", tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);\n    options.type = QueryTypes.UPDATE;\n    options.model = model;\n    return await this.sequelize.query(sql, options);\n  }\n\n  async rawSelect(tableName, options, attributeSelector, Model) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, {\n      raw: true,\n      plain: true,\n      type: QueryTypes.SELECT\n    });\n    const sql = this.queryGenerator.selectQuery(tableName, options, Model);\n\n    if (attributeSelector === void 0) {\n      throw new Error(\"Please pass an attribute selector!\");\n    }\n\n    const data = await this.sequelize.query(sql, options);\n\n    if (!options.plain) {\n      return data;\n    }\n\n    const result = data ? data[attributeSelector] : null;\n\n    if (!options || !options.dataType) {\n      return result;\n    }\n\n    const dataType = options.dataType;\n\n    if (dataType instanceof DataTypes.DECIMAL || dataType instanceof DataTypes.FLOAT) {\n      if (result !== null) {\n        return parseFloat(result);\n      }\n    }\n\n    if (dataType instanceof DataTypes.INTEGER || dataType instanceof DataTypes.BIGINT) {\n      if (result !== null) {\n        return parseInt(result, 10);\n      }\n    }\n\n    if (dataType instanceof DataTypes.DATE) {\n      if (result !== null && !(result instanceof Date)) {\n        return new Date(result);\n      }\n    }\n\n    return result;\n  }\n\n  async createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray, options) {\n    const sql = this.queryGenerator.createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray);\n    options = options || {};\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  async dropTrigger(tableName, triggerName, options) {\n    const sql = this.queryGenerator.dropTrigger(tableName, triggerName);\n    options = options || {};\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  async renameTrigger(tableName, oldTriggerName, newTriggerName, options) {\n    const sql = this.queryGenerator.renameTrigger(tableName, oldTriggerName, newTriggerName);\n    options = options || {};\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  async createFunction(functionName, params, returnType, language, body, optionsArray, options) {\n    const sql = this.queryGenerator.createFunction(functionName, params, returnType, language, body, optionsArray, options);\n    options = options || {};\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  async dropFunction(functionName, params, options) {\n    const sql = this.queryGenerator.dropFunction(functionName, params);\n    options = options || {};\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  async renameFunction(oldFunctionName, params, newFunctionName, options) {\n    const sql = this.queryGenerator.renameFunction(oldFunctionName, params, newFunctionName);\n    options = options || {};\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  ensureEnums() {}\n\n  async setIsolationLevel(transaction, value, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error(\"Unable to set isolation level for a transaction without transaction object!\");\n    }\n\n    if (transaction.parent || !value) {\n      return;\n    }\n\n    options = __spreadProps(__spreadValues({}, options), {\n      transaction: transaction.parent || transaction\n    });\n    const sql = this.queryGenerator.setIsolationLevelQuery(value, {\n      parent: transaction.parent\n    });\n    if (!sql) return;\n    return await this.sequelize.query(sql, options);\n  }\n\n  async startTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error(\"Unable to start a transaction without transaction object!\");\n    }\n\n    options = __spreadProps(__spreadValues({}, options), {\n      transaction: transaction.parent || transaction\n    });\n    options.transaction.name = transaction.parent ? transaction.name : void 0;\n    const sql = this.queryGenerator.startTransactionQuery(transaction);\n    return await this.sequelize.query(sql, options);\n  }\n\n  async deferConstraints(transaction, options) {\n    options = __spreadProps(__spreadValues({}, options), {\n      transaction: transaction.parent || transaction\n    });\n    const sql = this.queryGenerator.deferConstraintsQuery(options);\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  async commitTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error(\"Unable to commit a transaction without transaction object!\");\n    }\n\n    if (transaction.parent) {\n      return;\n    }\n\n    options = __spreadProps(__spreadValues({}, options), {\n      transaction: transaction.parent || transaction,\n      supportsSearchPath: false,\n      completesTransaction: true\n    });\n    const sql = this.queryGenerator.commitTransactionQuery(transaction);\n    const promise = this.sequelize.query(sql, options);\n    transaction.finished = \"commit\";\n    return await promise;\n  }\n\n  async rollbackTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error(\"Unable to rollback a transaction without transaction object!\");\n    }\n\n    options = __spreadProps(__spreadValues({}, options), {\n      transaction: transaction.parent || transaction,\n      supportsSearchPath: false,\n      completesTransaction: true\n    });\n    options.transaction.name = transaction.parent ? transaction.name : void 0;\n    const sql = this.queryGenerator.rollbackTransactionQuery(transaction);\n    const promise = this.sequelize.query(sql, options);\n    transaction.finished = \"rollback\";\n    return await promise;\n  }\n\n}\n\nexports.QueryInterface = QueryInterface;","map":{"version":3,"mappings":"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","names":["_","require","Utils","DataTypes","Transaction","QueryTypes","constructor","sequelize","queryGenerator","database","options","sql","createDatabaseQuery","query","dropDatabaseQuery","schema","createSchema","dropSchema","_dialect","supports","schemas","drop","showAllSchemas","Promise","all","map","schemaName","__spreadProps","raw","type","SELECT","showSchemasSql","showSchemasQuery","schemaNames","flatten","value","schema_name","versionQuery","VERSION","tableName","attributes","model","__spreadValues","uniqueKeys","forOwn","uniqueKey","customIndex","mapValues","attribute","normalizeAttribute","ensureEnums","_schema","addSchema","attributesToSQL","table","context","withoutForeignKeyConstraints","createTableQuery","tableExistsQuery","out","SHOWTABLES","length","cascade","force","dropTableQuery","tableNames","skip","includes","dropTable","showAllTables","foreignKeys","getForeignKeysForTables","normalizedTableName","isObject","foreignKey","dropForeignKeyQuery","_dropAllTables","before","after","renameTableQuery","showTablesSql","showTablesQuery","config","schemaDelimiter","describeTableQuery","DESCRIBE","data","isEmpty","Error","e","original","code","key","addColumnQuery","attributeName","removeColumnQuery","dataTypeOrOptions","Object","values","allowNull","quoteIdentifier","identifier2","quoteIdentifiers","identifiers","changeColumnQuery","columnName","description","describeTable","attrNameBefore","attrNameAfter","assertTableHasColumn","_options","defaultValue","renameColumnQuery","rawTablename","Array","isArray","fields","cloneDeep","addIndexQuery","supportsSearchPath","showIndexesQuery","SHOWINDEXES","FOREIGNKEYS","results","getForeignKeysQuery","result","forEach","i","r","constraint_name","filter","identity","queryOptions","indexNameOrAttributes","removeIndexQuery","addConstraintQuery","constraintName","showConstraintsQuery","SHOWCONSTRAINTS","removeConstraintQuery","instance","hasTrigger","insertQuery","rawAttributes","INSERT","isNewRecord","insertValues","updateValues","where","UPSERT","updateOnDuplicate","keys","upsertKeys","conflictFields","primaryKeys","item","field","c","indexKeys","_indexes","unique","find","indexKey","intersection","uniq","records","bulkInsertQuery","updateQuery","UPDATE","modelManager","models","BULKUPDATE","cascades","deleteQuery","associations","association","onDelete","toLowerCase","useHooks","push","accessors","get","instances","_instance","destroy","defaults","limit","truncate","truncateTableQuery","identifier","optionsArg","selectQuery","incrementAmountsByField","extraAttributesToBeUpdated","arithmeticQuery","attributeSelector","Model","plain","dataType","DECIMAL","FLOAT","parseFloat","INTEGER","BIGINT","parseInt","DATE","Date","triggerName","timingType","fireOnArray","functionName","functionParams","optionsArray","createTrigger","dropTrigger","oldTriggerName","newTriggerName","renameTrigger","params","returnType","language","body","createFunction","dropFunction","oldFunctionName","newFunctionName","renameFunction","transaction","parent","setIsolationLevelQuery","name","startTransactionQuery","deferConstraintsQuery","completesTransaction","commitTransactionQuery","promise","finished","rollbackTransactionQuery","exports","QueryInterface"],"sources":["/Users/aurele/node_modules/sequelize/src/dialects/abstract/query-interface.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\n\nconst Utils = require('../../utils');\nconst DataTypes = require('../../data-types');\nconst Transaction = require('../../transaction');\nconst QueryTypes = require('../../query-types');\n\n/**\n * The interface that Sequelize uses to talk to all databases\n */\nclass QueryInterface {\n  constructor(sequelize, queryGenerator) {\n    this.sequelize = sequelize;\n    this.queryGenerator = queryGenerator;\n  }\n\n  /**\n   * Create a database\n   *\n   * @param {string} database  Database name to create\n   * @param {object} [options] Query options\n   * @param {string} [options.charset] Database default character set, MYSQL only\n   * @param {string} [options.collate] Database default collation\n   * @param {string} [options.encoding] Database default character set, PostgreSQL only\n   * @param {string} [options.ctype] Database character classification, PostgreSQL only\n   * @param {string} [options.template] The name of the template from which to create the new database, PostgreSQL only\n   *\n   * @returns {Promise}\n   */\n  async createDatabase(database, options) {\n    options = options || {};\n    const sql = this.queryGenerator.createDatabaseQuery(database, options);\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Drop a database\n   *\n   * @param {string} database  Database name to drop\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async dropDatabase(database, options) {\n    options = options || {};\n    const sql = this.queryGenerator.dropDatabaseQuery(database);\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Create a schema\n   *\n   * @param {string} schema    Schema name to create\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async createSchema(schema, options) {\n    options = options || {};\n    const sql = this.queryGenerator.createSchema(schema);\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Drop a schema\n   *\n   * @param {string} schema    Schema name to drop\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async dropSchema(schema, options) {\n    options = options || {};\n    const sql = this.queryGenerator.dropSchema(schema);\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Drop all schemas\n   *\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async dropAllSchemas(options) {\n    options = options || {};\n\n    if (!this.queryGenerator._dialect.supports.schemas) {\n      return this.sequelize.drop(options);\n    }\n    const schemas = await this.showAllSchemas(options);\n    return Promise.all(schemas.map(schemaName => this.dropSchema(schemaName, options)));\n  }\n\n  /**\n   * Show all schemas\n   *\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise<Array>}\n   */\n  async showAllSchemas(options) {\n    options = {\n      ...options,\n      raw: true,\n      type: this.sequelize.QueryTypes.SELECT\n    };\n\n    const showSchemasSql = this.queryGenerator.showSchemasQuery(options);\n\n    const schemaNames = await this.sequelize.query(showSchemasSql, options);\n\n    return _.flatten(schemaNames.map(value => value.schema_name ? value.schema_name : value));\n  }\n\n  /**\n   * Return database version\n   *\n   * @param {object}    [options]      Query options\n   * @param {QueryType} [options.type] Query type\n   *\n   * @returns {Promise}\n   * @private\n   */\n  async databaseVersion(options) {\n    return await this.sequelize.query(\n      this.queryGenerator.versionQuery(),\n      { ...options, type: QueryTypes.VERSION }\n    );\n  }\n\n  /**\n   * Create a table with given set of attributes\n   *\n   * ```js\n   * queryInterface.createTable(\n   *   'nameOfTheNewTable',\n   *   {\n   *     id: {\n   *       type: Sequelize.INTEGER,\n   *       primaryKey: true,\n   *       autoIncrement: true\n   *     },\n   *     createdAt: {\n   *       type: Sequelize.DATE\n   *     },\n   *     updatedAt: {\n   *       type: Sequelize.DATE\n   *     },\n   *     attr1: Sequelize.STRING,\n   *     attr2: Sequelize.INTEGER,\n   *     attr3: {\n   *       type: Sequelize.BOOLEAN,\n   *       defaultValue: false,\n   *       allowNull: false\n   *     },\n   *     //foreign key usage\n   *     attr4: {\n   *       type: Sequelize.INTEGER,\n   *       references: {\n   *         model: 'another_table_name',\n   *         key: 'id'\n   *       },\n   *       onUpdate: 'cascade',\n   *       onDelete: 'cascade'\n   *     }\n   *   },\n   *   {\n   *     engine: 'MYISAM',    // default: 'InnoDB'\n   *     charset: 'latin1',   // default: null\n   *     schema: 'public',    // default: public, PostgreSQL only.\n   *     comment: 'my table', // comment for table\n   *     collate: 'latin1_danish_ci' // collation, MYSQL only\n   *   }\n   * )\n   * ```\n   *\n   * @param {string} tableName  Name of table to create\n   * @param {object} attributes Object representing a list of table attributes to create\n   * @param {object} [options] create table and query options\n   * @param {Model}  [model] model class\n   *\n   * @returns {Promise}\n   */\n  async createTable(tableName, attributes, options, model) {\n    let sql = '';\n\n    options = { ...options };\n\n    if (options && options.uniqueKeys) {\n      _.forOwn(options.uniqueKeys, uniqueKey => {\n        if (uniqueKey.customIndex === undefined) {\n          uniqueKey.customIndex = true;\n        }\n      });\n    }\n\n    if (model) {\n      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n    }\n\n    attributes = _.mapValues(\n      attributes,\n      attribute => this.sequelize.normalizeAttribute(attribute)\n    );\n\n    // Postgres requires special SQL commands for ENUM/ENUM[]\n    await this.ensureEnums(tableName, attributes, options, model);\n\n    if (\n      !tableName.schema &&\n      (options.schema || !!model && model._schema)\n    ) {\n      tableName = this.queryGenerator.addSchema({\n        tableName,\n        _schema: !!model && model._schema || options.schema\n      });\n    }\n\n    attributes = this.queryGenerator.attributesToSQL(attributes, {\n      table: tableName,\n      context: 'createTable',\n      withoutForeignKeyConstraints: options.withoutForeignKeyConstraints\n    });\n    sql = this.queryGenerator.createTableQuery(tableName, attributes, options);\n\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Returns a promise that will resolve to true if the table exists in the database, false otherwise.\n   *\n   * @param {TableName} tableName - The name of the table\n   * @param {QueryOptions} options - Query options\n   * @returns {Promise<boolean>}\n   */\n  async tableExists(tableName, options) {\n    const sql = this.queryGenerator.tableExistsQuery(tableName);\n\n    const out = await this.sequelize.query(sql, {\n      ...options,\n      type: QueryTypes.SHOWTABLES\n    });\n\n    return out.length === 1;\n  }\n\n  /**\n   * Drop a table from database\n   *\n   * @param {string} tableName Table name to drop\n   * @param {object} options   Query options\n   *\n   * @returns {Promise}\n   */\n  async dropTable(tableName, options) {\n    // if we're forcing we should be cascading unless explicitly stated otherwise\n    options = { ...options };\n    options.cascade = options.cascade || options.force || false;\n\n    const sql = this.queryGenerator.dropTableQuery(tableName, options);\n\n    await this.sequelize.query(sql, options);\n  }\n\n  async _dropAllTables(tableNames, skip, options) {\n    for (const tableName of tableNames) {\n      // if tableName is not in the Array of tables names then don't drop it\n      if (!skip.includes(tableName.tableName || tableName)) {\n        await this.dropTable(tableName, { ...options, cascade: true } );\n      }\n    }\n  }\n\n  /**\n   * Drop all tables from database\n   *\n   * @param {object} [options] query options\n   * @param {Array}  [options.skip] List of table to skip\n   *\n   * @returns {Promise}\n   */\n  async dropAllTables(options) {\n    options = options || {};\n    const skip = options.skip || [];\n\n    const tableNames = await this.showAllTables(options);\n    const foreignKeys = await this.getForeignKeysForTables(tableNames, options);\n\n    for (const tableName of tableNames) {\n      let normalizedTableName = tableName;\n      if (_.isObject(tableName)) {\n        normalizedTableName = `${tableName.schema}.${tableName.tableName}`;\n      }\n\n      for (const foreignKey of foreignKeys[normalizedTableName]) {\n        await this.sequelize.query(this.queryGenerator.dropForeignKeyQuery(tableName, foreignKey));\n      }\n    }\n    await this._dropAllTables(tableNames, skip, options);\n  }\n\n  /**\n   * Rename a table\n   *\n   * @param {string} before    Current name of table\n   * @param {string} after     New name from table\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async renameTable(before, after, options) {\n    options = options || {};\n    const sql = this.queryGenerator.renameTableQuery(before, after);\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Get all tables in current database\n   *\n   * @param {object}    [options] Query options\n   * @param {boolean}   [options.raw=true] Run query in raw mode\n   * @param {QueryType} [options.type=QueryType.SHOWTABLE] query type\n   *\n   * @returns {Promise<Array>}\n   * @private\n   */\n  async showAllTables(options) {\n    options = {\n      ...options,\n      raw: true,\n      type: QueryTypes.SHOWTABLES\n    };\n\n    const showTablesSql = this.queryGenerator.showTablesQuery(this.sequelize.config.database);\n    const tableNames = await this.sequelize.query(showTablesSql, options);\n    return _.flatten(tableNames);\n  }\n\n  /**\n   * Describe a table structure\n   *\n   * This method returns an array of hashes containing information about all attributes in the table.\n   *\n   * ```js\n   * {\n   *    name: {\n   *      type:         'VARCHAR(255)', // this will be 'CHARACTER VARYING' for pg!\n   *      allowNull:    true,\n   *      defaultValue: null\n   *    },\n   *    isBetaMember: {\n   *      type:         'TINYINT(1)', // this will be 'BOOLEAN' for pg!\n   *      allowNull:    false,\n   *      defaultValue: false\n   *    }\n   * }\n   * ```\n   *\n   * @param {string} tableName table name\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise<object>}\n   */\n  async describeTable(tableName, options) {\n    let schema = null;\n    let schemaDelimiter = null;\n\n    if (typeof options === 'string') {\n      schema = options;\n    } else if (typeof options === 'object' && options !== null) {\n      schema = options.schema || null;\n      schemaDelimiter = options.schemaDelimiter || null;\n    }\n\n    if (typeof tableName === 'object' && tableName !== null) {\n      schema = tableName.schema;\n      tableName = tableName.tableName;\n    }\n\n    const sql = this.queryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);\n    options = { ...options, type: QueryTypes.DESCRIBE };\n\n    try {\n      const data = await this.sequelize.query(sql, options);\n      /*\n       * If no data is returned from the query, then the table name may be wrong.\n       * Query generators that use information_schema for retrieving table info will just return an empty result set,\n       * it will not throw an error like built-ins do (e.g. DESCRIBE on MySql).\n       */\n      if (_.isEmpty(data)) {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n\n      return data;\n    } catch (e) {\n      if (e.original && e.original.code === 'ER_NO_SUCH_TABLE') {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n\n      throw e;\n    }\n  }\n\n  /**\n   * Add a new column to a table\n   *\n   * ```js\n   * queryInterface.addColumn('tableA', 'columnC', Sequelize.STRING, {\n   *    after: 'columnB' // after option is only supported by MySQL\n   * });\n   * ```\n   *\n   * @param {string} table     Table to add column to\n   * @param {string} key       Column name\n   * @param {object} attribute Attribute definition\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async addColumn(table, key, attribute, options) {\n    if (!table || !key || !attribute) {\n      throw new Error('addColumn takes at least 3 arguments (table, attribute name, attribute definition)');\n    }\n\n    options = options || {};\n    attribute = this.sequelize.normalizeAttribute(attribute);\n    return await this.sequelize.query(this.queryGenerator.addColumnQuery(table, key, attribute), options);\n  }\n\n  /**\n   * Remove a column from a table\n   *\n   * @param {string} tableName      Table to remove column from\n   * @param {string} attributeName  Column name to remove\n   * @param {object} [options]      Query options\n   */\n  async removeColumn(tableName, attributeName, options) {\n    return this.sequelize.query(this.queryGenerator.removeColumnQuery(tableName, attributeName), options);\n  }\n\n  normalizeAttribute(dataTypeOrOptions) {\n    let attribute;\n    if (Object.values(DataTypes).includes(dataTypeOrOptions)) {\n      attribute = { type: dataTypeOrOptions, allowNull: true };\n    } else {\n      attribute = dataTypeOrOptions;\n    }\n\n    return this.sequelize.normalizeAttribute(attribute);\n  }\n\n  /**\n   * Split a list of identifiers by \".\" and quote each part\n   *\n   * @param {string} identifier\n   * @param {boolean} force\n   *\n   * @returns {string}\n   */\n  quoteIdentifier(identifier, force) {\n    return this.queryGenerator.quoteIdentifier(identifier, force);\n  }\n\n  /**\n   * Split a list of identifiers by \".\" and quote each part.\n   *\n   * @param {string} identifiers \n   * \n   * @returns {string}\n   */\n  quoteIdentifiers(identifiers) {\n    return this.queryGenerator.quoteIdentifiers(identifiers);\n  }\n\n  /**\n   * Change a column definition\n   *\n   * @param {string} tableName          Table name to change from\n   * @param {string} attributeName      Column name\n   * @param {object} dataTypeOrOptions  Attribute definition for new column\n   * @param {object} [options]          Query options\n   */\n  async changeColumn(tableName, attributeName, dataTypeOrOptions, options) {\n    options = options || {};\n\n    const query = this.queryGenerator.attributesToSQL({\n      [attributeName]: this.normalizeAttribute(dataTypeOrOptions)\n    }, {\n      context: 'changeColumn',\n      table: tableName\n    });\n    const sql = this.queryGenerator.changeColumnQuery(tableName, query);\n\n    return this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Rejects if the table doesn't have the specified column, otherwise returns the column description.\n   *\n   * @param {string} tableName\n   * @param {string} columnName\n   * @param {object} options\n   * @private\n   */\n  async assertTableHasColumn(tableName, columnName, options) {\n    const description = await this.describeTable(tableName, options);\n    if (description[columnName]) {\n      return description;\n    }\n    throw new Error(`Table ${tableName} doesn't have the column ${columnName}`);\n  }\n\n  /**\n   * Rename a column\n   *\n   * @param {string} tableName        Table name whose column to rename\n   * @param {string} attrNameBefore   Current column name\n   * @param {string} attrNameAfter    New column name\n   * @param {object} [options]        Query option\n   *\n   * @returns {Promise}\n   */\n  async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {\n    options = options || {};\n    const data = (await this.assertTableHasColumn(tableName, attrNameBefore, options))[attrNameBefore];\n\n    const _options = {};\n\n    _options[attrNameAfter] = {\n      attribute: attrNameAfter,\n      type: data.type,\n      allowNull: data.allowNull,\n      defaultValue: data.defaultValue\n    };\n\n    // fix: a not-null column cannot have null as default value\n    if (data.defaultValue === null && !data.allowNull) {\n      delete _options[attrNameAfter].defaultValue;\n    }\n\n    const sql = this.queryGenerator.renameColumnQuery(\n      tableName,\n      attrNameBefore,\n      this.queryGenerator.attributesToSQL(_options)\n    );\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Add an index to a column\n   *\n   * @param {string|object}  tableName Table name to add index on, can be a object with schema\n   * @param {Array}   [attributes]     Use options.fields instead, List of attributes to add index on\n   * @param {object}  options          indexes options\n   * @param {Array}   options.fields   List of attributes to add index on\n   * @param {boolean} [options.concurrently] Pass CONCURRENT so other operations run while the index is created\n   * @param {boolean} [options.unique] Create a unique index\n   * @param {string}  [options.using]  Useful for GIN indexes\n   * @param {string}  [options.operator] Index operator\n   * @param {string}  [options.type]   Type of index, available options are UNIQUE|FULLTEXT|SPATIAL\n   * @param {string}  [options.name]   Name of the index. Default is <table>_<attr1>_<attr2>\n   * @param {object}  [options.where]  Where condition on index, for partial indexes\n   * @param {string}  [rawTablename]   table name, this is just for backward compatibiity\n   *\n   * @returns {Promise}\n   */\n  async addIndex(tableName, attributes, options, rawTablename) {\n    // Support for passing tableName, attributes, options or tableName, options (with a fields param which is the attributes)\n    if (!Array.isArray(attributes)) {\n      rawTablename = options;\n      options = attributes;\n      attributes = options.fields;\n    }\n\n    if (!rawTablename) {\n      // Map for backwards compat\n      rawTablename = tableName;\n    }\n\n    options = Utils.cloneDeep(options);\n    options.fields = attributes;\n    const sql = this.queryGenerator.addIndexQuery(tableName, options, rawTablename);\n    return await this.sequelize.query(sql, { ...options, supportsSearchPath: false });\n  }\n\n  /**\n   * Show indexes on a table\n   *\n   * @param {string} tableName table name\n   * @param {object} [options]   Query options\n   *\n   * @returns {Promise<Array>}\n   * @private\n   */\n  async showIndex(tableName, options) {\n    const sql = this.queryGenerator.showIndexesQuery(tableName, options);\n    return await this.sequelize.query(sql, { ...options, type: QueryTypes.SHOWINDEXES });\n  }\n\n\n  /**\n   * Returns all foreign key constraints of requested tables\n   *\n   * @param {string[]} tableNames table names\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async getForeignKeysForTables(tableNames, options) {\n    if (tableNames.length === 0) {\n      return {};\n    }\n\n    options = { ...options, type: QueryTypes.FOREIGNKEYS };\n\n    const results = await Promise.all(tableNames.map(tableName =>\n      this.sequelize.query(this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database), options)));\n\n    const result = {};\n\n    tableNames.forEach((tableName, i) => {\n      if (_.isObject(tableName)) {\n        tableName = `${tableName.schema}.${tableName.tableName}`;\n      }\n\n      result[tableName] = Array.isArray(results[i])\n        ? results[i].map(r => r.constraint_name)\n        : [results[i] && results[i].constraint_name];\n\n      result[tableName] = result[tableName].filter(_.identity);\n    });\n\n    return result;\n  }\n\n  /**\n   * Get foreign key references details for the table\n   *\n   * Those details contains constraintSchema, constraintName, constraintCatalog\n   * tableCatalog, tableSchema, tableName, columnName,\n   * referencedTableCatalog, referencedTableCatalog, referencedTableSchema, referencedTableName, referencedColumnName.\n   * Remind: constraint informations won't return if it's sqlite.\n   *\n   * @param {string} tableName table name\n   * @param {object} [options]  Query options\n   */\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const queryOptions = {\n      ...options,\n      type: QueryTypes.FOREIGNKEYS\n    };\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database);\n    return this.sequelize.query(query, queryOptions);\n  }\n\n  /**\n   * Remove an already existing index from a table\n   *\n   * @param {string} tableName                    Table name to drop index from\n   * @param {string|string[]} indexNameOrAttributes  Index name or list of attributes that in the index\n   * @param {object} [options]                    Query options\n   * @param {boolean} [options.concurrently]      Pass CONCURRENTLY so other operations run while the index is created\n   *\n   * @returns {Promise}\n   */\n  async removeIndex(tableName, indexNameOrAttributes, options) {\n    options = options || {};\n    const sql = this.queryGenerator.removeIndexQuery(tableName, indexNameOrAttributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Add a constraint to a table\n   *\n   * Available constraints:\n   * - UNIQUE\n   * - DEFAULT (MSSQL only)\n   * - CHECK (MySQL - Ignored by the database engine )\n   * - FOREIGN KEY\n   * - PRIMARY KEY\n   *\n   * @example <caption>UNIQUE</caption>\n   * queryInterface.addConstraint('Users', {\n   *   fields: ['email'],\n   *   type: 'unique',\n   *   name: 'custom_unique_constraint_name'\n   * });\n   *\n   * @example <caption>CHECK</caption>\n   * queryInterface.addConstraint('Users', {\n   *   fields: ['roles'],\n   *   type: 'check',\n   *   where: {\n   *      roles: ['user', 'admin', 'moderator', 'guest']\n   *   }\n   * });\n   *\n   * @example <caption>Default - MSSQL only</caption>\n   * queryInterface.addConstraint('Users', {\n   *    fields: ['roles'],\n   *    type: 'default',\n   *    defaultValue: 'guest'\n   * });\n   *\n   * @example <caption>Primary Key</caption>\n   * queryInterface.addConstraint('Users', {\n   *    fields: ['username'],\n   *    type: 'primary key',\n   *    name: 'custom_primary_constraint_name'\n   * });\n   *\n   * @example <caption>Foreign Key</caption>\n   * queryInterface.addConstraint('Posts', {\n   *   fields: ['username'],\n   *   type: 'foreign key',\n   *   name: 'custom_fkey_constraint_name',\n   *   references: { //Required field\n   *     table: 'target_table_name',\n   *     field: 'target_column_name'\n   *   },\n   *   onDelete: 'cascade',\n   *   onUpdate: 'cascade'\n   * });\n   *\n   * @example <caption>Composite Foreign Key</caption>\n   * queryInterface.addConstraint('TableName', {\n   *   fields: ['source_column_name', 'other_source_column_name'],\n   *   type: 'foreign key',\n   *   name: 'custom_fkey_constraint_name',\n   *   references: { //Required field\n   *     table: 'target_table_name',\n   *     fields: ['target_column_name', 'other_target_column_name']\n   *   },\n   *   onDelete: 'cascade',\n   *   onUpdate: 'cascade'\n   * });\n   *\n   * @param {string} tableName                   Table name where you want to add a constraint\n   * @param {object} options                     An object to define the constraint name, type etc\n   * @param {string} options.type                Type of constraint. One of the values in available constraints(case insensitive)\n   * @param {Array}  options.fields              Array of column names to apply the constraint over\n   * @param {string} [options.name]              Name of the constraint. If not specified, sequelize automatically creates a named constraint based on constraint type, table & column names\n   * @param {string} [options.defaultValue]      The value for the default constraint\n   * @param {object} [options.where]             Where clause/expression for the CHECK constraint\n   * @param {object} [options.references]        Object specifying target table, column name to create foreign key constraint\n   * @param {string} [options.references.table]  Target table name\n   * @param {string} [options.references.field]  Target column name\n   * @param {string} [options.references.fields] Target column names for a composite primary key. Must match the order of fields in options.fields.\n   * @param {string} [options.deferrable]        Sets the constraint to be deferred or immediately checked. See Sequelize.Deferrable. PostgreSQL Only\n   *\n   * @returns {Promise}\n   */\n  async addConstraint(tableName, options) {\n    if (!options.fields) {\n      throw new Error('Fields must be specified through options.fields');\n    }\n\n    if (!options.type) {\n      throw new Error('Constraint type must be specified through options.type');\n    }\n\n    options = Utils.cloneDeep(options);\n\n    const sql = this.queryGenerator.addConstraintQuery(tableName, options);\n    return await this.sequelize.query(sql, options);\n  }\n\n  async showConstraint(tableName, constraintName, options) {\n    const sql = this.queryGenerator.showConstraintsQuery(tableName, constraintName);\n    return await this.sequelize.query(sql, { ...options, type: QueryTypes.SHOWCONSTRAINTS });\n  }\n\n  /**\n   * Remove a constraint from a table\n   *\n   * @param {string} tableName       Table name to drop constraint from\n   * @param {string} constraintName  Constraint name\n   * @param {object} options         Query options\n   */\n  async removeConstraint(tableName, constraintName, options) {\n    return this.sequelize.query(this.queryGenerator.removeConstraintQuery(tableName, constraintName), options);\n  }\n\n  async insert(instance, tableName, values, options) {\n    options = Utils.cloneDeep(options);\n    options.hasTrigger = instance && instance.constructor.options.hasTrigger;\n    const sql = this.queryGenerator.insertQuery(tableName, values, instance && instance.constructor.rawAttributes, options);\n\n    options.type = QueryTypes.INSERT;\n    options.instance = instance;\n\n    const results = await this.sequelize.query(sql, options);\n    if (instance) results[0].isNewRecord = false;\n\n    return results;\n  }\n\n  /**\n   * Upsert\n   *\n   * @param {string} tableName    table to upsert on\n   * @param {object} insertValues values to be inserted, mapped to field name\n   * @param {object} updateValues values to be updated, mapped to field name\n   * @param {object} where        where conditions, which can be used for UPDATE part when INSERT fails\n   * @param {object} options      query options\n   *\n   * @returns {Promise<boolean,?number>} Resolves an array with <created, primaryKey>\n   */\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = { ...options };\n\n    const model = options.model;\n\n    options.type = QueryTypes.UPSERT;\n    options.updateOnDuplicate = Object.keys(updateValues);\n    options.upsertKeys = options.conflictFields || [];\n\n    if (options.upsertKeys.length === 0) {\n      const primaryKeys = Object.values(model.primaryKeys).map(item => item.field);\n      const uniqueKeys = Object.values(model.uniqueKeys).filter(c => c.fields.length > 0).map(c => c.fields);\n      const indexKeys = Object.values(model._indexes).filter(c => c.unique && c.fields.length > 0).map(c => c.fields);\n      // For fields in updateValues, try to find a constraint or unique index\n      // that includes given field. Only first matching upsert key is used.\n      for (const field of options.updateOnDuplicate) {\n        const uniqueKey = uniqueKeys.find(fields => fields.includes(field));\n        if (uniqueKey) {\n          options.upsertKeys = uniqueKey;\n          break;\n        }\n\n        const indexKey = indexKeys.find(fields => fields.includes(field));\n        if (indexKey) {\n          options.upsertKeys = indexKey;\n          break;\n        }\n      }\n\n      // Always use PK, if no constraint available OR update data contains PK\n      if (\n        options.upsertKeys.length === 0\n        || _.intersection(options.updateOnDuplicate, primaryKeys).length\n      ) {\n        options.upsertKeys = primaryKeys;\n      }\n\n      options.upsertKeys = _.uniq(options.upsertKeys);\n    }\n\n    const sql = this.queryGenerator.insertQuery(tableName, insertValues, model.rawAttributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Insert multiple records into a table\n   *\n   * @example\n   * queryInterface.bulkInsert('roles', [{\n   *    label: 'user',\n   *    createdAt: new Date(),\n   *    updatedAt: new Date()\n   *  }, {\n   *    label: 'admin',\n   *    createdAt: new Date(),\n   *    updatedAt: new Date()\n   *  }]);\n   *\n   * @param {string} tableName   Table name to insert record to\n   * @param {Array}  records     List of records to insert\n   * @param {object} options     Various options, please see Model.bulkCreate options\n   * @param {object} attributes  Various attributes mapped by field name\n   *\n   * @returns {Promise}\n   */\n  async bulkInsert(tableName, records, options, attributes) {\n    options = { ...options };\n    options.type = QueryTypes.INSERT;\n\n    const results = await this.sequelize.query(\n      this.queryGenerator.bulkInsertQuery(tableName, records, options, attributes),\n      options\n    );\n\n    return results[0];\n  }\n\n  async update(instance, tableName, values, identifier, options) {\n    options = { ...options };\n    options.hasTrigger = instance && instance.constructor.options.hasTrigger;\n\n    const sql = this.queryGenerator.updateQuery(tableName, values, identifier, options, instance.constructor.rawAttributes);\n\n    options.type = QueryTypes.UPDATE;\n\n    options.instance = instance;\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Update multiple records of a table\n   *\n   * @example\n   * queryInterface.bulkUpdate('roles', {\n   *     label: 'admin',\n   *   }, {\n   *     userType: 3,\n   *   },\n   * );\n   *\n   * @param {string} tableName     Table name to update\n   * @param {object} values        Values to be inserted, mapped to field name\n   * @param {object} identifier    A hash with conditions OR an ID as integer OR a string with conditions\n   * @param {object} [options]     Various options, please see Model.bulkCreate options\n   * @param {object} [attributes]  Attributes on return objects if supported by SQL dialect\n   *\n   * @returns {Promise}\n   */\n  async bulkUpdate(tableName, values, identifier, options, attributes) {\n    options = Utils.cloneDeep(options);\n    if (typeof identifier === 'object') identifier = Utils.cloneDeep(identifier);\n\n    const sql = this.queryGenerator.updateQuery(tableName, values, identifier, options, attributes);\n    const table = _.isObject(tableName) ? tableName : { tableName };\n    const model = options.model ? options.model : _.find(this.sequelize.modelManager.models, { tableName: table.tableName });\n\n    options.type = QueryTypes.BULKUPDATE;\n    options.model = model;\n    return await this.sequelize.query(sql, options);\n  }\n\n  async delete(instance, tableName, identifier, options) {\n    const cascades = [];\n    const sql = this.queryGenerator.deleteQuery(tableName, identifier, {}, instance.constructor);\n\n    options = { ...options };\n\n    // Check for a restrict field\n    if (!!instance.constructor && !!instance.constructor.associations) {\n      const keys = Object.keys(instance.constructor.associations);\n      const length = keys.length;\n      let association;\n\n      for (let i = 0; i < length; i++) {\n        association = instance.constructor.associations[keys[i]];\n        if (association.options && association.options.onDelete &&\n          association.options.onDelete.toLowerCase() === 'cascade' &&\n          association.options.useHooks === true) {\n          cascades.push(association.accessors.get);\n        }\n      }\n    }\n\n    for (const cascade of cascades) {\n      let instances = await instance[cascade](options);\n      // Check for hasOne relationship with non-existing associate (\"has zero\")\n      if (!instances) continue;\n      if (!Array.isArray(instances)) instances = [instances];\n      for (const _instance of instances) await _instance.destroy(options);\n    }\n    options.instance = instance;\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Delete multiple records from a table\n   *\n   * @param {string}  tableName            table name from where to delete records\n   * @param {object}  where                where conditions to find records to delete\n   * @param {object}  [options]            options\n   * @param {boolean} [options.truncate]   Use truncate table command\n   * @param {boolean} [options.cascade=false]         Only used in conjunction with TRUNCATE. Truncates  all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.\n   * @param {boolean} [options.restartIdentity=false] Only used in conjunction with TRUNCATE. Automatically restart sequences owned by columns of the truncated table.\n   * @param {Model}   [model]              Model\n   *\n   * @returns {Promise}\n   */\n  async bulkDelete(tableName, where, options, model) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, { limit: null });\n\n    if (options.truncate === true) {\n      return this.sequelize.query(\n        this.queryGenerator.truncateTableQuery(tableName, options),\n        options\n      );\n    }\n\n    if (typeof identifier === 'object') where = Utils.cloneDeep(where);\n\n    return await this.sequelize.query(\n      this.queryGenerator.deleteQuery(tableName, where, options, model),\n      options\n    );\n  }\n\n  async select(model, tableName, optionsArg) {\n    const options = { ...optionsArg, type: QueryTypes.SELECT, model };\n\n    return await this.sequelize.query(\n      this.queryGenerator.selectQuery(tableName, options, model),\n      options\n    );\n  }\n\n  async increment(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    options = Utils.cloneDeep(options);\n\n    const sql = this.queryGenerator.arithmeticQuery('+', tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);\n\n    options.type = QueryTypes.UPDATE;\n    options.model = model;\n\n    return await this.sequelize.query(sql, options);\n  }\n\n  async decrement(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    options = Utils.cloneDeep(options);\n\n    const sql = this.queryGenerator.arithmeticQuery('-', tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);\n\n    options.type = QueryTypes.UPDATE;\n    options.model = model;\n\n    return await this.sequelize.query(sql, options);\n  }\n\n  async rawSelect(tableName, options, attributeSelector, Model) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, {\n      raw: true,\n      plain: true,\n      type: QueryTypes.SELECT\n    });\n\n    const sql = this.queryGenerator.selectQuery(tableName, options, Model);\n\n    if (attributeSelector === undefined) {\n      throw new Error('Please pass an attribute selector!');\n    }\n\n    const data = await this.sequelize.query(sql, options);\n    if (!options.plain) {\n      return data;\n    }\n\n    const result = data ? data[attributeSelector] : null;\n\n    if (!options || !options.dataType) {\n      return result;\n    }\n\n    const dataType = options.dataType;\n\n    if (dataType instanceof DataTypes.DECIMAL || dataType instanceof DataTypes.FLOAT) {\n      if (result !== null) {\n        return parseFloat(result);\n      }\n    }\n    if (dataType instanceof DataTypes.INTEGER || dataType instanceof DataTypes.BIGINT) {\n      if (result !== null) {\n        return parseInt(result, 10);\n      }\n    }\n    if (dataType instanceof DataTypes.DATE) {\n      if (result !== null && !(result instanceof Date)) {\n        return new Date(result);\n      }\n    }\n    return result;\n  }\n\n  async createTrigger(\n    tableName,\n    triggerName,\n    timingType,\n    fireOnArray,\n    functionName,\n    functionParams,\n    optionsArray,\n    options\n  ) {\n    const sql = this.queryGenerator.createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  async dropTrigger(tableName, triggerName, options) {\n    const sql = this.queryGenerator.dropTrigger(tableName, triggerName);\n    options = options || {};\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  async renameTrigger(tableName, oldTriggerName, newTriggerName, options) {\n    const sql = this.queryGenerator.renameTrigger(tableName, oldTriggerName, newTriggerName);\n    options = options || {};\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  /**\n   * Create an SQL function\n   *\n   * @example\n   * queryInterface.createFunction(\n   *   'someFunction',\n   *   [\n   *     {type: 'integer', name: 'param', direction: 'IN'}\n   *   ],\n   *   'integer',\n   *   'plpgsql',\n   *   'RETURN param + 1;',\n   *   [\n   *     'IMMUTABLE',\n   *     'LEAKPROOF'\n   *   ],\n   *   {\n   *    variables:\n   *      [\n   *        {type: 'integer', name: 'myVar', default: 100}\n   *      ],\n   *      force: true\n   *   };\n   * );\n   *\n   * @param {string}  functionName  Name of SQL function to create\n   * @param {Array}   params        List of parameters declared for SQL function\n   * @param {string}  returnType    SQL type of function returned value\n   * @param {string}  language      The name of the language that the function is implemented in\n   * @param {string}  body          Source code of function\n   * @param {Array}   optionsArray  Extra-options for creation\n   * @param {object}  [options]     query options\n   * @param {boolean} options.force If force is true, any existing functions with the same parameters will be replaced. For postgres, this means using `CREATE OR REPLACE FUNCTION` instead of `CREATE FUNCTION`. Default is false\n   * @param {Array<object>}   options.variables List of declared variables. Each variable should be an object with string fields `type` and `name`, and optionally having a `default` field as well.\n   *\n   * @returns {Promise}\n   */\n  async createFunction(functionName, params, returnType, language, body, optionsArray, options) {\n    const sql = this.queryGenerator.createFunction(functionName, params, returnType, language, body, optionsArray, options);\n    options = options || {};\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  /**\n   * Drop an SQL function\n   *\n   * @example\n   * queryInterface.dropFunction(\n   *   'someFunction',\n   *   [\n   *     {type: 'varchar', name: 'param1', direction: 'IN'},\n   *     {type: 'integer', name: 'param2', direction: 'INOUT'}\n   *   ]\n   * );\n   *\n   * @param {string} functionName Name of SQL function to drop\n   * @param {Array}  params       List of parameters declared for SQL function\n   * @param {object} [options]    query options\n   *\n   * @returns {Promise}\n   */\n  async dropFunction(functionName, params, options) {\n    const sql = this.queryGenerator.dropFunction(functionName, params);\n    options = options || {};\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  /**\n   * Rename an SQL function\n   *\n   * @example\n   * queryInterface.renameFunction(\n   *   'fooFunction',\n   *   [\n   *     {type: 'varchar', name: 'param1', direction: 'IN'},\n   *     {type: 'integer', name: 'param2', direction: 'INOUT'}\n   *   ],\n   *   'barFunction'\n   * );\n   *\n   * @param {string} oldFunctionName  Current name of function\n   * @param {Array}  params           List of parameters declared for SQL function\n   * @param {string} newFunctionName  New name of function\n   * @param {object} [options]        query options\n   *\n   * @returns {Promise}\n   */\n  async renameFunction(oldFunctionName, params, newFunctionName, options) {\n    const sql = this.queryGenerator.renameFunction(oldFunctionName, params, newFunctionName);\n    options = options || {};\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  // Helper methods useful for querying\n\n  /**\n   * @private\n   */\n  ensureEnums() {\n    // noop by default\n  }\n\n  async setIsolationLevel(transaction, value, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to set isolation level for a transaction without transaction object!');\n    }\n\n    if (transaction.parent || !value) {\n      // Not possible to set a separate isolation level for savepoints\n      return;\n    }\n\n    options = { ...options, transaction: transaction.parent || transaction };\n\n    const sql = this.queryGenerator.setIsolationLevelQuery(value, {\n      parent: transaction.parent\n    });\n\n    if (!sql) return;\n\n    return await this.sequelize.query(sql, options);\n  }\n\n  async startTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to start a transaction without transaction object!');\n    }\n\n    options = { ...options, transaction: transaction.parent || transaction };\n    options.transaction.name = transaction.parent ? transaction.name : undefined;\n    const sql = this.queryGenerator.startTransactionQuery(transaction);\n\n    return await this.sequelize.query(sql, options);\n  }\n\n  async deferConstraints(transaction, options) {\n    options = { ...options, transaction: transaction.parent || transaction };\n\n    const sql = this.queryGenerator.deferConstraintsQuery(options);\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  async commitTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to commit a transaction without transaction object!');\n    }\n    if (transaction.parent) {\n      // Savepoints cannot be committed\n      return;\n    }\n\n    options = {\n      ...options,\n      transaction: transaction.parent || transaction,\n      supportsSearchPath: false,\n      completesTransaction: true\n    };\n\n    const sql = this.queryGenerator.commitTransactionQuery(transaction);\n    const promise = this.sequelize.query(sql, options);\n\n    transaction.finished = 'commit';\n\n    return await promise;\n  }\n\n  async rollbackTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to rollback a transaction without transaction object!');\n    }\n\n    options = {\n      ...options,\n      transaction: transaction.parent || transaction,\n      supportsSearchPath: false,\n      completesTransaction: true\n    };\n    options.transaction.name = transaction.parent ? transaction.name : undefined;\n    const sql = this.queryGenerator.rollbackTransactionQuery(transaction);\n    const promise = this.sequelize.query(sql, options);\n\n    transaction.finished = 'rollback';\n\n    return await promise;\n  }\n}\n\nexports.QueryInterface = QueryInterface;\n"]},"metadata":{},"sourceType":"script"}