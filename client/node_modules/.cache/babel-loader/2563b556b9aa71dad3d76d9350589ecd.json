{"ast":null,"code":"\"use strict\";\n\nconst AbstractConnectionManager = require(\"../abstract/connection-manager\");\n\nconst AsyncQueue = require(\"./async-queue\").default;\n\nconst {\n  logger\n} = require(\"../../utils/logger\");\n\nconst sequelizeErrors = require(\"../../errors\");\n\nconst DataTypes = require(\"../../data-types\").mssql;\n\nconst parserStore = require(\"../parserStore\")(\"mssql\");\n\nconst debug = logger.debugContext(\"connection:mssql\");\nconst debugTedious = logger.debugContext(\"connection:mssql:tedious\");\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 1433;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"tedious\");\n    this.refreshTypeParser(DataTypes);\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  async connect(config) {\n    const connectionConfig = {\n      server: config.host,\n      authentication: {\n        type: \"default\",\n        options: {\n          userName: config.username || void 0,\n          password: config.password || void 0\n        }\n      },\n      options: {\n        port: parseInt(config.port, 10),\n        database: config.database,\n        trustServerCertificate: true\n      }\n    };\n\n    if (config.dialectOptions) {\n      if (config.dialectOptions.options && config.dialectOptions.options.instanceName) {\n        delete connectionConfig.options.port;\n      }\n\n      if (config.dialectOptions.authentication) {\n        Object.assign(connectionConfig.authentication, config.dialectOptions.authentication);\n      }\n\n      Object.assign(connectionConfig.options, config.dialectOptions.options);\n    }\n\n    try {\n      return await new Promise((resolve, reject) => {\n        const connection = new this.lib.Connection(connectionConfig);\n\n        if (connection.state === connection.STATE.INITIALIZED) {\n          connection.connect();\n        }\n\n        connection.queue = new AsyncQueue();\n        connection.lib = this.lib;\n\n        const connectHandler = error => {\n          connection.removeListener(\"end\", endHandler);\n          connection.removeListener(\"error\", errorHandler);\n          if (error) return reject(error);\n          debug(\"connection acquired\");\n          resolve(connection);\n        };\n\n        const endHandler = () => {\n          connection.removeListener(\"connect\", connectHandler);\n          connection.removeListener(\"error\", errorHandler);\n          reject(new Error(\"Connection was closed by remote server\"));\n        };\n\n        const errorHandler = error => {\n          connection.removeListener(\"connect\", connectHandler);\n          connection.removeListener(\"end\", endHandler);\n          reject(error);\n        };\n\n        connection.once(\"error\", errorHandler);\n        connection.once(\"end\", endHandler);\n        connection.once(\"connect\", connectHandler);\n        connection.on(\"error\", error => {\n          switch (error.code) {\n            case \"ESOCKET\":\n            case \"ECONNRESET\":\n              this.pool.destroy(connection);\n          }\n        });\n\n        if (config.dialectOptions && config.dialectOptions.debug) {\n          connection.on(\"debug\", debugTedious.log.bind(debugTedious));\n        }\n      });\n    } catch (error) {\n      if (!error.code) {\n        throw new sequelizeErrors.ConnectionError(error);\n      }\n\n      switch (error.code) {\n        case \"ESOCKET\":\n          if (error.message.includes(\"connect EHOSTUNREACH\")) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n\n          if (error.message.includes(\"connect ENETUNREACH\")) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n\n          if (error.message.includes(\"connect EADDRNOTAVAIL\")) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n\n          if (error.message.includes(\"connect EAFNOSUPPORT\")) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n\n          if (error.message.includes(\"getaddrinfo ENOTFOUND\")) {\n            throw new sequelizeErrors.HostNotFoundError(error);\n          }\n\n          if (error.message.includes(\"connect ECONNREFUSED\")) {\n            throw new sequelizeErrors.ConnectionRefusedError(error);\n          }\n\n          throw new sequelizeErrors.ConnectionError(error);\n\n        case \"ER_ACCESS_DENIED_ERROR\":\n        case \"ELOGIN\":\n          throw new sequelizeErrors.AccessDeniedError(error);\n\n        case \"EINVAL\":\n          throw new sequelizeErrors.InvalidConnectionError(error);\n\n        default:\n          throw new sequelizeErrors.ConnectionError(error);\n      }\n    }\n  }\n\n  async disconnect(connection) {\n    if (connection.closed) {\n      return;\n    }\n\n    connection.queue.close();\n    return new Promise(resolve => {\n      connection.on(\"end\", resolve);\n      connection.close();\n      debug(\"connection closed\");\n    });\n  }\n\n  validate(connection) {\n    return connection && (connection.loggedIn || connection.state.name === \"LoggedIn\");\n  }\n\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"mappings":";;AAEA,MAAMA,4BAA4BC,QAAQ,gCAAR,CAAlC;;AACA,MAAMC,aAAaD,QAAQ,eAAR,EAAyBE,OAA5C;;AACA,MAAM;EAAEC;AAAF,IAAaH,QAAQ,oBAAR,CAAnB;;AACA,MAAMI,kBAAkBJ,QAAQ,cAAR,CAAxB;;AACA,MAAMK,YAAYL,QAAQ,kBAAR,EAA4BM,KAA9C;;AACA,MAAMC,cAAcP,QAAQ,gBAAR,EAA0B,OAA1B,CAApB;;AACA,MAAMQ,QAAQL,OAAOM,YAAP,CAAoB,kBAApB,CAAd;AACA,MAAMC,eAAeP,OAAOM,YAAP,CAAoB,0BAApB,CAArB;;AAEA,gCAAgCV,yBAAhC,CAA0D;EACxDY,YAAYC,OAAZ,EAAqBC,SAArB,EAAgC;IAC9BA,UAAUC,MAAV,CAAiBC,IAAjB,GAAwBF,UAAUC,MAAV,CAAiBC,IAAjB,IAAyB,IAAjD;IACA,MAAMH,OAAN,EAAeC,SAAf;IACA,KAAKG,GAAL,GAAW,KAAKC,kBAAL,CAAwB,SAAxB,CAAX;IACA,KAAKC,iBAAL,CAAuBb,SAAvB;EAAuB;;EAGzBc,mBAAmBC,QAAnB,EAA6B;IAC3Bb,YAAYc,OAAZ,CAAoBD,QAApB;EAAoB;;EAGtBE,mBAAmB;IACjBf,YAAYgB,KAAZ;EAAY;;EAGR,cAAQT,MAAR,EAAgB;IACpB,MAAMU,mBAAmB;MACvBC,QAAQX,OAAOY,IADQ;MAEvBC,gBAAgB;QACdC,MAAM,SADQ;QAEdC,SAAS;UACPC,UAAUhB,OAAOiB,QAAP,IAAmB,MADtB;UAEPC,UAAUlB,OAAOkB,QAAP,IAAmB;QAFtB;MAFK,CAFO;MASvBH,SAAS;QACPd,MAAMkB,SAASnB,OAAOC,IAAhB,EAAsB,EAAtB,CADC;QAEPmB,UAAUpB,OAAOoB,QAFV;QAGPC,wBAAwB;MAHjB;IATc,CAAzB;;IAgBA,IAAIrB,OAAOsB,cAAX,EAA2B;MAEzB,IACEtB,OAAOsB,cAAP,CAAsBP,OAAtB,IACAf,OAAOsB,cAAP,CAAsBP,OAAtB,CAA8BQ,YAFhC,EAGE;QACA,OAAOb,iBAAiBK,OAAjB,CAAyBd,IAAhC;MAAgC;;MAGlC,IAAID,OAAOsB,cAAP,CAAsBT,cAA1B,EAA0C;QACxCW,OAAOC,MAAP,CAAcf,iBAAiBG,cAA/B,EAA+Cb,OAAOsB,cAAP,CAAsBT,cAArE;MAAqE;;MAGvEW,OAAOC,MAAP,CAAcf,iBAAiBK,OAA/B,EAAwCf,OAAOsB,cAAP,CAAsBP,OAA9D;IAA8D;;IAGhE,IAAI;MACF,OAAO,MAAM,IAAIW,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;QAC5C,MAAMC,aAAa,IAAI,KAAK3B,GAAL,CAAS4B,UAAb,CAAwBpB,gBAAxB,CAAnB;;QACA,IAAImB,WAAWE,KAAX,KAAqBF,WAAWG,KAAX,CAAiBC,WAA1C,EAAuD;UACrDJ,WAAWK,OAAX;QAAW;;QAEbL,WAAWM,KAAX,GAAmB,IAAIhD,UAAJ,EAAnB;QACA0C,WAAW3B,GAAX,GAAiB,KAAKA,GAAtB;;QAEA,MAAMkC,iBAAiBC,SAAS;UAC9BR,WAAWS,cAAX,CAA0B,KAA1B,EAAiCC,UAAjC;UACAV,WAAWS,cAAX,CAA0B,OAA1B,EAAmCE,YAAnC;UAEA,IAAIH,KAAJ,EAAW,OAAOT,OAAOS,KAAP,CAAP;UAEX3C,MAAM,qBAAN;UACAiC,QAAQE,UAAR;QAAQ,CAPV;;QAUA,MAAMU,aAAa,MAAM;UACvBV,WAAWS,cAAX,CAA0B,SAA1B,EAAqCF,cAArC;UACAP,WAAWS,cAAX,CAA0B,OAA1B,EAAmCE,YAAnC;UACAZ,OAAO,IAAIa,KAAJ,CAAU,wCAAV,CAAP;QAAiB,CAHnB;;QAMA,MAAMD,eAAeH,SAAS;UAC5BR,WAAWS,cAAX,CAA0B,SAA1B,EAAqCF,cAArC;UACAP,WAAWS,cAAX,CAA0B,KAA1B,EAAiCC,UAAjC;UACAX,OAAOS,KAAP;QAAO,CAHT;;QAMAR,WAAWa,IAAX,CAAgB,OAAhB,EAAyBF,YAAzB;QACAX,WAAWa,IAAX,CAAgB,KAAhB,EAAuBH,UAAvB;QACAV,WAAWa,IAAX,CAAgB,SAAhB,EAA2BN,cAA3B;QAUAP,WAAWc,EAAX,CAAc,OAAd,EAAuBN,SAAS;UAC9B,QAAQA,MAAMO,IAAd;YAAc,KACP,SADO;YACP,KACA,YADA;cAEH,KAAKC,IAAL,CAAUC,OAAV,CAAkBjB,UAAlB;UAHJ;QAGsB,CAJxB;;QAQA,IAAI7B,OAAOsB,cAAP,IAAyBtB,OAAOsB,cAAP,CAAsB5B,KAAnD,EAA0D;UACxDmC,WAAWc,EAAX,CAAc,OAAd,EAAuB/C,aAAamD,GAAb,CAAiBC,IAAjB,CAAsBpD,YAAtB,CAAvB;QAA6C;MAAA,CAnDpC,CAAb;IAmDiD,CApDnD,CAoDmD,OAG1CyC,KAH0C,EAGjD;MACA,IAAI,CAACA,MAAMO,IAAX,EAAiB;QACf,MAAM,IAAItD,gBAAgB2D,eAApB,CAAoCZ,KAApC,CAAN;MAA0C;;MAG5C,QAAQA,MAAMO,IAAd;QAAc,KACP,SADO;UAEV,IAAIP,MAAMa,OAAN,CAAcC,QAAd,CAAuB,sBAAvB,CAAJ,EAAoD;YAClD,MAAM,IAAI7D,gBAAgB8D,qBAApB,CAA0Cf,KAA1C,CAAN;UAAgD;;UAElD,IAAIA,MAAMa,OAAN,CAAcC,QAAd,CAAuB,qBAAvB,CAAJ,EAAmD;YACjD,MAAM,IAAI7D,gBAAgB8D,qBAApB,CAA0Cf,KAA1C,CAAN;UAAgD;;UAElD,IAAIA,MAAMa,OAAN,CAAcC,QAAd,CAAuB,uBAAvB,CAAJ,EAAqD;YACnD,MAAM,IAAI7D,gBAAgB8D,qBAApB,CAA0Cf,KAA1C,CAAN;UAAgD;;UAElD,IAAIA,MAAMa,OAAN,CAAcC,QAAd,CAAuB,sBAAvB,CAAJ,EAAoD;YAClD,MAAM,IAAI7D,gBAAgB8D,qBAApB,CAA0Cf,KAA1C,CAAN;UAAgD;;UAElD,IAAIA,MAAMa,OAAN,CAAcC,QAAd,CAAuB,uBAAvB,CAAJ,EAAqD;YACnD,MAAM,IAAI7D,gBAAgB+D,iBAApB,CAAsChB,KAAtC,CAAN;UAA4C;;UAE9C,IAAIA,MAAMa,OAAN,CAAcC,QAAd,CAAuB,sBAAvB,CAAJ,EAAoD;YAClD,MAAM,IAAI7D,gBAAgBgE,sBAApB,CAA2CjB,KAA3C,CAAN;UAAiD;;UAEnD,MAAM,IAAI/C,gBAAgB2D,eAApB,CAAoCZ,KAApC,CAAN;;QAA0C,KACvC,wBADuC;QACvC,KACA,QADA;UAEH,MAAM,IAAI/C,gBAAgBiE,iBAApB,CAAsClB,KAAtC,CAAN;;QAA4C,KACzC,QADyC;UAE5C,MAAM,IAAI/C,gBAAgBkE,sBAApB,CAA2CnB,KAA3C,CAAN;;QAAiD;UAEjD,MAAM,IAAI/C,gBAAgB2D,eAApB,CAAoCZ,KAApC,CAAN;MA3BJ;IA2B8C;EAAA;;EAK5C,iBAAWR,UAAX,EAAuB;IAE3B,IAAIA,WAAW4B,MAAf,EAAuB;MACrB;IAAA;;IAGF5B,WAAWM,KAAX,CAAiBuB,KAAjB;IAEA,OAAO,IAAIhC,OAAJ,CAAYC,WAAW;MAC5BE,WAAWc,EAAX,CAAc,KAAd,EAAqBhB,OAArB;MACAE,WAAW6B,KAAX;MACAhE,MAAM,mBAAN;IAAM,CAHD,CAAP;EAGQ;;EAIViE,SAAS9B,UAAT,EAAqB;IACnB,OAAOA,eAAeA,WAAW+B,QAAX,IAAuB/B,WAAWE,KAAX,CAAiB8B,IAAjB,KAA0B,UAAhE,CAAP;EAAuE;;AA7JjB;;AAiK1DC,OAAOC,OAAP,GAAiBC,iBAAjB;AACAF,OAAOC,OAAP,CAAeC,iBAAf,GAAmCA,iBAAnC;AACAF,OAAOC,OAAP,CAAe3E,OAAf,GAAyB4E,iBAAzB","names":["AbstractConnectionManager","require","AsyncQueue","default","logger","sequelizeErrors","DataTypes","mssql","parserStore","debug","debugContext","debugTedious","constructor","dialect","sequelize","config","port","lib","_loadDialectModule","refreshTypeParser","_refreshTypeParser","dataType","refresh","_clearTypeParser","clear","connectionConfig","server","host","authentication","type","options","userName","username","password","parseInt","database","trustServerCertificate","dialectOptions","instanceName","Object","assign","Promise","resolve","reject","connection","Connection","state","STATE","INITIALIZED","connect","queue","connectHandler","error","removeListener","endHandler","errorHandler","Error","once","on","code","pool","destroy","log","bind","ConnectionError","message","includes","HostNotReachableError","HostNotFoundError","ConnectionRefusedError","AccessDeniedError","InvalidConnectionError","closed","close","validate","loggedIn","name","module","exports","ConnectionManager"],"sources":["/Users/aurele/node_modules/sequelize/src/dialects/mssql/connection-manager.js"],"sourcesContent":["'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst AsyncQueue = require('./async-queue').default;\nconst { logger } = require('../../utils/logger');\nconst sequelizeErrors = require('../../errors');\nconst DataTypes = require('../../data-types').mssql;\nconst parserStore = require('../parserStore')('mssql');\nconst debug = logger.debugContext('connection:mssql');\nconst debugTedious = logger.debugContext('connection:mssql:tedious');\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 1433;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule('tedious');\n    this.refreshTypeParser(DataTypes);\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  async connect(config) {\n    const connectionConfig = {\n      server: config.host,\n      authentication: {\n        type: 'default',\n        options: {\n          userName: config.username || undefined,\n          password: config.password || undefined\n        }\n      },\n      options: {\n        port: parseInt(config.port, 10),\n        database: config.database,\n        trustServerCertificate: true\n      }\n    };\n\n    if (config.dialectOptions) {\n      // only set port if no instance name was provided\n      if (\n        config.dialectOptions.options &&\n        config.dialectOptions.options.instanceName\n      ) {\n        delete connectionConfig.options.port;\n      }\n\n      if (config.dialectOptions.authentication) {\n        Object.assign(connectionConfig.authentication, config.dialectOptions.authentication);\n      }\n\n      Object.assign(connectionConfig.options, config.dialectOptions.options);\n    }\n\n    try {\n      return await new Promise((resolve, reject) => {\n        const connection = new this.lib.Connection(connectionConfig);\n        if (connection.state === connection.STATE.INITIALIZED) {\n          connection.connect();\n        }\n        connection.queue = new AsyncQueue();\n        connection.lib = this.lib;\n\n        const connectHandler = error => {\n          connection.removeListener('end', endHandler);\n          connection.removeListener('error', errorHandler);\n\n          if (error) return reject(error);\n\n          debug('connection acquired');\n          resolve(connection);\n        };\n\n        const endHandler = () => {\n          connection.removeListener('connect', connectHandler);\n          connection.removeListener('error', errorHandler);\n          reject(new Error('Connection was closed by remote server'));\n        };\n\n        const errorHandler = error => {\n          connection.removeListener('connect', connectHandler);\n          connection.removeListener('end', endHandler);\n          reject(error);\n        };\n\n        connection.once('error', errorHandler);\n        connection.once('end', endHandler);\n        connection.once('connect', connectHandler);\n\n        /*\n         * Permanently attach this event before connection is even acquired\n         * tedious sometime emits error even after connect(with error).\n         *\n         * If we dont attach this even that unexpected error event will crash node process\n         *\n         * E.g. connectTimeout is set higher than requestTimeout\n         */\n        connection.on('error', error => {\n          switch (error.code) {\n            case 'ESOCKET':\n            case 'ECONNRESET':\n              this.pool.destroy(connection);\n          }\n        });\n\n        if (config.dialectOptions && config.dialectOptions.debug) {\n          connection.on('debug', debugTedious.log.bind(debugTedious));\n        }\n      });\n    } catch (error) {\n      if (!error.code) {\n        throw new sequelizeErrors.ConnectionError(error);\n      }\n\n      switch (error.code) {\n        case 'ESOCKET':\n          if (error.message.includes('connect EHOSTUNREACH')) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes('connect ENETUNREACH')) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes('connect EADDRNOTAVAIL')) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes('connect EAFNOSUPPORT')) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes('getaddrinfo ENOTFOUND')) {\n            throw new sequelizeErrors.HostNotFoundError(error);\n          }\n          if (error.message.includes('connect ECONNREFUSED')) {\n            throw new sequelizeErrors.ConnectionRefusedError(error);\n          }\n          throw new sequelizeErrors.ConnectionError(error);\n        case 'ER_ACCESS_DENIED_ERROR':\n        case 'ELOGIN':\n          throw new sequelizeErrors.AccessDeniedError(error);\n        case 'EINVAL':\n          throw new sequelizeErrors.InvalidConnectionError(error);\n        default:\n          throw new sequelizeErrors.ConnectionError(error);\n      }\n    }\n  }\n\n  async disconnect(connection) {\n    // Don't disconnect a connection that is already disconnected\n    if (connection.closed) {\n      return;\n    }\n\n    connection.queue.close();\n\n    return new Promise(resolve => {\n      connection.on('end', resolve);\n      connection.close();\n      debug('connection closed');\n    });\n  }\n\n  validate(connection) {\n    return connection && (connection.loggedIn || connection.state.name === 'LoggedIn');\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"]},"metadata":{},"sourceType":"script"}