{"ast":null,"code":"\"use strict\";\n\nconst Toposort = require(\"toposort-class\");\n\nconst _ = require(\"lodash\");\n\nclass ModelManager {\n  constructor(sequelize) {\n    this.models = [];\n    this.sequelize = sequelize;\n  }\n\n  addModel(model) {\n    this.models.push(model);\n    this.sequelize.models[model.name] = model;\n    return model;\n  }\n\n  removeModel(modelToRemove) {\n    this.models = this.models.filter(model => model.name !== modelToRemove.name);\n    delete this.sequelize.models[modelToRemove.name];\n  }\n\n  getModel(against, options) {\n    options = _.defaults(options || {}, {\n      attribute: \"name\"\n    });\n    return this.models.find(model => model[options.attribute] === against);\n  }\n\n  get all() {\n    return this.models;\n  }\n\n  getModelsTopoSortedByForeignKey() {\n    const models = /* @__PURE__ */new Map();\n    const sorter = new Toposort();\n\n    for (const model of this.models) {\n      let deps = [];\n      let tableName = model.getTableName();\n\n      if (_.isObject(tableName)) {\n        tableName = `${tableName.schema}.${tableName.tableName}`;\n      }\n\n      models.set(tableName, model);\n\n      for (const attrName in model.rawAttributes) {\n        if (Object.prototype.hasOwnProperty.call(model.rawAttributes, attrName)) {\n          const attribute = model.rawAttributes[attrName];\n\n          if (attribute.references) {\n            let dep = attribute.references.model;\n\n            if (_.isObject(dep)) {\n              dep = `${dep.schema}.${dep.tableName}`;\n            }\n\n            deps.push(dep);\n          }\n        }\n      }\n\n      deps = deps.filter(dep => tableName !== dep);\n      sorter.add(tableName, deps);\n    }\n\n    let sorted;\n\n    try {\n      sorted = sorter.sort();\n    } catch (e) {\n      if (!e.message.startsWith(\"Cyclic dependency found.\")) {\n        throw e;\n      }\n\n      return null;\n    }\n\n    return sorted.map(modelName => {\n      return models.get(modelName);\n    }).filter(Boolean);\n  }\n\n  forEachModel(iterator, options) {\n    const sortedModels = this.getModelsTopoSortedByForeignKey();\n\n    if (sortedModels == null) {\n      throw new Error(\"Cyclic dependency found.\");\n    }\n\n    options = _.defaults(options || {}, {\n      reverse: true\n    });\n\n    if (options.reverse) {\n      sortedModels.reverse();\n    }\n\n    for (const model of sortedModels) {\n      iterator(model);\n    }\n  }\n\n}\n\nmodule.exports = ModelManager;\nmodule.exports.ModelManager = ModelManager;\nmodule.exports.default = ModelManager;","map":{"version":3,"mappings":"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","names":["Toposort","require","_","constructor","sequelize","models","addModel","model","push","name","removeModel","modelToRemove","filter","getModel","against","options","defaults","attribute","find","getModelsTopoSortedByForeignKey","Map","sorter","deps","tableName","getTableName","isObject","schema","set","attrName","rawAttributes","Object","prototype","hasOwnProperty","call","references","dep","add","sorted","sort","e","message","startsWith","map","modelName","get","Boolean","forEachModel","iterator","sortedModels","Error","reverse","module","exports","ModelManager","default"],"sources":["/Users/aurele/node_modules/sequelize/src/model-manager.js"],"sourcesContent":["'use strict';\n\nconst Toposort = require('toposort-class');\nconst _ = require('lodash');\n\nclass ModelManager {\n  constructor(sequelize) {\n    this.models = [];\n    this.sequelize = sequelize;\n  }\n\n  addModel(model) {\n    this.models.push(model);\n    this.sequelize.models[model.name] = model;\n\n    return model;\n  }\n\n  removeModel(modelToRemove) {\n    this.models = this.models.filter(model => model.name !== modelToRemove.name);\n\n    delete this.sequelize.models[modelToRemove.name];\n  }\n\n  getModel(against, options) {\n    options = _.defaults(options || {}, {\n      attribute: 'name'\n    });\n\n    return this.models.find(model => model[options.attribute] === against);\n  }\n\n  get all() {\n    return this.models;\n  }\n\n  /**\n   * Returns an array that lists every model, sorted in order\n   * of foreign key references: The first model is a model that is depended upon,\n   * the last model is a model that is not depended upon.\n   *\n   * If there is a cyclic dependency, this returns null.\n   */\n  getModelsTopoSortedByForeignKey() {\n    const models = new Map();\n    const sorter = new Toposort();\n\n    for (const model of this.models) {\n      let deps = [];\n      let tableName = model.getTableName();\n\n      if (_.isObject(tableName)) {\n        tableName = `${tableName.schema}.${tableName.tableName}`;\n      }\n\n      models.set(tableName, model);\n\n      for (const attrName in model.rawAttributes) {\n        if (Object.prototype.hasOwnProperty.call(model.rawAttributes, attrName)) {\n          const attribute = model.rawAttributes[attrName];\n\n          if (attribute.references) {\n            let dep = attribute.references.model;\n\n            if (_.isObject(dep)) {\n              dep = `${dep.schema}.${dep.tableName}`;\n            }\n\n            deps.push(dep);\n          }\n        }\n      }\n\n      deps = deps.filter(dep => tableName !== dep);\n\n      sorter.add(tableName, deps);\n    }\n\n    let sorted;\n    try {\n      sorted = sorter.sort();\n    } catch (e) {\n      if (!e.message.startsWith('Cyclic dependency found.')) {\n        throw e;\n      }\n\n      return null;\n    }\n\n    return sorted\n      .map(modelName => {\n        return models.get(modelName);\n      })\n      .filter(Boolean);\n  }\n\n  /**\n   * Iterate over Models in an order suitable for e.g. creating tables.\n   * Will take foreign key constraints into account so that dependencies are visited before dependents.\n   *\n   * @param {Function} iterator method to execute on each model\n   * @param {object} options\n   * @private\n   *\n   * @deprecated\n   */\n  forEachModel(iterator, options) {\n    const sortedModels = this.getModelsTopoSortedByForeignKey();\n    if (sortedModels == null) {\n      throw new Error('Cyclic dependency found.');\n    }\n\n    options = _.defaults(options || {}, {\n      reverse: true\n    });\n\n    if (options.reverse) {\n      sortedModels.reverse();\n    }\n\n    for (const model of sortedModels) {\n      iterator(model);\n    }\n  }\n}\n\nmodule.exports = ModelManager;\nmodule.exports.ModelManager = ModelManager;\nmodule.exports.default = ModelManager;\n"]},"metadata":{},"sourceType":"script"}